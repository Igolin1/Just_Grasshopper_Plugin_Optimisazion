===== IntraLattice\IntraLatticeInfo.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;

namespace IntraLattice;

public class IntraLatticeInfo : GH_AssemblyInfo
{
	public override string Name => "IntraLattice";

	public override Bitmap Icon => null;

	public override string Description => "";

	public override Guid Id => new Guid("df475ca3-9a35-471e-9348-f2b7c04e9189");

	public override string AuthorName => "Aidan Kurtz";

	public override string AuthorContact => "aidan.kurtz@mail.mcgill.ca";
}


===== IntraLattice.CORE.Components\BasicBoxComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class BasicBoxComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.basicBox;

	public override Guid ComponentGuid => new Guid("{3d9572a6-0783-4885-9b11-df464cf549a7}");

	public BasicBoxComponent()
		: base("Basic Box", "BasicBox", "Generates a lattice box.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddNumberParameter("Cell Size ( x )", "CSx", "Size of unit cell (x)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( y )", "CSy", "Size of unit cell (y)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( z )", "CSz", "Size of unit cell (z)", (GH_ParamAccess)0, 5.0);
		pManager.AddIntegerParameter("Number of Cells ( x )", "Nx", "Number of unit cells (x)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number of Cells ( y )", "Ny", "Number of unit cells (y)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number of Cells ( z )", "Nz", "Number of unit cells (z)", (GH_ParamAccess)0, 5);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Expected O, but got Unknown
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		int num4 = 0;
		int num5 = 0;
		int num6 = 0;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<double>(1, ref num) || !DA.GetData<double>(2, ref num2) || !DA.GetData<double>(3, ref num3) || !DA.GetData<int>(4, ref num4) || !DA.GetData<int>(5, ref num5) || !DA.GetData<int>(6, ref num6) || !unitCell.isValid || num == 0.0 || num2 == 0.0 || num3 == 0.0 || num4 == 0 || num5 == 0 || num6 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Plane worldXY = Plane.WorldXY;
		Vector3d val = num * ((Plane)(ref worldXY)).XAxis;
		Vector3d val2 = num2 * ((Plane)(ref worldXY)).YAxis;
		Vector3d val3 = num3 * ((Plane)(ref worldXY)).ZAxis;
		float[] array = new float[3] { num4, num5, num6 };
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val4 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val4);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val5 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val5)).X;
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val6)).Y;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val7)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag2 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag || flag2)
						{
							list.Add(null);
							continue;
						}
						Vector3d val8 = array2[0] * val + array2[1] * val2 + array2[2] * val3;
						LatticeNode item = new LatticeNode(((Plane)(ref worldXY)).Origin + val8);
						list.Add(item);
					}
				}
			}
		}
		lattice.ConformMapping(unitCell, array);
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\BasicCylinderComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class BasicCylinderComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.basicCylinder;

	public override Guid ComponentGuid => new Guid("{9f6769c0-dec5-4a0d-8ade-76fca1dfd4e3}");

	public BasicCylinderComponent()
		: base("Basic Cylinder", "BasicCylinder", "Generates a conformal lattice cylinder.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddNumberParameter("Radius", "R", "Radius of cylinder", (GH_ParamAccess)0, 15.0);
		pManager.AddNumberParameter("Height", "H", "Height of cylinder", (GH_ParamAccess)0, 25.0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (axial)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (theta)", (GH_ParamAccess)0, 15);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (radial)", (GH_ParamAccess)0, 4);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Expected O, but got Unknown
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Expected O, but got Unknown
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Expected O, but got Unknown
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031d: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		double num = 0.0;
		double num2 = 0.0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<double>(1, ref num) || !DA.GetData<double>(2, ref num2) || !DA.GetData<int>(3, ref num3) || !DA.GetData<int>(4, ref num4) || !DA.GetData<int>(5, ref num5) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || num == 0.0 || num2 == 0.0 || num3 == 0 || num4 == 0 || num5 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val = new DataTree<GeometryBase>();
		Plane worldXY = Plane.WorldXY;
		Cylinder val2 = new Cylinder(new Circle(worldXY, num), num2);
		Surface val3 = (Surface)(object)((Cylinder)(ref val2)).ToNurbsSurface();
		val3 = val3.Transpose();
		LineCurve val4 = new LineCurve(((Plane)(ref worldXY)).Origin, ((Plane)(ref worldXY)).Origin + num2 * ((Plane)(ref worldXY)).ZAxis);
		float[] array = new float[3] { num3, num4, num5 };
		Interval val5 = default(Interval);
		((Interval)(ref val5))._002Ector(0.0, 1.0);
		val3.SetDomain(0, val5);
		val3.SetDomain(1, val5);
		((Curve)val4).Domain = val5;
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Point3d val12 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Interval val15 = default(Interval);
		Interval val16 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val6 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val6);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val7)).X;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val8)).Y;
						Point3d val9 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val9)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list.Add(null);
							continue;
						}
						Vector3d val10 = num2 * ((Plane)(ref worldXY)).ZAxis * array2[0] / (double)array[0];
						Point3d val11 = ((Plane)(ref worldXY)).Origin + val10;
						val3.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val12, ref array3);
						Vector3d val13 = val12 - val11;
						LatticeNode item = new LatticeNode(val11 + val13 * array2[2] / (double)array[2]);
						list.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val14 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val15))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val16))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val17 = val3.Trim(val15, val16);
					Curve val18 = ((Curve)val4).Trim(val15);
					val17.SetDomain(0, val5);
					val17.SetDomain(1, val5);
					val18.Domain = val5;
					val.Add((GeometryBase)(object)val17, val14);
					val.Add((GeometryBase)(object)val18, val14);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\ConformSAComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class ConformSAComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.conformSA;

	public override Guid ComponentGuid => new Guid("{e0e8a858-66bd-4145-b173-23dc2e247206}");

	public ConformSAComponent()
		: base("Conform Surface-Axis", "ConformSA", "Generates a conforming lattice between a surface and an axis.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface", "Surf", "Surface to conform to", (GH_ParamAccess)0);
		pManager.AddCurveParameter("Axis", "A", "Axis (may be curved)", (GH_ParamAccess)0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (u)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (v)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (w)", (GH_ParamAccess)0, 5);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Expected O, but got Unknown
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Expected O, but got Unknown
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		Surface val = null;
		Curve val2 = null;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<Surface>(1, ref val) || !DA.GetData<Curve>(2, ref val2) || !DA.GetData<int>(3, ref num) || !DA.GetData<int>(4, ref num2) || !DA.GetData<int>(5, ref num3) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || !((CommonObject)val).IsValid || !((CommonObject)val2).IsValid || num == 0 || num2 == 0 || num3 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val3 = new DataTree<GeometryBase>();
		float[] array = new float[3] { num, num2, num3 };
		Interval val4 = default(Interval);
		((Interval)(ref val4))._002Ector(0.0, 1.0);
		val.SetDomain(0, val4);
		val.SetDomain(1, val4);
		val2.Domain = val4;
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		List<double> list = new List<double>(val2.DivideByCount((int)array[0], true));
		_ = list[1];
		_ = list[0];
		if (val2.IsClosed)
		{
			list.Add(0.0);
		}
		Point3d val10 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Interval val13 = default(Interval);
		Interval val14 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val5 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list2 = lattice.Nodes.EnsurePath(val5);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val6)).X;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val7)).Y;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val8)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list2.Add(null);
							continue;
						}
						Point3d val9 = val2.PointAt(list[i] + x / (double)array[0]);
						val.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val10, ref array3);
						Vector3d val11 = val10 - val9;
						LatticeNode item = new LatticeNode(val9 + val11 * array2[2] / (double)array[2]);
						list2.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val12 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val13))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val14))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val15 = val.Trim(val13, val14);
					Curve val16 = val2.Trim(val13);
					val15.SetDomain(0, val4);
					val15.SetDomain(1, val4);
					val16.Domain = val4;
					val3.Add((GeometryBase)(object)val15, val12);
					val3.Add((GeometryBase)(object)val16, val12);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val3, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\ConformSPComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class ConformSPComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.conformSP;

	public override Guid ComponentGuid => new Guid("{27cbc46a-3ef6-4f00-9a66-d6afd6b7b2fe}");

	public ConformSPComponent()
		: base("Conform Surface-Point", "ConformSP", "Generates a conforming lattice between a surface and a point.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface", "Surf", "Surface to conform to", (GH_ParamAccess)0);
		pManager.AddPointParameter("Point", "Pt", "Point", (GH_ParamAccess)0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (u)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (v)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (w)", (GH_ParamAccess)0, 5);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Expected O, but got Unknown
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Expected O, but got Unknown
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_034f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		Surface val = null;
		Point3d unset = Point3d.Unset;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<Surface>(1, ref val) || !DA.GetData<Point3d>(2, ref unset) || !DA.GetData<int>(3, ref num) || !DA.GetData<int>(4, ref num2) || !DA.GetData<int>(5, ref num3) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || !((CommonObject)val).IsValid || !((Point3d)(ref unset)).IsValid || num == 0 || num2 == 0 || num3 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val2 = new DataTree<GeometryBase>();
		float[] array = new float[3] { num, num2, num3 };
		Interval val3 = default(Interval);
		((Interval)(ref val3))._002Ector(0.0, 1.0);
		val.SetDomain(0, val3);
		val.SetDomain(1, val3);
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Point3d val9 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Interval val12 = default(Interval);
		Interval val13 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val4 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val4);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val5 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val5)).X;
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val6)).Y;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val7)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list.Add(null);
							continue;
						}
						Point3d val8 = unset;
						val.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val9, ref array3);
						Vector3d val10 = val9 - val8;
						LatticeNode item = new LatticeNode(val8 + val10 * array2[2] / (double)array[2]);
						list.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val11 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val12))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val13))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val14 = val.Trim(val12, val13);
					Point val15 = new Point(unset);
					val14.SetDomain(0, val3);
					val14.SetDomain(1, val3);
					val2.Add((GeometryBase)(object)val14, val11);
					val2.Add((GeometryBase)(object)val15, val11);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val2, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\ConformSSComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class ConformSSComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.conformSS;

	public override Guid ComponentGuid => new Guid("{ac0814b4-00e7-4efb-add5-e845a831c6da}");

	public ConformSSComponent()
		: base("Conform Surface-Surface", "ConformSS", "Generates a conforming lattice between two surfaces.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface 1", "S1", "First bounding surface", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface 2", "S2", "Second bounding surface", (GH_ParamAccess)0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (u)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (v)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (w)", (GH_ParamAccess)0, 5);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Expected O, but got Unknown
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Expected O, but got Unknown
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		Surface val = null;
		Surface val2 = null;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<Surface>(1, ref val) || !DA.GetData<Surface>(2, ref val2) || !DA.GetData<int>(3, ref num) || !DA.GetData<int>(4, ref num2) || !DA.GetData<int>(5, ref num3) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || !((CommonObject)val).IsValid || !((CommonObject)val2).IsValid || num == 0 || num2 == 0 || num3 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val3 = new DataTree<GeometryBase>();
		float[] array = new float[3] { num, num2, num3 };
		Interval val4 = default(Interval);
		((Interval)(ref val4))._002Ector(0.0, 1.0);
		val.SetDomain(0, val4);
		val.SetDomain(1, val4);
		val2.SetDomain(0, val4);
		val2.SetDomain(1, val4);
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Point3d val9 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Point3d val10 = default(Point3d);
		Vector3d[] array4 = default(Vector3d[]);
		Interval val13 = default(Interval);
		Interval val14 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val5 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val5);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val6)).X;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val7)).Y;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val8)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list.Add(null);
							continue;
						}
						val.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val9, ref array3);
						val2.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val10, ref array4);
						Vector3d val11 = val10 - val9;
						LatticeNode item = new LatticeNode(val9 + val11 * array2[2] / (double)array[2]);
						list.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val12 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val13))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val14))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val15 = val.Trim(val13, val14);
					Surface val16 = val2.Trim(val13, val14);
					val15.SetDomain(0, val4);
					val15.SetDomain(1, val4);
					val16.SetDomain(0, val4);
					val16.SetDomain(1, val4);
					val3.Add((GeometryBase)(object)val15, val12);
					val3.Add((GeometryBase)(object)val16, val12);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val3, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\CustomCellComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.CORE.Data.GH_Goo;
using IntraLattice.Properties;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class CustomCellComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.customCell;

	public override Guid ComponentGuid => new Guid("{93998286-27d4-40a3-8f0e-043de932b931}");

	public CustomCellComponent()
		: base("Custom Cell", "CustomCell", "Pre-processes a custom unit cell by check validity and outputting topology.", "IntraLattice", "Cell")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Custom Cell", "L", "Unit cell lines (curves must be linear).", (GH_ParamAccess)1);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Verified unit cell topology", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		List<Curve> list = new List<Curve>();
		if (!DA.GetDataList<Curve>(0, list))
		{
			return;
		}
		List<Line> list2 = new List<Line>();
		foreach (Curve item in list)
		{
			if (!item.IsLinear())
			{
				((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "All struts must be linear.");
				return;
			}
			list2.Add(new Line(item.PointAtStart, item.PointAtEnd));
		}
		UnitCell unitCell = new UnitCell(list2);
		switch (unitCell.CheckValidity())
		{
		case -1:
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Invalid cell - opposing faces must be identical.");
			return;
		case 0:
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Invalid cell - each face needs at least one node lying on it.");
			return;
		case 1:
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)0, "Your cell is valid!");
			break;
		}
		DA.SetData(0, (object)new UnitCellGoo(unitCell));
	}
}


===== IntraLattice.CORE.Components\PresetCellComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.CORE.Data.GH_Goo;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class PresetCellComponent : GH_Component
{
	private GH_Document GrasshopperDocument;

	private IGH_Component Component;

	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.presetCell;

	public override Guid ComponentGuid => new Guid("{508cc705-bc5b-42a9-8100-c1e364f3b83d}");

	public PresetCellComponent()
		: base("Preset Cell", "PresetCell", "Built-in selection of unit cell topologies.", "IntraLattice", "Cell")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddIntegerParameter("Cell Tye", "Type", "Unit cell topology type", (GH_ParamAccess)0, 0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddLineParameter("Lines", "L", "Optional output so you can modify the unit cell lines. Pass through the CustomCell component when you're done.", (GH_ParamAccess)1);
		pManager.HideParameter(1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Component = (IGH_Component)(object)this;
		GrasshopperDocument = ((GH_DocumentObject)this).OnPingDocument();
		if (Component.Params.Input[0].SourceCount == 0)
		{
			InputTools.TopoSelect(ref Component, ref GrasshopperDocument, 0, 11f);
		}
		int num = 0;
		if (!DA.GetData<int>(0, ref num))
		{
			return;
		}
		List<Line> rawCell = new List<Line>();
		double d = 5.0;
		switch (num)
		{
		case 0:
			rawCell = GridLines(d);
			break;
		case 1:
			rawCell = XLines(d);
			break;
		case 2:
			rawCell = StarLines(d);
			break;
		case 3:
			rawCell = CrossLines(d);
			break;
		case 4:
			rawCell = TesseractLines(d);
			break;
		case 5:
			rawCell = VintileLines(d);
			break;
		case 6:
			rawCell = OctetLines(d);
			break;
		case 7:
			rawCell = DiamondLines(d);
			break;
		case 8:
			rawCell = Honeycomb(d);
			break;
		case 9:
			rawCell = AuxeticHoneycomb(d);
			break;
		}
		UnitCell unitCell = new UnitCell(rawCell);
		if (!unitCell.isValid)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Invalid cell - this is embarassing.");
		}
		List<Line> list = new List<Line>();
		foreach (IndexPair nodePair in unitCell.NodePairs)
		{
			IndexPair current = nodePair;
			list.Add(new Line(((RhinoList<Point3d>)(object)unitCell.Nodes)[((IndexPair)(ref current)).I], ((RhinoList<Point3d>)(object)unitCell.Nodes)[((IndexPair)(ref current)).J]));
		}
		DA.SetData(0, (object)new UnitCellGoo(unitCell));
		DA.SetDataList(1, (IEnumerable)list);
	}

	private List<Line> GridLines(double d)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		int[] array = new int[3] { 1, 3, 4 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[0], nodes[index]));
		}
		int[] array2 = new int[3] { 1, 3, 6 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[2], nodes[index2]));
		}
		int[] array3 = new int[3] { 1, 4, 6 };
		foreach (int index3 in array3)
		{
			list.Add(new Line(nodes[5], nodes[index3]));
		}
		int[] array4 = new int[3] { 3, 4, 6 };
		foreach (int index4 in array4)
		{
			list.Add(new Line(nodes[7], nodes[index4]));
		}
		return list;
	}

	private List<Line> XLines(double d)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		list.Add(new Line(nodes[0], nodes[6]));
		list.Add(new Line(nodes[1], nodes[7]));
		list.Add(new Line(nodes[3], nodes[5]));
		list.Add(new Line(nodes[2], nodes[4]));
		return list;
	}

	private List<Line> StarLines(double d)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		list.Add(new Line(nodes[0], nodes[6]));
		list.Add(new Line(nodes[1], nodes[7]));
		list.Add(new Line(nodes[3], nodes[5]));
		list.Add(new Line(nodes[2], nodes[4]));
		int[] array = new int[3] { 1, 3, 4 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[0], nodes[index]));
		}
		int[] array2 = new int[3] { 1, 3, 6 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[2], nodes[index2]));
		}
		int[] array3 = new int[3] { 1, 4, 6 };
		foreach (int index3 in array3)
		{
			list.Add(new Line(nodes[5], nodes[index3]));
		}
		int[] array4 = new int[3] { 3, 4, 6 };
		foreach (int index4 in array4)
		{
			list.Add(new Line(nodes[7], nodes[index4]));
		}
		return list;
	}

	private List<Line> DiamondLines(double d)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		list2.Add(new Point3d(0.0, 0.0, 0.0));
		list2.Add(new Point3d(0.0, d / 2.0, d / 2.0));
		list2.Add(new Point3d(d / 2.0, 0.0, d / 2.0));
		list2.Add(new Point3d(d / 2.0, d / 2.0, 0.0));
		list2.Add(new Point3d(d / 4.0, d / 4.0, d / 4.0));
		list.Add(new Line(list2[4], list2[0]));
		list.Add(new Line(list2[4], list2[1]));
		list.Add(new Line(list2[4], list2[2]));
		list.Add(new Line(list2[4], list2[3]));
		List<Line> list3 = new List<Line>(list);
		Line item = default(Line);
		foreach (Line item4 in list)
		{
			Line current = item4;
			((Line)(ref item))._002Ector(((Line)(ref current)).From, ((Line)(ref current)).To);
			((Line)(ref item)).Transform(Transform.Translation(d / 2.0, d / 2.0, 0.0));
			list3.Add(item);
		}
		Line item2 = default(Line);
		foreach (Line item5 in list)
		{
			Line current2 = item5;
			((Line)(ref item2))._002Ector(((Line)(ref current2)).From, ((Line)(ref current2)).To);
			((Line)(ref item2)).Transform(Transform.Rotation(Math.PI / 2.0, list2[4]));
			((Line)(ref item2)).Transform(Transform.Translation(d / 2.0, d / 2.0, d / 2.0));
			list3.Add(item2);
		}
		Line item3 = default(Line);
		foreach (Line item6 in list)
		{
			Line current3 = item6;
			((Line)(ref item3))._002Ector(((Line)(ref current3)).From, ((Line)(ref current3)).To);
			((Line)(ref item3)).Transform(Transform.Rotation(Math.PI / 2.0, list2[4]));
			((Line)(ref item3)).Transform(Transform.Translation(0.0, 0.0, d / 2.0));
			list3.Add(item3);
		}
		list.AddRange(list3);
		return list;
	}

	private List<Line> CrossLines(double d)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		int[] array = new int[2] { 5, 7 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[0], nodes[index]));
			list.Add(new Line(nodes[2], nodes[index]));
		}
		int[] array2 = new int[2] { 4, 6 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[1], nodes[index2]));
			list.Add(new Line(nodes[3], nodes[index2]));
		}
		int[] array3 = new int[4] { 0, 1, 4, 5 };
		foreach (int num in array3)
		{
			list.Add(new Line(nodes[num], nodes[num + 2]));
		}
		return list;
	}

	private List<Line> TesseractLines(double d)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		nodes.Add(new Point3d(d / 4.0, d / 4.0, d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, d / 4.0, d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, 3.0 * d / 4.0, d / 4.0));
		nodes.Add(new Point3d(d / 4.0, 3.0 * d / 4.0, d / 4.0));
		nodes.Add(new Point3d(d / 4.0, d / 4.0, 3.0 * d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, d / 4.0, 3.0 * d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, 3.0 * d / 4.0, 3.0 * d / 4.0));
		nodes.Add(new Point3d(d / 4.0, 3.0 * d / 4.0, 3.0 * d / 4.0));
		int[] array = new int[3] { 1, 3, 4 };
		foreach (int num in array)
		{
			list.Add(new Line(nodes[0], nodes[num]));
			list.Add(new Line(nodes[8], nodes[num + 8]));
		}
		int[] array2 = new int[3] { 1, 3, 6 };
		foreach (int num2 in array2)
		{
			list.Add(new Line(nodes[2], nodes[num2]));
			list.Add(new Line(nodes[10], nodes[num2 + 8]));
		}
		int[] array3 = new int[3] { 1, 4, 6 };
		foreach (int num3 in array3)
		{
			list.Add(new Line(nodes[5], nodes[num3]));
			list.Add(new Line(nodes[13], nodes[num3 + 8]));
		}
		int[] array4 = new int[3] { 3, 4, 6 };
		foreach (int num4 in array4)
		{
			list.Add(new Line(nodes[7], nodes[num4]));
			list.Add(new Line(nodes[15], nodes[num4 + 8]));
		}
		for (int m = 0; m < 8; m++)
		{
			list.Add(new Line(nodes[m], nodes[m + 8]));
		}
		return list;
	}

	private List<Line> VintileLines(double d)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_0439: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0479: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_0486: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0516: Unknown result type (might be due to invalid IL or missing references)
		//IL_0551: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0560: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0604: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		double[] array = new double[2] { 0.0, d };
		foreach (double num in array)
		{
			list2.Add(new Point3d(0.0, d / 4.0, num));
			list2.Add(new Point3d(0.0, 3.0 * d / 4.0, num));
			list2.Add(new Point3d(d / 4.0, d, num));
			list2.Add(new Point3d(3.0 * d / 4.0, d, num));
			list2.Add(new Point3d(d, 3.0 * d / 4.0, num));
			list2.Add(new Point3d(d, d / 4.0, num));
			list2.Add(new Point3d(3.0 * d / 4.0, 0.0, num));
			list2.Add(new Point3d(d / 4.0, 0.0, num));
		}
		double[] array2 = new double[2]
		{
			d / 4.0,
			3.0 * d / 4.0
		};
		foreach (double num2 in array2)
		{
			list2.Add(new Point3d(0.0, d / 2.0, num2));
			list2.Add(new Point3d(d / 2.0, d, num2));
			list2.Add(new Point3d(d, d / 2.0, num2));
			list2.Add(new Point3d(d / 2.0, 0.0, num2));
		}
		double[] array3 = new double[2]
		{
			d / 4.0,
			3.0 * d / 4.0
		};
		foreach (double num3 in array3)
		{
			list2.Add(new Point3d(d / 2.0, num3, d / 2.0));
		}
		double[] array4 = new double[2]
		{
			d / 4.0,
			3.0 * d / 4.0
		};
		foreach (double num4 in array4)
		{
			list2.Add(new Point3d(num4, d / 2.0, d / 2.0));
		}
		int[] array5 = new int[3] { 0, 1, 26 };
		foreach (int index in array5)
		{
			list.Add(new Line(list2[16], list2[index]));
		}
		int[] array6 = new int[3] { 2, 3, 25 };
		foreach (int index2 in array6)
		{
			list.Add(new Line(list2[17], list2[index2]));
		}
		int[] array7 = new int[3] { 4, 5, 27 };
		foreach (int index3 in array7)
		{
			list.Add(new Line(list2[18], list2[index3]));
		}
		int[] array8 = new int[3] { 6, 7, 24 };
		foreach (int index4 in array8)
		{
			list.Add(new Line(list2[19], list2[index4]));
		}
		int[] array9 = new int[3] { 8, 9, 26 };
		foreach (int index5 in array9)
		{
			list.Add(new Line(list2[20], list2[index5]));
		}
		int[] array10 = new int[3] { 10, 11, 25 };
		foreach (int index6 in array10)
		{
			list.Add(new Line(list2[21], list2[index6]));
		}
		int[] array11 = new int[3] { 12, 13, 27 };
		foreach (int index7 in array11)
		{
			list.Add(new Line(list2[22], list2[index7]));
		}
		int[] array12 = new int[3] { 14, 15, 24 };
		foreach (int index8 in array12)
		{
			list.Add(new Line(list2[23], list2[index8]));
		}
		int[] array13 = new int[6] { 1, 3, 5, 9, 11, 13 };
		foreach (int num12 in array13)
		{
			list.Add(new Line(list2[num12], list2[num12 + 1]));
		}
		int[] array14 = new int[2] { 24, 25 };
		foreach (int index9 in array14)
		{
			list.Add(new Line(list2[26], list2[index9]));
			list.Add(new Line(list2[27], list2[index9]));
		}
		list.Add(new Line(list2[0], list2[7]));
		list.Add(new Line(list2[8], list2[15]));
		return list;
	}

	private List<Line> OctetLines(double d)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		nodes.Add(new Point3d(d, d / 2.0, d / 2.0));
		nodes.Add(new Point3d(d / 2.0, d, d / 2.0));
		nodes.Add(new Point3d(0.0, d / 2.0, d / 2.0));
		nodes.Add(new Point3d(d / 2.0, 0.0, d / 2.0));
		nodes.Add(new Point3d(d / 2.0, d / 2.0, 0.0));
		nodes.Add(new Point3d(d / 2.0, d / 2.0, d));
		int[] array = new int[8] { 0, 1, 2, 3, 8, 9, 10, 11 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[12], nodes[index]));
		}
		int[] array2 = new int[8] { 4, 5, 6, 7, 8, 9, 10, 11 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[13], nodes[index2]));
		}
		int[] array3 = new int[4] { 0, 3, 4, 7 };
		foreach (int index3 in array3)
		{
			list.Add(new Line(nodes[10], nodes[index3]));
		}
		int[] array4 = new int[6] { 2, 3, 6, 7, 8, 10 };
		foreach (int index4 in array4)
		{
			list.Add(new Line(nodes[9], nodes[index4]));
		}
		int[] array5 = new int[4] { 1, 2, 5, 6 };
		foreach (int index5 in array5)
		{
			list.Add(new Line(nodes[8], nodes[index5]));
		}
		int[] array6 = new int[6] { 0, 1, 4, 5, 8, 10 };
		foreach (int index6 in array6)
		{
			list.Add(new Line(nodes[11], nodes[index6]));
		}
		return list;
	}

	private List<Line> Honeycomb(double d)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		for (int i = 0; i < 2; i++)
		{
			double num = 3.0 * d * (double)i;
			list2.Add(new Point3d(2.25 * d, num, 2.0 * d));
			list2.Add(new Point3d(2.25 * d, num, d));
			list2.Add(new Point3d(0.75 * d, num, 2.0 * d));
			list2.Add(new Point3d(0.75 * d, num, d));
			list2.Add(new Point3d(0.0, num, 0.0));
			list2.Add(new Point3d(0.0, num, 0.5 * d));
			list2.Add(new Point3d(0.0, num, 2.5 * d));
			list2.Add(new Point3d(0.0, num, 3.0 * d));
			list2.Add(new Point3d(1.5 * d, num, 0.0));
			list2.Add(new Point3d(1.5 * d, num, 0.5 * d));
			list2.Add(new Point3d(1.5 * d, num, 2.5 * d));
			list2.Add(new Point3d(1.5 * d, num, 3.0 * d));
			list2.Add(new Point3d(3.0 * d, num, 0.0));
			list2.Add(new Point3d(3.0 * d, num, 0.5 * d));
			list2.Add(new Point3d(3.0 * d, num, 2.5 * d));
			list2.Add(new Point3d(3.0 * d, num, 3.0 * d));
		}
		for (int j = 0; j < 2; j++)
		{
			int num2 = j * 16;
			int[] array = new int[3] { 2, 5, 9 };
			foreach (int num3 in array)
			{
				list.Add(new Line(list2[3 + num2], list2[num3 + num2]));
			}
			int[] array2 = new int[3] { 0, 9, 13 };
			foreach (int num4 in array2)
			{
				list.Add(new Line(list2[1 + num2], list2[num4 + num2]));
			}
			int[] array3 = new int[3] { 0, 2, 11 };
			foreach (int num5 in array3)
			{
				list.Add(new Line(list2[10 + num2], list2[num5 + num2]));
			}
			list.Add(new Line(list2[6 + num2], list2[7 + num2]));
			list.Add(new Line(list2[14 + num2], list2[15 + num2]));
			list.Add(new Line(list2[4 + num2], list2[5 + num2]));
			list.Add(new Line(list2[8 + num2], list2[9 + num2]));
			list.Add(new Line(list2[13 + num2], list2[12 + num2]));
			list.Add(new Line(list2[num2], list2[14 + num2]));
			list.Add(new Line(list2[2 + num2], list2[6 + num2]));
		}
		for (int n = 0; n < 16; n++)
		{
			list.Add(new Line(list2[n], list2[n + 16]));
		}
		return list;
	}

	private List<Line> AuxeticHoneycomb(double d)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		for (int i = 0; i < 2; i++)
		{
			double num = 3.0 * d * (double)i;
			list2.Add(new Point3d(2.25 * d, num, 2.5 * d));
			list2.Add(new Point3d(2.25 * d, num, 0.5 * d));
			list2.Add(new Point3d(0.75 * d, num, 2.5 * d));
			list2.Add(new Point3d(0.75 * d, num, 0.5 * d));
			list2.Add(new Point3d(0.0, num, 0.0));
			list2.Add(new Point3d(0.0, num, d));
			list2.Add(new Point3d(0.0, num, 2.0 * d));
			list2.Add(new Point3d(0.0, num, 3.0 * d));
			list2.Add(new Point3d(1.5 * d, num, 0.0));
			list2.Add(new Point3d(1.5 * d, num, d));
			list2.Add(new Point3d(1.5 * d, num, 2.0 * d));
			list2.Add(new Point3d(1.5 * d, num, 3.0 * d));
			list2.Add(new Point3d(3.0 * d, num, 0.0));
			list2.Add(new Point3d(3.0 * d, num, d));
			list2.Add(new Point3d(3.0 * d, num, 2.0 * d));
			list2.Add(new Point3d(3.0 * d, num, 3.0 * d));
		}
		for (int j = 0; j < 2; j++)
		{
			int num2 = j * 16;
			int[] array = new int[3] { 2, 5, 9 };
			foreach (int num3 in array)
			{
				list.Add(new Line(list2[3 + num2], list2[num3 + num2]));
			}
			int[] array2 = new int[3] { 0, 9, 13 };
			foreach (int num4 in array2)
			{
				list.Add(new Line(list2[1 + num2], list2[num4 + num2]));
			}
			int[] array3 = new int[3] { 0, 2, 11 };
			foreach (int num5 in array3)
			{
				list.Add(new Line(list2[10 + num2], list2[num5 + num2]));
			}
			list.Add(new Line(list2[6 + num2], list2[7 + num2]));
			list.Add(new Line(list2[14 + num2], list2[15 + num2]));
			list.Add(new Line(list2[4 + num2], list2[5 + num2]));
			list.Add(new Line(list2[8 + num2], list2[9 + num2]));
			list.Add(new Line(list2[13 + num2], list2[12 + num2]));
			list.Add(new Line(list2[num2], list2[14 + num2]));
			list.Add(new Line(list2[2 + num2], list2[6 + num2]));
		}
		for (int n = 0; n < 16; n++)
		{
			list.Add(new Line(list2[n], list2[n + 16]));
		}
		return list;
	}
}


===== IntraLattice.CORE.Components\UniformDSComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class UniformDSComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)8;

	protected override Bitmap Icon => Resources.uniformDS;

	public override Guid ComponentGuid => new Guid("{d242b0c6-83a1-4795-8f8c-a32b1ac85fb3}");

	public UniformDSComponent()
		: base("Uniform DS", "UniformDS", "Generates a uniform lattice within by a design space", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddGeometryParameter("Design Space", "DS", "Design Space (Brep or Mesh)", (GH_ParamAccess)0);
		pManager.AddPlaneParameter("Orientation Plane", "Plane", "Lattice orientation plane", (GH_ParamAccess)0, Plane.WorldXY);
		pManager.AddNumberParameter("Cell Size ( x )", "CSx", "Size of unit cell (x)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( y )", "CSy", "Size of unit cell (y)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( z )", "CSz", "Size of unit cell (z)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Tolerance", "Tol", "Smallest allowed strut length", (GH_ParamAccess)0, 0.2);
		pManager.AddBooleanParameter("Strict tolerance", "Strict", "Specifies if we use a strict tolerance.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Expected O, but got Unknown
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		GeometryBase designSpace = null;
		Plane unset = Plane.Unset;
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		double num4 = 0.0;
		bool strictlyIn = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<GeometryBase>(1, ref designSpace) || !DA.GetData<Plane>(2, ref unset) || !DA.GetData<double>(3, ref num) || !DA.GetData<double>(4, ref num2) || !DA.GetData<double>(5, ref num3) || !DA.GetData<double>(6, ref num4) || !DA.GetData<bool>(7, ref strictlyIn) || !unitCell.isValid || !((CommonObject)designSpace).IsValid || !((Plane)(ref unset)).IsValid || num == 0.0 || num2 == 0.0 || num3 == 0.0)
		{
			return;
		}
		if (num4 >= num || num4 >= num2 || num4 >= num3)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Tolerance parameter cannot be larger than the unit cell dimensions.");
			return;
		}
		int num5 = FrameTools.ValidateSpace(ref designSpace);
		if (num5 == 0)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Design space must be a closed Brep, Mesh or Surface");
			return;
		}
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Box val = default(Box);
		designSpace.GetBoundingBox(unset, ref val);
		Point3d[] corners = ((Box)(ref val)).GetCorners();
		Plane val2 = default(Plane);
		((Plane)(ref val2))._002Ector(corners[0], corners[1], corners[3]);
		double num6 = ((Point3d)(ref corners[0])).DistanceTo(corners[1]);
		double num7 = ((Point3d)(ref corners[0])).DistanceTo(corners[3]);
		double num8 = ((Point3d)(ref corners[0])).DistanceTo(corners[4]);
		int num9 = (int)Math.Ceiling(num6 / num);
		int num10 = (int)Math.Ceiling(num7 / num2);
		int num11 = (int)Math.Ceiling(num8 / num3);
		float[] array = new float[3] { num9, num10, num11 };
		Lattice lattice = new Lattice();
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Vector3d val3 = num * ((Plane)(ref val2)).XAxis;
		Vector3d val4 = num2 * ((Plane)(ref val2)).YAxis;
		Vector3d val5 = num3 * ((Plane)(ref val2)).ZAxis;
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val6 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val6);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val7)).X;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val8)).Y;
						Point3d val9 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val9)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag2 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag || flag2)
						{
							list.Add(null);
							continue;
						}
						Vector3d val10 = array2[0] * val3 + array2[1] * val4 + array2[2] * val5;
						LatticeNode latticeNode = new LatticeNode(((Plane)(ref val2)).Origin + val10);
						if (FrameTools.IsPointInside(designSpace, latticeNode.Point3d, num5, modelAbsoluteTolerance, strictlyIn))
						{
							latticeNode.State = LatticeNodeState.Inside;
						}
						else
						{
							latticeNode.State = LatticeNodeState.Outside;
						}
						list.Add(latticeNode);
					}
				}
			}
		}
		lattice.UniformMapping(unitCell, designSpace, num5, array, num4);
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components.Utility\AdjustUVComponent.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.Properties;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components.Utility;

public class AdjustUVComponent : GH_Component
{
	protected override Bitmap Icon => Resources.adjustUV;

	public override Guid ComponentGuid => new Guid("{3372eac1-1545-4fca-9a25-72c4563aaa1f}");

	public AdjustUVComponent()
		: base("Adjust UV", "AdjustUV", "Adjusts the UV-map of a surface for proper alignment with other surfaces/axes.", "Intralattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddSurfaceParameter("Surface", "Surf", "Surface to adjust.", (GH_ParamAccess)0);
		pManager.AddBooleanParameter("Swap UV", "SwapUV", "Swap the uv parameters.", (GH_ParamAccess)0, false);
		pManager.AddBooleanParameter("Reverse U", "ReverseU", "Reverse the u-parameter direction.", (GH_ParamAccess)0, false);
		pManager.AddBooleanParameter("Reverse V", "ReverseV", "Reverse the v-parameter direction.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddSurfaceParameter("Adjusted surface", "Surf", "Surface with adjusted uv-map.", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		Surface val = null;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		if (DA.GetData<Surface>(0, ref val) && DA.GetData<bool>(1, ref flag) && DA.GetData<bool>(2, ref flag2) && DA.GetData<bool>(3, ref flag3) && val != null)
		{
			if (flag)
			{
				val = val.Transpose();
			}
			if (flag2)
			{
				val.Reverse(0, true);
			}
			if (flag3)
			{
				val.Reverse(1, true);
			}
			DA.SetData(0, (object)val);
		}
	}
}


===== IntraLattice.CORE.Components.Utility\CleanNetworkComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components.Utility;

public class CleanNetworkComponent : GH_Component
{
	protected override Bitmap Icon => Resources.cleanNetwork;

	public override Guid ComponentGuid => new Guid("{8b3a2f8c-3a76-4b19-84b9-f3eea80010ea}");

	public CleanNetworkComponent()
		: base("Clean Network", "CleanNetwork", "Removes duplicate curves from a network, within specified tolerance.", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut network to clean.", (GH_ParamAccess)1);
		pManager.AddNumberParameter("Tolerance", "Tol", "Tolerance for combining nodes.", (GH_ParamAccess)0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Cleaned curve network.", (GH_ParamAccess)1);
		pManager.AddPointParameter("Nodes", "Nodes", "List of unique nodes.", (GH_ParamAccess)1);
		pManager.AddIntegerParameter("CurveStart", "I", "Index in 'Nodes' for the start of each curve in 'Struts'.", (GH_ParamAccess)1);
		pManager.AddIntegerParameter("CurveEnd", "J", "Index in 'Nodes' for the end of each curve in 'Struts'.", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		List<Curve> list = new List<Curve>();
		double num = 0.0;
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetData<double>(1, ref num) || list == null || list.Count == 1 || num < 0.0)
		{
			return;
		}
		Point3dList nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		list = FrameTools.CleanNetwork(list, num, out nodes, out nodePairs);
		List<int> list2 = new List<int>();
		List<int> list3 = new List<int>();
		foreach (IndexPair item in nodePairs)
		{
			IndexPair current = item;
			list2.Add(((IndexPair)(ref current)).I);
			list3.Add(((IndexPair)(ref current)).J);
		}
		DA.SetDataList(0, (IEnumerable)list);
		DA.SetDataList(1, (IEnumerable)nodes);
		DA.SetDataList(2, (IEnumerable)list2);
		DA.SetDataList(3, (IEnumerable)list3);
	}
}


===== IntraLattice.CORE.Data\EndoMesh.cs =====
namespace IntraLattice.CORE.Data;

internal class EndoMesh
{
}


===== IntraLattice.CORE.Data\ExoHull.cs =====
using System.Collections.Generic;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

internal class ExoHull
{
	private Point3d m_point3d;

	private List<int> m_sleeveIndices;

	private List<int> m_plateIndices;

	private double m_avgRadius;

	public Point3d Point3d
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_point3d;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_point3d = value;
		}
	}

	public List<int> SleeveIndices
	{
		get
		{
			return m_sleeveIndices;
		}
		set
		{
			m_sleeveIndices = value;
		}
	}

	public List<int> PlateIndices
	{
		get
		{
			return m_plateIndices;
		}
		set
		{
			m_plateIndices = value;
		}
	}

	public double AvgRadius
	{
		get
		{
			return m_avgRadius;
		}
		set
		{
			m_avgRadius = value;
		}
	}

	public ExoHull()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = Point3d.Unset;
		m_sleeveIndices = new List<int>();
		m_plateIndices = new List<int>();
		m_avgRadius = 0.0;
	}

	public ExoHull(Point3d point3d)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = point3d;
		m_sleeveIndices = new List<int>();
		m_plateIndices = new List<int>();
		m_avgRadius = 0.0;
	}
}


===== IntraLattice.CORE.Data\ExoMesh.cs =====
using System;
using System.Collections.Generic;
using IntraLattice.CORE.Helpers;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;

namespace IntraLattice.CORE.Data;

internal class ExoMesh
{
	private List<ExoHull> m_hulls;

	private List<ExoSleeve> m_sleeves;

	private List<ExoPlate> m_plates;

	private Mesh m_mesh;

	public List<ExoHull> Hulls
	{
		get
		{
			return m_hulls;
		}
		set
		{
			m_hulls = value;
		}
	}

	public List<ExoSleeve> Sleeves
	{
		get
		{
			return m_sleeves;
		}
		set
		{
			m_sleeves = value;
		}
	}

	public List<ExoPlate> Plates
	{
		get
		{
			return m_plates;
		}
		set
		{
			m_plates = value;
		}
	}

	public Mesh Mesh
	{
		get
		{
			return m_mesh;
		}
		set
		{
			m_mesh = value;
		}
	}

	public ExoMesh()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Expected O, but got Unknown
		m_hulls = new List<ExoHull>();
		m_sleeves = new List<ExoSleeve>();
		m_plates = new List<ExoPlate>();
		m_mesh = new Mesh();
	}

	public ExoMesh(List<Curve> struts)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Expected O, but got Unknown
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Expected O, but got Unknown
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		m_hulls = new List<ExoHull>();
		m_sleeves = new List<ExoSleeve>();
		m_plates = new List<ExoPlate>();
		m_mesh = new Mesh();
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Point3dList nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		struts = FrameTools.CleanNetwork(struts, modelAbsoluteTolerance, out nodes, out nodePairs);
		foreach (Point3d item in (RhinoList<Point3d>)(object)nodes)
		{
			m_hulls.Add(new ExoHull(item));
		}
		IndexPair platePair = default(IndexPair);
		for (int i = 0; i < struts.Count; i++)
		{
			m_sleeves.Add(new ExoSleeve(struts[i], nodePairs[i]));
			List<ExoPlate> plates = m_plates;
			IndexPair val = nodePairs[i];
			plates.Add(new ExoPlate(((IndexPair)(ref val)).I, struts[i].TangentAtStart));
			List<ExoPlate> plates2 = m_plates;
			IndexPair val2 = nodePairs[i];
			plates2.Add(new ExoPlate(((IndexPair)(ref val2)).J, -struts[i].TangentAtEnd));
			((IndexPair)(ref platePair))._002Ector(m_plates.Count - 2, m_plates.Count - 1);
			m_sleeves[i].PlatePair = platePair;
			List<ExoHull> hulls = m_hulls;
			IndexPair val3 = nodePairs[i];
			hulls[((IndexPair)(ref val3)).I].SleeveIndices.Add(i);
			List<ExoHull> hulls2 = m_hulls;
			IndexPair val4 = nodePairs[i];
			hulls2[((IndexPair)(ref val4)).J].SleeveIndices.Add(i);
			List<ExoHull> hulls3 = m_hulls;
			IndexPair val5 = nodePairs[i];
			hulls3[((IndexPair)(ref val5)).I].PlateIndices.Add(((IndexPair)(ref platePair)).I);
			List<ExoHull> hulls4 = m_hulls;
			IndexPair val6 = nodePairs[i];
			hulls4[((IndexPair)(ref val6)).J].PlateIndices.Add(((IndexPair)(ref platePair)).J);
		}
	}

	public bool ComputeOffsets(int nodeIndex, double tol)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Invalid comparison between Unknown and I4
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Invalid comparison between Unknown and I4
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Invalid comparison between Unknown and I4
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Invalid comparison between Unknown and I4
		ExoHull exoHull = Hulls[nodeIndex];
		List<Curve> list = new List<Curve>();
		List<double> list2 = new List<double>();
		List<double> list3 = new List<double>();
		double item = default(double);
		foreach (int sleeveIndex in exoHull.SleeveIndices)
		{
			Curve val = Sleeves[sleeveIndex].Curve.DuplicateCurve();
			Point3d pointAtEnd = val.PointAtEnd;
			if (((Point3d)(ref pointAtEnd)).EpsilonEquals(exoHull.Point3d, 100.0 * tol))
			{
				val.Reverse();
				val.Domain = new Interval(0.0, 1.0);
				list2.Add(Sleeves[sleeveIndex].EndRadius);
			}
			else
			{
				list2.Add(Sleeves[sleeveIndex].StartRadius);
			}
			list.Add(val);
			val.LengthParameter(list2[list2.Count - 1], ref item);
			list3.Add(item);
		}
		double num = 0.0;
		foreach (double item2 in list2)
		{
			double num2 = item2;
			num += num2;
		}
		exoHull.AvgRadius = num / (double)list2.Count;
		bool flag = false;
		int num3 = 0;
		double num4 = list3[0] / 10.0;
		Plane val2 = default(Plane);
		double num5 = default(double);
		double num6 = default(double);
		while (!flag && num3 < 500)
		{
			List<Circle> list4 = new List<Circle>();
			for (int i = 0; i < list.Count; i++)
			{
				list[i].PerpendicularFrameAt(list3[i], ref val2);
				list4.Add(new Circle(val2, list2[i]));
			}
			bool[] array = new bool[list.Count];
			for (int j = 0; j < list.Count; j++)
			{
				for (int k = j + 1; k < list.Count; k++)
				{
					Circle val3 = list4[j];
					PlaneCircleIntersection val4 = Intersection.PlaneCircle(((Circle)(ref val3)).Plane, list4[k], ref num5, ref num6);
					Circle val5 = list4[k];
					PlaneCircleIntersection val6 = Intersection.PlaneCircle(((Circle)(ref val5)).Plane, list4[j], ref num5, ref num6);
					if ((int)val4 == 2 || (int)val4 == 1)
					{
						array[j] = true;
					}
					if ((int)val6 == 2 || (int)val6 == 1)
					{
						array[k] = true;
					}
				}
			}
			flag = true;
			for (int l = 0; l < list.Count; l++)
			{
				if (array[l])
				{
					list3[l] += num4;
					flag = false;
				}
			}
			num3++;
		}
		for (int m = 0; m < list.Count; m++)
		{
			int index = exoHull.PlateIndices[m];
			Plates[index].Offset = 1.05 * list3[m];
		}
		return true;
	}

	public void FixSharpNodes(int nodeIndex, int sides)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		ExoHull exoHull = Hulls[nodeIndex];
		bool flag = true;
		Vector3d val = default(Vector3d);
		foreach (int plateIndex in exoHull.PlateIndices)
		{
			val += Plates[plateIndex].Normal;
		}
		foreach (int plateIndex2 in exoHull.PlateIndices)
		{
			if (Vector3d.VectorAngle(-val, Plates[plateIndex2].Normal) < Math.PI / 2.0)
			{
				flag = false;
			}
		}
		if (flag)
		{
			Plane plane = default(Plane);
			((Plane)(ref plane))._002Ector(exoHull.Point3d - val * exoHull.AvgRadius / (double)exoHull.PlateIndices.Count, -val);
			List<Point3d> collection = MeshTools.CreateKnuckle(plane, sides, exoHull.AvgRadius, 0.0);
			Plates.Add(new ExoPlate(nodeIndex, -val));
			int num = Plates.Count - 1;
			Plates[num].Vtc.AddRange(collection);
			exoHull.PlateIndices.Add(num);
		}
	}

	public Mesh MakeSleeve(int strutIndex, int sides)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		ExoSleeve exoSleeve = Sleeves[strutIndex];
		List<ExoPlate> plates = Plates;
		IndexPair platePair = exoSleeve.PlatePair;
		ExoPlate exoPlate = plates[((IndexPair)(ref platePair)).I];
		List<ExoPlate> plates2 = Plates;
		IndexPair platePair2 = exoSleeve.PlatePair;
		ExoPlate exoPlate2 = plates2[((IndexPair)(ref platePair2)).J];
		double offset = exoPlate.Offset;
		double num = 1.0 - exoPlate2.Offset;
		exoPlate.Vtc.Add(exoSleeve.Curve.PointAt(offset));
		exoPlate2.Vtc.Add(exoSleeve.Curve.PointAt(num));
		double avgRadius = exoSleeve.AvgRadius;
		double length = exoSleeve.Curve.GetLength(new Interval(offset, num));
		double num2 = Math.Max(Math.Round(length * 0.5 / avgRadius) * 2.0, 2.0);
		Vector3d tangentAtStart = exoSleeve.Curve.TangentAtStart;
		Plane plane = default(Plane);
		for (int i = 0; (double)i <= num2; i++)
		{
			if (exoSleeve.Curve.IsLinear())
			{
				Point3d val2 = exoPlate.Vtc[0] + tangentAtStart * (length * (double)i / num2);
				plane = new Plane(val2, tangentAtStart);
			}
			else
			{
				double num3 = offset + (double)i / num2 * (num - offset);
				exoSleeve.Curve.PointAt(num3);
				exoSleeve.Curve.PerpendicularFrameAt(num3, ref plane);
			}
			double radius = exoSleeve.StartRadius - (double)i * (exoSleeve.StartRadius - exoSleeve.EndRadius) / num2;
			double startAngle = (double)i * Math.PI / (double)sides;
			List<Point3d> list = MeshTools.CreateKnuckle(plane, sides, radius, startAngle);
			if (i == 0)
			{
				exoPlate.Vtc.AddRange(list);
			}
			if ((double)i == num2)
			{
				exoPlate2.Vtc.AddRange(list);
			}
			val.Vertices.AddVertices((IEnumerable<Point3d>)list);
		}
		for (int j = 0; (double)j < num2; j++)
		{
			for (int k = 0; k < sides; k++)
			{
				int num4 = j * sides + k;
				int num5 = j * sides + k + sides;
				int num6 = j * sides + sides + (k + 1) % sides;
				int num7 = j * sides + (k + 1) % sides;
				val.Faces.AddFace(num4, num5, num7);
				val.Faces.AddFace(num5, num6, num7);
			}
		}
		return val;
	}

	public Mesh MakeConvexHull(int nodeIndex, int sides, double tol, bool cleanPlates)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		Mesh mesh = new Mesh();
		ExoHull exoHull = Hulls[nodeIndex];
		double avgRadius = exoHull.AvgRadius;
		double num = tol * avgRadius / 10.0;
		List<Point3d> list = new List<Point3d>();
		foreach (int plateIndex in exoHull.PlateIndices)
		{
			list.AddRange(Plates[plateIndex].Vtc);
		}
		mesh.Vertices.Add(list[0]);
		mesh.Vertices.Add(list[1]);
		mesh.Vertices.Add(list[2]);
		Plane val = default(Plane);
		((Plane)(ref val))._002Ector(list[0], list[1], list[2]);
		int i;
		for (i = sides + 1; Math.Abs(((Plane)(ref val)).DistanceTo(list[i])) < num; i++)
		{
		}
		mesh.Vertices.Add(list[i]);
		mesh.Faces.AddFace(0, 2, 1);
		mesh.Faces.AddFace(0, 3, 2);
		mesh.Faces.AddFace(0, 1, 3);
		mesh.Faces.AddFace(1, 2, 3);
		list.RemoveAt(i);
		list.RemoveRange(0, 3);
		Plane val3 = default(Plane);
		for (int j = 0; j < list.Count; j++)
		{
			MeshTools.NormaliseMesh(ref mesh);
			List<int> list2 = new List<int>();
			for (int k = 0; k < mesh.Faces.Count; k++)
			{
				Vector3d val2 = list[j] - mesh.Faces.GetFaceCenter(k);
				double num2 = Vector3d.VectorAngle(Vector3d.op_Implicit(mesh.FaceNormals[k]), val2);
				((Plane)(ref val3))._002Ector(mesh.Faces.GetFaceCenter(k), Vector3d.op_Implicit(mesh.FaceNormals[k]));
				if (num2 < Math.PI / 2.0 || Math.Abs(((Plane)(ref val3)).DistanceTo(list[j])) < num)
				{
					list2.Add(k);
				}
			}
			mesh.Faces.DeleteFaces((IEnumerable<int>)list2);
			mesh.Vertices.Add(list[j]);
			List<MeshFace> list3 = new List<MeshFace>();
			for (int l = 0; l < mesh.TopologyEdges.Count; l++)
			{
				if (!mesh.TopologyEdges.IsSwappableEdge(l))
				{
					IndexPair topologyVertices = mesh.TopologyEdges.GetTopologyVertices(l);
					int num3 = mesh.TopologyVertices.MeshVertexIndices(((IndexPair)(ref topologyVertices)).I)[0];
					int num4 = mesh.TopologyVertices.MeshVertexIndices(((IndexPair)(ref topologyVertices)).J)[0];
					list3.Add(new MeshFace(num3, num4, mesh.Vertices.Count - 1));
				}
			}
			mesh.Faces.AddFaces((IEnumerable<MeshFace>)list3);
		}
		MeshTools.NormaliseMesh(ref mesh);
		if (cleanPlates)
		{
			List<int> list4 = new List<int>();
			Point3f val4 = default(Point3f);
			Point3f val5 = default(Point3f);
			Point3f val6 = default(Point3f);
			Point3f val7 = default(Point3f);
			foreach (int plateIndex2 in exoHull.PlateIndices)
			{
				List<Point3f> list5 = MeshTools.Point3dToPoint3f(Plates[plateIndex2].Vtc);
				if (list5.Count < sides + 1)
				{
					continue;
				}
				for (int m = 0; m < mesh.Faces.Count; m++)
				{
					mesh.Faces.GetFaceVertices(m, ref val4, ref val5, ref val6, ref val7);
					int num5 = 0;
					foreach (Point3f item in list5)
					{
						Point3f current3 = item;
						if (((Point3f)(ref current3)).EpsilonEquals(val4, (float)tol) || ((Point3f)(ref current3)).EpsilonEquals(val5, (float)tol) || ((Point3f)(ref current3)).EpsilonEquals(val6, (float)tol))
						{
							num5++;
						}
					}
					if (num5 == 3)
					{
						list4.Add(m);
					}
				}
			}
			list4.Reverse();
			foreach (int item2 in list4)
			{
				mesh.Faces.RemoveAt(item2);
			}
		}
		return mesh;
	}

	public Mesh MakeEndFace(int nodeIndex, int sides)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		foreach (Point3d item in Plates[Hulls[nodeIndex].PlateIndices[0]].Vtc)
		{
			val.Vertices.Add(item);
		}
		for (int i = 1; i < sides; i++)
		{
			val.Faces.AddFace(0, i, i + 1);
		}
		val.Faces.AddFace(0, sides, 1);
		return val;
	}
}


===== IntraLattice.CORE.Data\ExoPlate.cs =====
using System.Collections.Generic;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

internal class ExoPlate
{
	private double m_offset;

	private Vector3d m_normal;

	private List<Point3d> m_vtc;

	private int m_hullIndex;

	public double Offset
	{
		get
		{
			return m_offset;
		}
		set
		{
			m_offset = value;
		}
	}

	public Vector3d Normal
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_normal;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_normal = value;
		}
	}

	public List<Point3d> Vtc
	{
		get
		{
			return m_vtc;
		}
		set
		{
			m_vtc = value;
		}
	}

	public int HullIndex
	{
		get
		{
			return m_hullIndex;
		}
		set
		{
			m_hullIndex = value;
		}
	}

	public ExoPlate()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		m_offset = 0.0;
		m_normal = Vector3d.Unset;
		m_vtc = new List<Point3d>();
		m_hullIndex = 0;
	}

	public ExoPlate(int hullIndex, Vector3d normal)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		m_offset = 0.0;
		m_normal = normal;
		m_vtc = new List<Point3d>();
		m_hullIndex = hullIndex;
	}
}


===== IntraLattice.CORE.Data\ExoSleeve.cs =====
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

internal class ExoSleeve
{
	private Curve m_curve;

	private IndexPair m_hullPair;

	private IndexPair m_platePair;

	private double m_startRadius;

	private double m_endRadius;

	public Curve Curve
	{
		get
		{
			return m_curve;
		}
		set
		{
			m_curve = value;
		}
	}

	public IndexPair HullPair
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_hullPair;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_hullPair = value;
		}
	}

	public IndexPair PlatePair
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_platePair;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_platePair = value;
		}
	}

	public double StartRadius
	{
		get
		{
			return m_startRadius;
		}
		set
		{
			m_startRadius = value;
		}
	}

	public double EndRadius
	{
		get
		{
			return m_endRadius;
		}
		set
		{
			m_endRadius = value;
		}
	}

	public double AvgRadius => (StartRadius + EndRadius) / 2.0;

	public ExoSleeve()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		m_curve = null;
		m_hullPair = default(IndexPair);
		m_platePair = default(IndexPair);
		m_startRadius = 0.0;
		m_endRadius = 0.0;
	}

	public ExoSleeve(Curve curve)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		m_curve = curve;
		m_hullPair = default(IndexPair);
		m_platePair = default(IndexPair);
		m_startRadius = 0.0;
		m_endRadius = 0.0;
	}

	public ExoSleeve(Curve curve, IndexPair hullPair)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		m_curve = curve;
		m_hullPair = hullPair;
		m_platePair = default(IndexPair);
		m_startRadius = 0.0;
		m_endRadius = 0.0;
	}
}


===== IntraLattice.CORE.Data\Lattice.cs =====
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using Grasshopper;
using Grasshopper.Kernel.Data;
using Rhino;
using Rhino.Collections;
using Rhino.DocObjects;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;
using Rhino.Runtime;

namespace IntraLattice.CORE.Data;

public class Lattice
{
	private DataTree<LatticeNode> m_nodes;

	private List<Curve> m_struts;

	public DataTree<LatticeNode> Nodes
	{
		get
		{
			return m_nodes;
		}
		set
		{
			m_nodes = value;
		}
	}

	public List<Curve> Struts
	{
		get
		{
			return m_struts;
		}
		set
		{
			m_struts = value;
		}
	}

	public Lattice()
	{
		m_nodes = new DataTree<LatticeNode>();
		m_struts = new List<Curve>();
	}

	public Lattice Duplicate()
	{
		using MemoryStream memoryStream = new MemoryStream();
		if (GetType().IsSerializable)
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			binaryFormatter.Serialize(memoryStream, this);
			memoryStream.Position = 0L;
			return (Lattice)binaryFormatter.Deserialize(memoryStream);
		}
		return null;
	}

	public void ConformMapping(UnitCell cell, float[] N)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Expected O, but got Unknown
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Expected O, but got Unknown
		for (int i = 0; (float)i <= N[0]; i++)
		{
			for (int j = 0; (float)j <= N[1]; j++)
			{
				for (int k = 0; (float)k <= N[2]; k++)
				{
					foreach (IndexPair nodePair in cell.NodePairs)
					{
						IndexPair current = nodePair;
						int[] array = cell.NodePaths[((IndexPair)(ref current)).I];
						int[] array2 = cell.NodePaths[((IndexPair)(ref current)).J];
						GH_Path val = new GH_Path(new int[3]
						{
							i + array[0],
							j + array[1],
							k + array[2]
						});
						GH_Path val2 = new GH_Path(new int[3]
						{
							i + array2[0],
							j + array2[1],
							k + array2[2]
						});
						if (!Nodes.PathExists(val) || !Nodes.PathExists(val2))
						{
							continue;
						}
						LatticeNode latticeNode = Nodes[val, array[3]];
						LatticeNode latticeNode2 = Nodes[val2, array2[3]];
						if (latticeNode != null && latticeNode2 != null)
						{
							LineCurve val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
							if (val3 != null && ((CommonObject)val3).IsValid)
							{
								Struts.Add((Curve)(object)val3);
							}
						}
					}
				}
			}
		}
	}

	public void MorphMapping(UnitCell cell, DataTree<GeometryBase> spaceTree, float[] N)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Expected O, but got Unknown
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Expected O, but got Unknown
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Expected O, but got Unknown
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Expected O, but got Unknown
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Invalid comparison between Unknown and I4
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Invalid comparison between Unknown and I4
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Invalid comparison between Unknown and I4
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		Line val6 = default(Line);
		Point3d val7 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Point3d val9 = default(Point3d);
		Vector3d[] array4 = default(Vector3d[]);
		for (int i = 0; (float)i <= N[0]; i++)
		{
			for (int j = 0; (float)j <= N[1]; j++)
			{
				for (int k = 0; (float)k <= N[2]; k++)
				{
					foreach (IndexPair nodePair in cell.NodePairs)
					{
						IndexPair current = nodePair;
						int[] array = cell.NodePaths[((IndexPair)(ref current)).I];
						int[] array2 = cell.NodePaths[((IndexPair)(ref current)).J];
						GH_Path val = new GH_Path(new int[3]
						{
							i + array[0],
							j + array[1],
							k + array[2]
						});
						GH_Path val2 = new GH_Path(new int[3]
						{
							i + array2[0],
							j + array2[1],
							k + array2[2]
						});
						if (!Nodes.PathExists(val) || !Nodes.PathExists(val2))
						{
							continue;
						}
						LatticeNode latticeNode = Nodes[val, array[3]];
						LatticeNode latticeNode2 = Nodes[val2, array2[3]];
						if (latticeNode == null || latticeNode2 == null)
						{
							continue;
						}
						GH_Path val3 = (((float)i == N[0] && (float)j == N[1]) ? new GH_Path(new int[2]
						{
							i - 1,
							j - 1
						}) : (((float)i == N[0]) ? new GH_Path(new int[2]
						{
							i - 1,
							j
						}) : (((float)j != N[1]) ? new GH_Path(new int[2] { i, j }) : new GH_Path(new int[2]
						{
							i,
							j - 1
						}))));
						GeometryBase val4 = spaceTree[val3, 0];
						GeometryBase val5 = spaceTree[val3, 1];
						int num = 16;
						List<Point3d> list = new List<Point3d>();
						((Line)(ref val6))._002Ector(((RhinoList<Point3d>)(object)cell.Nodes)[((IndexPair)(ref current)).I], ((RhinoList<Point3d>)(object)cell.Nodes)[((IndexPair)(ref current)).J]);
						for (int l = 0; l <= num; l++)
						{
							list.Add(((Line)(ref val6)).PointAt((double)l / (double)num));
						}
						List<Point3d> list2 = new List<Point3d>();
						foreach (Point3d item2 in list)
						{
							Point3d current2 = item2;
							double num2 = ((Point3d)(ref current2)).X;
							double num3 = ((Point3d)(ref current2)).Y;
							if ((float)i == N[0])
							{
								num2 = 1.0 - num2;
							}
							if ((float)j == N[1])
							{
								num3 = 1.0 - num3;
							}
							((Surface)val4).Evaluate(num2, num3, 0, ref val7, ref array3);
							Vector3d val8 = Vector3d.Unset;
							ObjectType objectType = val5.ObjectType;
							if ((int)objectType != 1)
							{
								if ((int)objectType != 4)
								{
									if ((int)objectType == 8)
									{
										((Surface)val5).Evaluate(num2, num3, 0, ref val9, ref array4);
										val8 = val9 - val7;
									}
								}
								else
								{
									val8 = ((Curve)val5).PointAt(num2) - val7;
								}
							}
							else
							{
								val8 = ((Point)val5).Location - val7;
							}
							Point3d item = val7 + val8 * ((double)k + ((Point3d)(ref current2)).Z) / (double)N[2];
							list2.Add(item);
						}
						Curve val10 = Curve.CreateInterpolatedCurve((IEnumerable<Point3d>)list2, 3);
						if (val10 != null && ((CommonObject)val10).IsValid)
						{
							Struts.Add(val10);
						}
					}
				}
			}
		}
	}

	public void UniformMapping(UnitCell cell, GeometryBase designSpace, int spaceType, float[] N, double minStrutLength)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Expected O, but got Unknown
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Expected O, but got Unknown
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Expected O, but got Unknown
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Expected O, but got Unknown
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Expected O, but got Unknown
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Expected O, but got Unknown
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Expected O, but got Unknown
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Expected O, but got Unknown
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		int[] array5 = default(int[]);
		for (int i = 0; (float)i <= N[0]; i++)
		{
			for (int j = 0; (float)j <= N[1]; j++)
			{
				for (int k = 0; (float)k <= N[2]; k++)
				{
					foreach (IndexPair nodePair in cell.NodePairs)
					{
						IndexPair current = nodePair;
						int[] array = cell.NodePaths[((IndexPair)(ref current)).I];
						int[] array2 = cell.NodePaths[((IndexPair)(ref current)).J];
						GH_Path val = new GH_Path(new int[3]
						{
							i + array[0],
							j + array[1],
							k + array[2]
						});
						GH_Path val2 = new GH_Path(new int[3]
						{
							i + array2[0],
							j + array2[1],
							k + array2[2]
						});
						if (!Nodes.PathExists(val) || !Nodes.PathExists(val2))
						{
							continue;
						}
						LatticeNode latticeNode = Nodes[val, array[3]];
						LatticeNode latticeNode2 = Nodes[val2, array2[3]];
						if (latticeNode == null || latticeNode2 == null)
						{
							continue;
						}
						Curve item = (Curve)new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
						if (latticeNode.IsInside && latticeNode2.IsInside)
						{
							Struts.Add(item);
						}
						else
						{
							if (!latticeNode.IsInside && !latticeNode2.IsInside)
							{
								continue;
							}
							Point3d[] array3 = null;
							Curve[] array4 = null;
							LineCurve val3 = null;
							switch (spaceType)
							{
							case 1:
								val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
								Intersection.CurveBrep((Curve)(object)val3, (Brep)designSpace, modelAbsoluteTolerance, ref array4, ref array3);
								break;
							case 2:
								val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
								array3 = Intersection.MeshLine((Mesh)designSpace, val3.Line, ref array5);
								break;
							case 3:
								array4 = null;
								val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
								Intersection.CurveBrep((Curve)(object)val3, ((Surface)designSpace).ToBrep(), modelAbsoluteTolerance, ref array4, ref array3);
								break;
							}
							LineCurve val4 = null;
							if (array3.Length > 0)
							{
								val4 = AddTrimmedStrut(latticeNode, latticeNode2, array3[0], minStrutLength);
								if (val4 != null)
								{
									Struts.Add((Curve)(object)val4);
								}
							}
							else if (array4 != null && array4.Length > 0)
							{
								Struts.Add(array4[0]);
							}
						}
					}
				}
			}
		}
	}

	public LineCurve AddTrimmedStrut(LatticeNode node1, LatticeNode node2, Point3d intersectionPt, double minStrutLength)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Expected O, but got Unknown
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Expected O, but got Unknown
		new LineCurve(new Line(node1.Point3d, node2.Point3d), 0.0, 1.0);
		if (node1.IsInside)
		{
			double num = ((Point3d)(ref intersectionPt)).DistanceTo(node1.Point3d);
			if (num > minStrutLength)
			{
				Nodes.Add(new LatticeNode(intersectionPt, LatticeNodeState.Boundary));
				return new LineCurve(node1.Point3d, intersectionPt);
			}
			node1.State = LatticeNodeState.Boundary;
		}
		if (node2.IsInside)
		{
			double num2 = ((Point3d)(ref intersectionPt)).DistanceTo(node2.Point3d);
			if (num2 > minStrutLength)
			{
				Nodes.Add(new LatticeNode(intersectionPt, LatticeNodeState.Boundary));
				return new LineCurve(node2.Point3d, intersectionPt);
			}
			node2.State = LatticeNodeState.Boundary;
		}
		return null;
	}
}


===== IntraLattice.CORE.Data\LatticeNode.cs =====
using System;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

[Serializable]
public class LatticeNode
{
	private Point3d m_point3d;

	private LatticeNodeState m_state;

	public Point3d Point3d
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_point3d;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_point3d = value;
		}
	}

	public LatticeNodeState State
	{
		get
		{
			return m_state;
		}
		set
		{
			m_state = value;
		}
	}

	public bool IsInside
	{
		get
		{
			if (m_state == LatticeNodeState.Outside)
			{
				return false;
			}
			return true;
		}
	}

	public LatticeNode()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = Point3d.Unset;
		m_state = LatticeNodeState.Inside;
	}

	public LatticeNode(Point3d point3d)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = point3d;
		m_state = LatticeNodeState.Inside;
	}

	public LatticeNode(Point3d point3d, LatticeNodeState state)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = point3d;
		m_state = state;
	}
}


===== IntraLattice.CORE.Data\LatticeNodeState.cs =====
namespace IntraLattice.CORE.Data;

public enum LatticeNodeState
{
	Outside,
	Inside,
	Boundary
}


===== IntraLattice.CORE.Data\UnitCell.cs =====
using System;
using System.Collections.Generic;
using IntraLattice.CORE.Helpers;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

public class UnitCell
{
	private Point3dList m_nodes;

	private List<IndexPair> m_nodePairs;

	private List<int[]> m_nodePaths;

	public Point3dList Nodes
	{
		get
		{
			return m_nodes;
		}
		set
		{
			m_nodes = value;
		}
	}

	public List<IndexPair> NodePairs
	{
		get
		{
			return m_nodePairs;
		}
		set
		{
			m_nodePairs = value;
		}
	}

	public List<int[]> NodePaths
	{
		get
		{
			return m_nodePaths;
		}
		set
		{
			m_nodePaths = value;
		}
	}

	public bool isValid
	{
		get
		{
			int num = CheckValidity();
			if (num == 1)
			{
				return true;
			}
			return false;
		}
	}

	public UnitCell()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		m_nodes = new Point3dList();
		m_nodePairs = new List<IndexPair>();
		m_nodePaths = new List<int[]>();
	}

	public UnitCell(List<Line> rawCell)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		m_nodes = new Point3dList();
		m_nodePairs = new List<IndexPair>();
		m_nodePaths = new List<int[]>();
		ExtractTopology(rawCell);
		NormaliseTopology();
	}

	public UnitCell Duplicate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			((RhinoList<Point3d>)(object)unitCell.Nodes).Add(item);
		}
		foreach (IndexPair nodePair in NodePairs)
		{
			unitCell.NodePairs.Add(nodePair);
		}
		foreach (int[] nodePath in NodePaths)
		{
			unitCell.NodePaths.Add(new int[4]
			{
				nodePath[0],
				nodePath[1],
				nodePath[2],
				nodePath[3]
			});
		}
		return unitCell;
	}

	private void ExtractTopology(List<Line> lines)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		CellTools.FixIntersections(ref lines);
		IndexPair item = default(IndexPair);
		foreach (Line line in lines)
		{
			Line current = line;
			Point3d[] array = (Point3d[])(object)new Point3d[2]
			{
				((Line)(ref current)).From,
				((Line)(ref current)).To
			};
			List<int> list = new List<int>();
			Point3d[] array2 = array;
			foreach (Point3d val in array2)
			{
				int num = Nodes.ClosestIndex(val);
				if (((RhinoList<Point3d>)(object)Nodes).Count != 0)
				{
					Point3d val2 = ((RhinoList<Point3d>)(object)Nodes)[num];
					if (((Point3d)(ref val2)).EpsilonEquals(val, modelAbsoluteTolerance))
					{
						list.Add(num);
						continue;
					}
				}
				((RhinoList<Point3d>)(object)Nodes).Add(val);
				list.Add(((RhinoList<Point3d>)(object)Nodes).Count - 1);
			}
			((IndexPair)(ref item))._002Ector(list[0], list[1]);
			if (NodePairs.Count == 0 || !NodePairs.Contains(item))
			{
				NodePairs.Add(item);
			}
		}
	}

	private void NormaliseTopology()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Interval val = default(Interval);
		Interval val2 = default(Interval);
		Interval val3 = default(Interval);
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			Point3d current = item;
			if (((Point3d)(ref current)).X < ((Interval)(ref val)).T0)
			{
				((Interval)(ref val)).T0 = ((Point3d)(ref current)).X;
			}
			if (((Point3d)(ref current)).X > ((Interval)(ref val)).T1)
			{
				((Interval)(ref val)).T1 = ((Point3d)(ref current)).X;
			}
			if (((Point3d)(ref current)).Y < ((Interval)(ref val2)).T0)
			{
				((Interval)(ref val2)).T0 = ((Point3d)(ref current)).Y;
			}
			if (((Point3d)(ref current)).Y > ((Interval)(ref val2)).T1)
			{
				((Interval)(ref val2)).T1 = ((Point3d)(ref current)).Y;
			}
			if (((Point3d)(ref current)).Z < ((Interval)(ref val3)).T0)
			{
				((Interval)(ref val3)).T0 = ((Point3d)(ref current)).Z;
			}
			if (((Point3d)(ref current)).Z > ((Interval)(ref val3)).T1)
			{
				((Interval)(ref val3)).T1 = ((Point3d)(ref current)).Z;
			}
		}
		Vector3d val4 = default(Vector3d);
		((Vector3d)(ref val4))._002Ector(0.0 - ((Interval)(ref val)).T0, 0.0 - ((Interval)(ref val2)).T0, 0.0 - ((Interval)(ref val3)).T0);
		Nodes.Transform(Transform.Translation(val4));
		Nodes.Transform(Transform.Scale(Plane.WorldXY, 1.0 / ((Interval)(ref val)).Length, 1.0 / ((Interval)(ref val2)).Length, 1.0 / ((Interval)(ref val3)).Length));
	}

	public int CheckValidity()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Plane[] array = (Plane[])(object)new Plane[2];
		ref Plane reference = ref array[0];
		Point3d val = new Point3d(0.0, 0.0, 0.0);
		Plane worldXY = Plane.WorldXY;
		reference = new Plane(val, ((Plane)(ref worldXY)).ZAxis);
		ref Plane reference2 = ref array[1];
		Point3d val2 = new Point3d(0.0, 0.0, 1.0);
		Plane worldXY2 = Plane.WorldXY;
		reference2 = new Plane(val2, ((Plane)(ref worldXY2)).ZAxis);
		Plane[] array2 = (Plane[])(object)new Plane[2];
		ref Plane reference3 = ref array2[0];
		Point3d val3 = new Point3d(0.0, 0.0, 0.0);
		Plane worldXY3 = Plane.WorldXY;
		reference3 = new Plane(val3, ((Plane)(ref worldXY3)).XAxis);
		ref Plane reference4 = ref array2[1];
		Point3d val4 = new Point3d(1.0, 0.0, 0.0);
		Plane worldXY4 = Plane.WorldXY;
		reference4 = new Plane(val4, ((Plane)(ref worldXY4)).XAxis);
		Plane[] array3 = (Plane[])(object)new Plane[2];
		ref Plane reference5 = ref array3[0];
		Point3d val5 = new Point3d(0.0, 0.0, 0.0);
		Plane worldXY5 = Plane.WorldXY;
		reference5 = new Plane(val5, ((Plane)(ref worldXY5)).YAxis);
		ref Plane reference6 = ref array3[1];
		Point3d val6 = new Point3d(0.0, 1.0, 0.0);
		Plane worldXY6 = Plane.WorldXY;
		reference6 = new Plane(val6, ((Plane)(ref worldXY6)).YAxis);
		bool[] array4 = new bool[3];
		bool[] array5 = array4;
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			Point3d current = item;
			_ = Point3d.Unset;
			if (Math.Abs(((Plane)(ref array[0])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Point3d)(ref current)).Y, ((Plane)(ref array[1])).OriginZ);
				array5[0] = true;
			}
			if (Math.Abs(((Plane)(ref array[1])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Point3d)(ref current)).Y, ((Plane)(ref array[0])).OriginZ);
			}
			if (Math.Abs(((Plane)(ref array2[0])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Plane)(ref array2[1])).OriginX, ((Point3d)(ref current)).Y, ((Point3d)(ref current)).Z);
				array5[1] = true;
			}
			if (Math.Abs(((Plane)(ref array2[1])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Plane)(ref array2[0])).OriginX, ((Point3d)(ref current)).Y, ((Point3d)(ref current)).Z);
			}
			if (Math.Abs(((Plane)(ref array3[0])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Plane)(ref array3[1])).OriginY, ((Point3d)(ref current)).Z);
				array5[2] = true;
			}
			if (Math.Abs(((Plane)(ref array3[1])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Plane)(ref array3[0])).OriginY, ((Point3d)(ref current)).Z);
			}
		}
		if (!array5[0] || !array5[1] || !array5[2])
		{
			return 0;
		}
		return 1;
	}

	public void FormatTopology()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0456: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0462: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0473: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Plane worldXY = Plane.WorldXY;
		((Plane)(ref worldXY)).Translate(new Vector3d(0.0, 0.0, 1.0));
		Plane worldYZ = Plane.WorldYZ;
		((Plane)(ref worldYZ)).Translate(new Vector3d(1.0, 0.0, 0.0));
		Plane worldZX = Plane.WorldZX;
		((Plane)(ref worldZX)).Translate(new Vector3d(0.0, 1.0, 0.0));
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			Point3d current = item;
			if (Math.Abs(((Plane)(ref worldXY)).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				if (((Point3d)(ref current)).DistanceTo(new Point3d(1.0, 1.0, 1.0)) < modelAbsoluteTolerance)
				{
					List<int[]> nodePaths = NodePaths;
					int[] array = new int[4] { 1, 1, 1, 0 };
					array[3] = Nodes.ClosestIndex(new Point3d(0.0, 0.0, 0.0));
					nodePaths.Add(array);
				}
				else if (Math.Abs(((Point3d)(ref current)).X - 1.0) < modelAbsoluteTolerance && Math.Abs(((Point3d)(ref current)).Z - 1.0) < modelAbsoluteTolerance)
				{
					NodePaths.Add(new int[4]
					{
						1,
						0,
						1,
						Nodes.ClosestIndex(new Point3d(0.0, ((Point3d)(ref current)).Y, 0.0))
					});
				}
				else if (Math.Abs(((Point3d)(ref current)).Y - 1.0) < modelAbsoluteTolerance && Math.Abs(((Point3d)(ref current)).Z - 1.0) < modelAbsoluteTolerance)
				{
					NodePaths.Add(new int[4]
					{
						0,
						1,
						1,
						Nodes.ClosestIndex(new Point3d(((Point3d)(ref current)).X, 0.0, 0.0))
					});
				}
				else
				{
					NodePaths.Add(new int[4]
					{
						0,
						0,
						1,
						Nodes.ClosestIndex(new Point3d(((Point3d)(ref current)).X, ((Point3d)(ref current)).Y, 0.0))
					});
				}
			}
			else if (Math.Abs(((Plane)(ref worldYZ)).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				if (Math.Abs(((Point3d)(ref current)).X - 1.0) < modelAbsoluteTolerance && Math.Abs(((Point3d)(ref current)).Y - 1.0) < modelAbsoluteTolerance)
				{
					NodePaths.Add(new int[4]
					{
						1,
						1,
						0,
						Nodes.ClosestIndex(new Point3d(0.0, 0.0, ((Point3d)(ref current)).Z))
					});
				}
				else
				{
					NodePaths.Add(new int[4]
					{
						1,
						0,
						0,
						Nodes.ClosestIndex(new Point3d(0.0, ((Point3d)(ref current)).Y, ((Point3d)(ref current)).Z))
					});
				}
			}
			else if (Math.Abs(((Plane)(ref worldZX)).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				NodePaths.Add(new int[4]
				{
					0,
					1,
					0,
					Nodes.ClosestIndex(new Point3d(((Point3d)(ref current)).X, 0.0, ((Point3d)(ref current)).Z))
				});
			}
			else
			{
				NodePaths.Add(new int[4]
				{
					0,
					0,
					0,
					((RhinoList<Point3d>)(object)Nodes).IndexOf(current)
				});
			}
		}
		List<int> list = new List<int>();
		for (int i = 0; i < NodePairs.Count; i++)
		{
			Point3dList nodes = Nodes;
			IndexPair val = NodePairs[i];
			Point3d val2 = ((RhinoList<Point3d>)(object)nodes)[((IndexPair)(ref val)).I];
			Point3dList nodes2 = Nodes;
			IndexPair val3 = NodePairs[i];
			Point3d val4 = ((RhinoList<Point3d>)(object)nodes2)[((IndexPair)(ref val3)).J];
			bool flag = false;
			if (Math.Abs(((Plane)(ref worldXY)).DistanceTo(val2)) < modelAbsoluteTolerance && Math.Abs(((Plane)(ref worldXY)).DistanceTo(val4)) < modelAbsoluteTolerance)
			{
				flag = true;
			}
			if (Math.Abs(((Plane)(ref worldYZ)).DistanceTo(val2)) < modelAbsoluteTolerance && Math.Abs(((Plane)(ref worldYZ)).DistanceTo(val4)) < modelAbsoluteTolerance)
			{
				flag = true;
			}
			if (Math.Abs(((Plane)(ref worldZX)).DistanceTo(val2)) < modelAbsoluteTolerance && Math.Abs(((Plane)(ref worldZX)).DistanceTo(val4)) < modelAbsoluteTolerance)
			{
				flag = true;
			}
			if (flag)
			{
				list.Add(i);
			}
		}
		list.Reverse();
		foreach (int item2 in list)
		{
			NodePairs.RemoveAt(item2);
		}
	}
}


===== IntraLattice.CORE.Data.GH_Goo\LatticeGoo.cs =====
using System;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data.GH_Goo;

public class LatticeGoo : GH_GeometricGoo<Lattice>, IGH_PreviewData
{
	public override bool IsValid
	{
		get
		{
			if (((GH_GeometricGoo<Lattice>)this).Value == null)
			{
				return false;
			}
			return base.IsValid;
		}
	}

	public override string IsValidWhyNot
	{
		get
		{
			if (((GH_GeometricGoo<Lattice>)this).Value.Nodes == null)
			{
				return "nodes empty";
			}
			if (((GH_GeometricGoo<Lattice>)this).Value.Struts == null)
			{
				return "struts empty";
			}
			return ((GH_Goo<Lattice>)(object)this).IsValidWhyNot;
		}
	}

	public override string TypeDescription => "Lattice Representation";

	public override string TypeName => "LatticeGoo";

	public override BoundingBox Boundingbox
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			Point3dList val = new Point3dList();
			foreach (LatticeNode item in ((GH_GeometricGoo<Lattice>)this).Value.Nodes.AllData())
			{
				((RhinoList<Point3d>)(object)val).Add(item.Point3d);
			}
			return val.BoundingBox;
		}
	}

	public BoundingBox ClippingBox => ((GH_GeometricGoo<Lattice>)this).Boundingbox;

	public LatticeGoo()
	{
		((GH_GeometricGoo<Lattice>)this).Value = new Lattice();
	}

	public LatticeGoo(Lattice cell)
	{
		if (cell == null)
		{
			cell = new Lattice();
		}
		((GH_GeometricGoo<Lattice>)this).Value = cell;
	}

	public LatticeGoo DuplicateGoo()
	{
		return new LatticeGoo(((GH_GeometricGoo<Lattice>)this).Value.Duplicate());
	}

	public override IGH_GeometricGoo DuplicateGeometry()
	{
		return (IGH_GeometricGoo)(object)DuplicateGoo();
	}

	public override string ToString()
	{
		if (((GH_GeometricGoo<Lattice>)this).Value == null)
		{
			return "Null Lattice";
		}
		return ((GH_GeometricGoo<Lattice>)this).Value.ToString();
	}

	public override object ScriptVariable()
	{
		return ((GH_GeometricGoo<Lattice>)this).Value;
	}

	public override bool CastTo<Q>(out Q target)
	{
		if (typeof(Q).IsAssignableFrom(typeof(Lattice)))
		{
			if (((GH_GeometricGoo<Lattice>)this).Value == null)
			{
				target = default(Q);
			}
			else
			{
				target = (Q)(object)((GH_GeometricGoo<Lattice>)this).Value;
			}
			return true;
		}
		target = default(Q);
		return false;
	}

	public override bool CastFrom(object source)
	{
		if (source == null)
		{
			return false;
		}
		if (typeof(Lattice).IsAssignableFrom(source.GetType()))
		{
			((GH_GeometricGoo<Lattice>)this).Value = (Lattice)source;
			return true;
		}
		return false;
	}

	public override BoundingBox GetBoundingBox(Transform xform)
	{
		throw new NotImplementedException();
	}

	public override IGH_GeometricGoo Transform(Transform xform)
	{
		throw new NotImplementedException();
	}

	public override IGH_GeometricGoo Morph(SpaceMorph xmorph)
	{
		throw new NotImplementedException();
	}

	public void DrawViewportWires(GH_PreviewWireArgs args)
	{
	}

	public void DrawViewportMeshes(GH_PreviewMeshArgs args)
	{
	}
}


===== IntraLattice.CORE.Data.GH_Goo\UnitCellGoo.cs =====
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data.GH_Goo;

public class UnitCellGoo : GH_GeometricGoo<UnitCell>, IGH_PreviewData
{
	public override bool IsValid
	{
		get
		{
			if (((GH_GeometricGoo<UnitCell>)this).Value == null)
			{
				return false;
			}
			return base.IsValid;
		}
	}

	public override string IsValidWhyNot
	{
		get
		{
			if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
			{
				return "Node list empty";
			}
			if (((GH_GeometricGoo<UnitCell>)this).Value.NodePairs == null)
			{
				return "No line";
			}
			return ((GH_Goo<UnitCell>)(object)this).IsValidWhyNot;
		}
	}

	public override string TypeDescription => "LatticeCell Representation";

	public override string TypeName => "LatticeCellGoo";

	public override BoundingBox Boundingbox
	{
		get
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (((GH_GeometricGoo<UnitCell>)this).Value == null)
			{
				return BoundingBox.Empty;
			}
			if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
			{
				return BoundingBox.Empty;
			}
			return ((GH_GeometricGoo<UnitCell>)this).Value.Nodes.BoundingBox;
		}
	}

	public BoundingBox ClippingBox => ((GH_GeometricGoo<UnitCell>)this).Boundingbox;

	public UnitCellGoo()
	{
		((GH_GeometricGoo<UnitCell>)this).Value = new UnitCell();
	}

	public UnitCellGoo(UnitCell cell)
	{
		if (cell == null)
		{
			cell = new UnitCell();
		}
		((GH_GeometricGoo<UnitCell>)this).Value = cell;
	}

	public override IGH_GeometricGoo DuplicateGeometry()
	{
		return (IGH_GeometricGoo)(object)DuplicateGoo();
	}

	public UnitCellGoo DuplicateGoo()
	{
		return new UnitCellGoo((((GH_GeometricGoo<UnitCell>)this).Value == null) ? new UnitCell() : ((GH_GeometricGoo<UnitCell>)this).Value.Duplicate());
	}

	public override string ToString()
	{
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return "Null LatticeCell";
		}
		return ((GH_GeometricGoo<UnitCell>)this).Value.ToString();
	}

	public override BoundingBox GetBoundingBox(Transform xform)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return BoundingBox.Empty;
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
		{
			return BoundingBox.Empty;
		}
		return ((GH_GeometricGoo<UnitCell>)this).Value.Nodes.BoundingBox;
	}

	public override object ScriptVariable()
	{
		return ((GH_GeometricGoo<UnitCell>)this).Value;
	}

	public override bool CastTo<Q>(out Q target)
	{
		if (typeof(Q).IsAssignableFrom(typeof(UnitCell)))
		{
			if (((GH_GeometricGoo<UnitCell>)this).Value == null)
			{
				target = default(Q);
			}
			else
			{
				target = (Q)(object)((GH_GeometricGoo<UnitCell>)this).Value;
			}
			return true;
		}
		target = default(Q);
		return false;
	}

	public override bool CastFrom(object source)
	{
		if (source == null)
		{
			return false;
		}
		if (typeof(UnitCell).IsAssignableFrom(source.GetType()))
		{
			((GH_GeometricGoo<UnitCell>)this).Value = (UnitCell)source;
			return true;
		}
		return false;
	}

	public override IGH_GeometricGoo Transform(Transform xform)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return null;
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
		{
			return null;
		}
		((GH_Goo<UnitCell>)(object)this).m_value.Nodes.Transform(xform);
		return (IGH_GeometricGoo)(object)this;
	}

	public override IGH_GeometricGoo Morph(SpaceMorph xmorph)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes).Count; i++)
		{
			((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[i] = xmorph.MorphPoint(((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[i]);
		}
		return (IGH_GeometricGoo)(object)this;
	}

	public void DrawViewportWires(GH_PreviewWireArgs args)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return;
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes != null)
		{
			foreach (Point3d item in (RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)
			{
				args.Pipeline.DrawPoint(item, (Color)args.Color);
			}
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.NodePairs == null)
		{
			return;
		}
		foreach (IndexPair nodePair in ((GH_GeometricGoo<UnitCell>)this).Value.NodePairs)
		{
			IndexPair current2 = nodePair;
			Point3d val = ((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[((IndexPair)(ref current2)).I];
			Point3d val2 = ((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[((IndexPair)(ref current2)).J];
			args.Pipeline.DrawLine(val, val2, (Color)args.Color);
		}
	}

	public void DrawViewportMeshes(GH_PreviewMeshArgs args)
	{
	}
}


===== IntraLattice.CORE.Helpers\CellTools.cs =====
using System.Collections.Generic;
using Rhino;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;

namespace IntraLattice.CORE.Helpers;

public class CellTools
{
	public static void FixIntersections(ref List<Line> lines)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		List<int> list = new List<int>();
		List<Line> list2 = new List<Line>();
		double num = default(double);
		double num2 = default(double);
		for (int i = 0; i < lines.Count; i++)
		{
			for (int j = i + 1; j < lines.Count; j++)
			{
				if (Intersection.LineLine(lines[i], lines[j], ref num, ref num2, modelAbsoluteTolerance, true))
				{
					if (num > modelAbsoluteTolerance && 1.0 - num > modelAbsoluteTolerance && !list.Contains(i))
					{
						Line val = lines[i];
						Point3d from = ((Line)(ref val)).From;
						Line val2 = lines[i];
						list2.Add(new Line(from, ((Line)(ref val2)).PointAt(num)));
						Line val3 = lines[i];
						Point3d val4 = ((Line)(ref val3)).PointAt(num);
						Line val5 = lines[i];
						list2.Add(new Line(val4, ((Line)(ref val5)).To));
						list.Add(i);
					}
					if (num2 > modelAbsoluteTolerance && 1.0 - num2 > modelAbsoluteTolerance && !list.Contains(j))
					{
						Line val6 = lines[j];
						Point3d from2 = ((Line)(ref val6)).From;
						Line val7 = lines[j];
						list2.Add(new Line(from2, ((Line)(ref val7)).PointAt(num2)));
						Line val8 = lines[j];
						Point3d val9 = ((Line)(ref val8)).PointAt(num2);
						Line val10 = lines[j];
						list2.Add(new Line(val9, ((Line)(ref val10)).To));
						list.Add(j);
					}
				}
			}
		}
		list.Sort();
		list.Reverse();
		foreach (int item in list)
		{
			lines.RemoveAt(item);
		}
		lines.AddRange(list2);
	}

	public static void MakeCornerNodes(ref List<Point3d> nodes, double d)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		nodes.Add(new Point3d(0.0, 0.0, 0.0));
		nodes.Add(new Point3d(d, 0.0, 0.0));
		nodes.Add(new Point3d(d, d, 0.0));
		nodes.Add(new Point3d(0.0, d, 0.0));
		nodes.Add(new Point3d(0.0, 0.0, d));
		nodes.Add(new Point3d(d, 0.0, d));
		nodes.Add(new Point3d(d, d, d));
		nodes.Add(new Point3d(0.0, d, d));
	}
}


===== IntraLattice.CORE.Helpers\FrameTools.cs =====
using System;
using System.Collections.Generic;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Helpers;

public class FrameTools
{
	public static List<Curve> CleanNetwork(List<Curve> inputStruts, double tol)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		Point3dList nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		return CleanNetwork(inputStruts, tol, out nodes, out nodePairs);
	}

	public static List<Curve> CleanNetwork(List<Curve> inputStruts, double tol, out Point3dList nodes)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		return CleanNetwork(inputStruts, tol, out nodes, out nodePairs);
	}

	public static List<Curve> CleanNetwork(List<Curve> inputStruts, double tol, out Point3dList nodes, out List<IndexPair> nodePairs)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		nodes = new Point3dList();
		nodePairs = new List<IndexPair>();
		List<Curve> list = new List<Curve>();
		IndexPair item = default(IndexPair);
		for (int i = 0; i < inputStruts.Count; i++)
		{
			Curve val = inputStruts[i];
			val.Domain = new Interval(0.0, 1.0);
			double num = Math.Max(tol, 100.0 * RhinoDoc.ActiveDoc.ModelAbsoluteTolerance);
			if (val == null || !((CommonObject)val).IsValid || val.IsShort(num))
			{
				continue;
			}
			Point3d[] array = (Point3d[])(object)new Point3d[2] { val.PointAtStart, val.PointAtEnd };
			List<int> list2 = new List<int>();
			for (int j = 0; j < 2; j++)
			{
				Point3d val2 = array[j];
				int num2 = nodes.ClosestIndex(val2);
				if (((RhinoList<Point3d>)(object)nodes).Count != 0 && ((Point3d)(ref val2)).EpsilonEquals(((RhinoList<Point3d>)(object)nodes)[num2], tol))
				{
					list2.Add(num2);
					continue;
				}
				((RhinoList<Point3d>)(object)nodes).Add(val2);
				list2.Add(((RhinoList<Point3d>)(object)nodes).Count - 1);
			}
			bool flag = false;
			((IndexPair)(ref item))._002Ector(list2[0], list2[1]);
			int num3 = nodePairs.IndexOf(item);
			if (nodePairs.Count != 0 && num3 != -1)
			{
				Curve val3 = list[num3];
				Point3d val4 = val.PointAt(0.5);
				Point3d val5 = val3.PointAt(0.5);
				if (((Point3d)(ref val4)).EpsilonEquals(val5, tol))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				nodePairs.Add(item);
				val.Domain = new Interval(0.0, 1.0);
				list.Add(val);
			}
		}
		return list;
	}

	public static int ValidateSpace(ref GeometryBase designSpace)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Invalid comparison between Unknown and I4
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Invalid comparison between Unknown and I4
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		int result = 0;
		if ((int)designSpace.ObjectType == 16)
		{
			result = 1;
		}
		else if ((int)designSpace.ObjectType == 32 && ((Mesh)designSpace).IsClosed)
		{
			result = 2;
		}
		else if ((int)designSpace.ObjectType == 8 && ((Surface)designSpace).IsSolid)
		{
			result = 3;
		}
		return result;
	}

	public static bool IsPointInside(GeometryBase geometry, Point3d testPoint, int spaceType, double tol, bool strictlyIn)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		switch (spaceType)
		{
		case 1:
			result = ((Brep)geometry).IsPointInside(testPoint, tol, strictlyIn);
			break;
		case 2:
			result = ((Mesh)geometry).IsPointInside(testPoint, tol, strictlyIn);
			break;
		case 3:
			result = ((Surface)geometry).ToBrep().IsPointInside(testPoint, tol, strictlyIn);
			break;
		}
		return result;
	}

	public static double DistanceTo(GeometryBase geometry, Point3d testPoint, int spaceType)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		double result = 0.0;
		switch (spaceType)
		{
		case 1:
		{
			Point3d val = ((Brep)geometry).ClosestPoint(testPoint);
			result = ((Point3d)(ref testPoint)).DistanceTo(val);
			break;
		}
		case 2:
		{
			Point3d val = ((Mesh)geometry).ClosestPoint(testPoint);
			result = ((Point3d)(ref testPoint)).DistanceTo(val);
			break;
		}
		case 3:
		{
			Point3d val = ((Surface)geometry).ToBrep().ClosestPoint(testPoint);
			result = ((Point3d)(ref testPoint)).DistanceTo(val);
			break;
		}
		}
		return result;
	}
}


===== IntraLattice.CORE.Helpers\InputTools.cs =====
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Special;

namespace IntraLattice.CORE.Helpers;

public class InputTools
{
	public static void TopoSelect(ref IGH_Component Component, ref GH_Document GrasshopperDocument, int index, float offset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Expected O, but got Unknown
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Expected O, but got Unknown
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Expected O, but got Unknown
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Expected O, but got Unknown
		GH_ValueList val = new GH_ValueList();
		val.ListMode = (GH_ValueListMode)3;
		val.CreateAttributes();
		float x = ((IGH_DocumentObject)Component).Attributes.Pivot.X - 250f;
		float y = ((IGH_DocumentObject)Component).Attributes.Pivot.Y + (float)(index * 40) - offset;
		PointF pivot = new PointF(x, y);
		((GH_DocumentObject)val).Attributes.Pivot = pivot;
		val.ListItems.Clear();
		List<GH_ValueListItem> list = new List<GH_ValueListItem>();
		list.Add(new GH_ValueListItem("Grid", "0"));
		list.Add(new GH_ValueListItem("X", "1"));
		list.Add(new GH_ValueListItem("Star", "2"));
		list.Add(new GH_ValueListItem("Cross", "3"));
		list.Add(new GH_ValueListItem("Tesseract", "4"));
		list.Add(new GH_ValueListItem("Vintiles", "5"));
		list.Add(new GH_ValueListItem("Octet", "6"));
		list.Add(new GH_ValueListItem("Diamond", "7"));
		list.Add(new GH_ValueListItem("Honeycomb 1", "8"));
		list.Add(new GH_ValueListItem("Honeycomb 2", "9"));
		val.ListItems.AddRange(list);
		GrasshopperDocument.AddObject((IGH_DocumentObject)(object)val, false, int.MaxValue);
		Component.Params.Input[index].AddSource((IGH_Param)(object)val);
		((IGH_ActiveObject)Component.Params.Input[index]).CollectData();
	}

	public static void OrientSelect(ref IGH_Component Component, ref GH_Document GrasshopperDocument, int index, float offset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		GH_ValueList val = new GH_ValueList();
		val.ListMode = (GH_ValueListMode)3;
		val.CreateAttributes();
		float x = ((IGH_DocumentObject)Component).Attributes.Pivot.X - 200f;
		float y = ((IGH_DocumentObject)Component).Attributes.Pivot.Y + (float)(index * 40) - offset;
		PointF pivot = new PointF(x, y);
		((GH_DocumentObject)val).Attributes.Pivot = pivot;
		val.ListItems.Clear();
		List<GH_ValueListItem> list = new List<GH_ValueListItem>();
		list.Add(new GH_ValueListItem("Default", "0"));
		list.Add(new GH_ValueListItem("RotateZ", "1"));
		list.Add(new GH_ValueListItem("RotateY", "2"));
		list.Add(new GH_ValueListItem("RotateX", "3"));
		val.ListItems.AddRange(list);
		GrasshopperDocument.AddObject((IGH_DocumentObject)(object)val, false, int.MaxValue);
		Component.Params.Input[index].AddSource((IGH_Param)(object)val);
		((IGH_ActiveObject)Component.Params.Input[index]).CollectData();
	}

	public static void GradientSelect(ref IGH_Component Component, ref GH_Document GrasshopperDocument, int index, float offset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Expected O, but got Unknown
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Expected O, but got Unknown
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Expected O, but got Unknown
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Expected O, but got Unknown
		GH_ValueList val = new GH_ValueList();
		val.ListMode = (GH_ValueListMode)1;
		val.CreateAttributes();
		float x = ((IGH_DocumentObject)Component).Attributes.Pivot.X - 200f;
		float y = ((IGH_DocumentObject)Component).Attributes.Pivot.Y + (float)(index * 40) - offset;
		PointF pivot = new PointF(x, y);
		((GH_DocumentObject)val).Attributes.Pivot = pivot;
		val.ListItems.Clear();
		List<GH_ValueListItem> list = new List<GH_ValueListItem>();
		list.Add(new GH_ValueListItem("Linear (X)", "0"));
		list.Add(new GH_ValueListItem("Linear (Y)", "1"));
		list.Add(new GH_ValueListItem("Linear (Z)", "2"));
		list.Add(new GH_ValueListItem("Centered (X)", "3"));
		list.Add(new GH_ValueListItem("Centered (Y)", "4"));
		list.Add(new GH_ValueListItem("Centered (Z)", "5"));
		list.Add(new GH_ValueListItem("Cylindrical (X)", "6"));
		list.Add(new GH_ValueListItem("Cylindrical (Y)", "7"));
		list.Add(new GH_ValueListItem("Cylindrical (Z)", "8"));
		list.Add(new GH_ValueListItem("Spherical", "9"));
		val.ListItems.AddRange(list);
		GrasshopperDocument.AddObject((IGH_DocumentObject)(object)val, false, int.MaxValue);
		Component.Params.Input[index].AddSource((IGH_Param)(object)val);
		((IGH_ActiveObject)Component.Params.Input[index]).CollectData();
	}
}


===== IntraLattice.CORE.Helpers\MeshTools.cs =====
using System;
using System.Collections.Generic;
using Rhino.Geometry;

namespace IntraLattice.CORE.Helpers;

public class MeshTools
{
	public static List<Point3d> CreateKnuckle(Plane plane, int sides, double radius, double startAngle)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		List<Point3d> list = new List<Point3d>();
		for (int i = 0; i < sides; i++)
		{
			double num = (double)(i * 2) * Math.PI / (double)sides + startAngle;
			list.Add(((Plane)(ref plane)).PointAt(radius * Math.Cos(num), radius * Math.Sin(num)));
		}
		return list;
	}

	public static List<Point3f> Point3dToPoint3f(List<Point3d> in3d)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		List<Point3f> list = new List<Point3f>();
		foreach (Point3d item in in3d)
		{
			Point3d current = item;
			list.Add(new Point3f((float)((Point3d)(ref current)).X, (float)((Point3d)(ref current)).Y, (float)((Point3d)(ref current)).Z));
		}
		return list;
	}

	public static void NormaliseMesh(ref Mesh mesh)
	{
		if (mesh.SolidOrientation() == -1)
		{
			mesh.Flip(true, true, true);
		}
		mesh.FaceNormals.ComputeFaceNormals();
		mesh.UnifyNormals();
		mesh.Normals.ComputeNormals();
	}
}


===== IntraLattice.CORE.MeshModule\HeterogenCustomComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.MeshModule;

public class HeterogenCustomComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.heterogenCustom;

	public override Guid ComponentGuid => new Guid("{5fa648cd-af7e-41e5-ac9c-f81bc19466bb}");

	public HeterogenCustomComponent()
		: base("Heterogen Custom", "HeterogenCustom", "Heterogeneous solidification of lattice wireframe", "IntraLattice", "Mesh")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Wireframe to thicken.", (GH_ParamAccess)1);
		pManager.AddNumberParameter("Start Radii", "StartRadii", "Radius at the start of each strut.", (GH_ParamAccess)1);
		pManager.AddNumberParameter("End Radii", "EndRadii", "Radius at the end of each strut.", (GH_ParamAccess)1);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Thickened wireframe.", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		List<Curve> list = new List<Curve>();
		List<double> list2 = new List<double>();
		List<double> list3 = new List<double>();
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetDataList<double>(1, list2) || !DA.GetDataList<double>(2, list3) || list == null || list.Count == 0 || list2 == null || list2.Count == 0 || list3 == null || list3.Count == 0)
		{
			return;
		}
		if (list2.Count != list.Count || list3.Count != list.Count)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Number of radii in each list must have same number of elements as the struts list.");
			return;
		}
		int sides = 6;
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		ExoMesh exoMesh = new ExoMesh(list);
		for (int i = 0; i < exoMesh.Sleeves.Count; i++)
		{
			exoMesh.Sleeves[i].StartRadius = list2[i];
			exoMesh.Sleeves[i].EndRadius = list3[i];
		}
		for (int j = 0; j < exoMesh.Hulls.Count; j++)
		{
			if (exoMesh.Hulls[j].SleeveIndices.Count >= 2)
			{
				exoMesh.ComputeOffsets(j, modelAbsoluteTolerance);
				exoMesh.FixSharpNodes(j, sides);
			}
		}
		for (int k = 0; k < exoMesh.Sleeves.Count; k++)
		{
			Mesh val = exoMesh.MakeSleeve(k, sides);
			exoMesh.Mesh.Append(val);
		}
		for (int l = 0; l < exoMesh.Hulls.Count; l++)
		{
			_ = exoMesh.Hulls[l];
			int count = exoMesh.Hulls[l].PlateIndices.Count;
			if (count < 2)
			{
				Mesh val2 = exoMesh.MakeEndFace(l, sides);
				exoMesh.Mesh.Append(val2);
			}
			else
			{
				Mesh val3 = exoMesh.MakeConvexHull(l, sides, modelAbsoluteTolerance, cleanPlates: true);
				exoMesh.Mesh.Append(val3);
			}
		}
		exoMesh.Mesh.Vertices.CombineIdentical(true, true);
		exoMesh.Mesh.FaceNormals.ComputeFaceNormals();
		exoMesh.Mesh.UnifyNormals();
		exoMesh.Mesh.Normals.ComputeNormals();
		DA.SetData(0, (object)exoMesh.Mesh);
	}
}


===== IntraLattice.CORE.MeshModule\HeterogenGradientComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Expressions;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.MeshModule;

public class HeterogenGradientComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.heterogenGradient;

	public override Guid ComponentGuid => new Guid("{a5e48dd2-8467-4991-95b1-15d29524de3e}");

	public HeterogenGradientComponent()
		: base("Heterogen Gradient", "HeterogenGradient", "Heterogeneous solidification (thickness gradient) of lattice wireframe", "IntraLattice", "Mesh")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Wireframe to thicken", (GH_ParamAccess)1);
		pManager.AddTextParameter("Gradient String", "Grad", "The spatial gradient as an expression string", (GH_ParamAccess)0, "0");
		pManager.AddNumberParameter("Maximum Radius", "Rmax", "Maximum radius in gradient", (GH_ParamAccess)0, 0.5);
		pManager.AddNumberParameter("Minimum Radius", "Rmin", "Minimum radius in gradient", (GH_ParamAccess)0, 0.2);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Thickened wireframe", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Expected O, but got Unknown
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		List<Curve> list = new List<Curve>();
		string text = null;
		double num = 0.0;
		double num2 = 0.0;
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetData<string>(1, ref text) || !DA.GetData<double>(2, ref num) || !DA.GetData<double>(3, ref num2) || list == null || list.Count == 0 || num <= 0.0 || num2 <= 0.0)
		{
			return;
		}
		int sides = 6;
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		ExoMesh exoMesh = new ExoMesh(list);
		BoundingBox val = default(BoundingBox);
		foreach (ExoSleeve sleefe in exoMesh.Sleeves)
		{
			BoundingBox boundingBox = ((GeometryBase)sleefe.Curve).GetBoundingBox(Plane.WorldXY);
			((BoundingBox)(ref val)).Union(boundingBox);
		}
		Point3d max = ((BoundingBox)(ref val)).Max;
		double x = ((Point3d)(ref max)).X;
		Point3d min = ((BoundingBox)(ref val)).Min;
		double num3 = x - ((Point3d)(ref min)).X;
		Point3d max2 = ((BoundingBox)(ref val)).Max;
		double y = ((Point3d)(ref max2)).Y;
		Point3d min2 = ((BoundingBox)(ref val)).Min;
		double num4 = y - ((Point3d)(ref min2)).Y;
		Point3d max3 = ((BoundingBox)(ref val)).Max;
		double z = ((Point3d)(ref max3)).Z;
		Point3d min3 = ((BoundingBox)(ref val)).Min;
		double num5 = z - ((Point3d)(ref min3)).Z;
		text = GH_ExpressionSyntaxWriter.RewriteForEvaluator(text);
		foreach (ExoSleeve sleefe2 in exoMesh.Sleeves)
		{
			List<ExoHull> hulls = exoMesh.Hulls;
			IndexPair hullPair = sleefe2.HullPair;
			ExoHull exoHull = hulls[((IndexPair)(ref hullPair)).I];
			GH_ExpressionParser val2 = new GH_ExpressionParser();
			Point3d point3d = exoHull.Point3d;
			double x2 = ((Point3d)(ref point3d)).X;
			Point3d min4 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("x", (x2 - ((Point3d)(ref min4)).X) / num3);
			Point3d point3d2 = exoHull.Point3d;
			double y2 = ((Point3d)(ref point3d2)).Y;
			Point3d min5 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("y", (y2 - ((Point3d)(ref min5)).Y) / num4);
			Point3d point3d3 = exoHull.Point3d;
			double z2 = ((Point3d)(ref point3d3)).Z;
			Point3d min6 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("z", (z2 - ((Point3d)(ref min6)).Z) / num5);
			sleefe2.StartRadius = num2 + val2.Evaluate(text)._Double * (num - num2);
			val2.ClearVariables();
			List<ExoHull> hulls2 = exoMesh.Hulls;
			IndexPair hullPair2 = sleefe2.HullPair;
			exoHull = hulls2[((IndexPair)(ref hullPair2)).J];
			Point3d point3d4 = exoHull.Point3d;
			double x3 = ((Point3d)(ref point3d4)).X;
			Point3d min7 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("x", (x3 - ((Point3d)(ref min7)).X) / num3);
			Point3d point3d5 = exoHull.Point3d;
			double y3 = ((Point3d)(ref point3d5)).Y;
			Point3d min8 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("y", (y3 - ((Point3d)(ref min8)).Y) / num4);
			Point3d point3d6 = exoHull.Point3d;
			double z3 = ((Point3d)(ref point3d6)).Z;
			Point3d min9 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("z", (z3 - ((Point3d)(ref min9)).Z) / num5);
			sleefe2.EndRadius = num2 + val2.Evaluate(text)._Double * (num - num2);
			val2.ClearVariables();
		}
		for (int i = 0; i < exoMesh.Hulls.Count; i++)
		{
			if (exoMesh.Hulls[i].SleeveIndices.Count >= 2)
			{
				exoMesh.ComputeOffsets(i, modelAbsoluteTolerance);
				exoMesh.FixSharpNodes(i, sides);
			}
		}
		for (int j = 0; j < exoMesh.Sleeves.Count; j++)
		{
			Mesh val3 = exoMesh.MakeSleeve(j, sides);
			exoMesh.Mesh.Append(val3);
		}
		for (int k = 0; k < exoMesh.Hulls.Count; k++)
		{
			_ = exoMesh.Hulls[k];
			int count = exoMesh.Hulls[k].PlateIndices.Count;
			if (count < 2)
			{
				Mesh val4 = exoMesh.MakeEndFace(k, sides);
				exoMesh.Mesh.Append(val4);
			}
			else
			{
				Mesh val5 = exoMesh.MakeConvexHull(k, sides, modelAbsoluteTolerance, cleanPlates: true);
				exoMesh.Mesh.Append(val5);
			}
		}
		exoMesh.Mesh.Vertices.CombineIdentical(true, true);
		exoMesh.Mesh.FaceNormals.ComputeFaceNormals();
		exoMesh.Mesh.UnifyNormals();
		exoMesh.Mesh.Normals.ComputeNormals();
		DA.SetData(0, (object)exoMesh.Mesh);
	}
}


===== IntraLattice.CORE.MeshModule\HomogenComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.MeshModule;

public class HomogenComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.homogen;

	public override Guid ComponentGuid => new Guid("{a51ac688-3afc-48a5-b121-48cecf687eb5}");

	public HomogenComponent()
		: base("Homogen", "Homogen", "Homogeneous solidification of lattice wireframe", "IntraLattice", "Mesh")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Wireframe to thicken", (GH_ParamAccess)1);
		pManager.AddNumberParameter("Radius", "Radius", "Strut Radius", (GH_ParamAccess)0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Thickened wireframe", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		List<Curve> list = new List<Curve>();
		double num = 0.0;
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetData<double>(1, ref num) || list == null || list.Count == 0 || num <= 0.0)
		{
			return;
		}
		int sides = 6;
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		ExoMesh exoMesh = new ExoMesh(list);
		foreach (ExoSleeve sleefe in exoMesh.Sleeves)
		{
			sleefe.StartRadius = num;
			sleefe.EndRadius = num;
		}
		for (int i = 0; i < exoMesh.Hulls.Count; i++)
		{
			if (exoMesh.Hulls[i].SleeveIndices.Count >= 2)
			{
				exoMesh.ComputeOffsets(i, modelAbsoluteTolerance);
				exoMesh.FixSharpNodes(i, sides);
			}
		}
		for (int j = 0; j < exoMesh.Sleeves.Count; j++)
		{
			Mesh val = exoMesh.MakeSleeve(j, sides);
			exoMesh.Mesh.Append(val);
		}
		for (int k = 0; k < exoMesh.Hulls.Count; k++)
		{
			_ = exoMesh.Hulls[k];
			int count = exoMesh.Hulls[k].PlateIndices.Count;
			if (count < 2)
			{
				Mesh val2 = exoMesh.MakeEndFace(k, sides);
				exoMesh.Mesh.Append(val2);
			}
			else
			{
				Mesh val3 = exoMesh.MakeConvexHull(k, sides, modelAbsoluteTolerance, cleanPlates: true);
				exoMesh.Mesh.Append(val3);
			}
		}
		exoMesh.Mesh.Vertices.CombineIdentical(true, true);
		exoMesh.Mesh.FaceNormals.ComputeFaceNormals();
		exoMesh.Mesh.UnifyNormals();
		exoMesh.Mesh.Normals.ComputeNormals();
		DA.SetData(0, (object)exoMesh.Mesh);
	}
}


===== IntraLattice.CORE.MeshModule\PresetGradientComponent.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;

namespace IntraLattice.CORE.MeshModule;

public class PresetGradientComponent : GH_Component
{
	private GH_Document GrasshopperDocument;

	private IGH_Component Component;

	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.presetGradient;

	public override Guid ComponentGuid => new Guid("{6a4e5dcf-5d72-49fc-a543-c2465b14eb86}");

	public PresetGradientComponent()
		: base("Preset Gradient", "PresetGradient", "Generates gradient string (i.e. a spatial math expression)", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddIntegerParameter("Gradient Type", "Type", "Selection of gradient types", (GH_ParamAccess)0, 0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddTextParameter("Gradient String", "Grad", "The spatial gradient as an expression string", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		Component = (IGH_Component)(object)this;
		GrasshopperDocument = ((GH_DocumentObject)this).OnPingDocument();
		if (Component.Params.Input[0].SourceCount == 0)
		{
			InputTools.GradientSelect(ref Component, ref GrasshopperDocument, 0, 11f);
		}
		int num = 0;
		if (DA.GetData<int>(0, ref num))
		{
			string text = null;
			switch (num)
			{
			case 0:
				text = "Abs(x)";
				break;
			case 1:
				text = "Abs(y)";
				break;
			case 2:
				text = "Abs(z)";
				break;
			case 3:
				text = "Abs(2*x-1)";
				break;
			case 4:
				text = "Abs(2*y-1)";
				break;
			case 5:
				text = "Abs(2*z-1)";
				break;
			case 6:
				text = "Sqrt(Abs(2*y-1)^2 + Abs(2*z-1)^2)/Sqrt(2)";
				break;
			case 7:
				text = "Sqrt(Abs(2*x-1)^2 + Abs(2*z-1)^2)/Sqrt(2)";
				break;
			case 8:
				text = "Sqrt(Abs(2*x-1)^2 + Abs(2*y-1)^2)/Sqrt(2)";
				break;
			case 9:
				text = "Sqrt(Abs(2*x-1)^2 + Abs(2*y-1)^2 + Abs(2*z-1)^2)/Sqrt(3)";
				break;
			}
			DA.SetData(0, (object)text);
		}
	}
}


===== IntraLattice.CORE.UtilityModule\MeshPreviewComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.Properties;
using Rhino.Display;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.UtilityModule;

public class MeshPreviewComponent : GH_Component
{
	private List<Mesh> m_mesh = new List<Mesh>();

	public override GH_Exposure Exposure => (GH_Exposure)8;

	protected override Bitmap Icon => Resources.meshPreview;

	public override Guid ComponentGuid => new Guid("{c5e3b143-5534-4ad3-a711-33881772d683}");

	public MeshPreviewComponent()
		: base("Mesh Preview", "MeshPreview", "Generates a preview of the mesh.", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Mesh(es) to preview.", (GH_ParamAccess)1);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		List<Mesh> list = new List<Mesh>();
		if (DA.GetDataList<Mesh>(0, list) && list != null && list.Count != 0)
		{
			m_mesh = list;
		}
	}

	public override void DrawViewportMeshes(IGH_PreviewArgs args)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Expected O, but got Unknown
		DisplayMaterial val = new DisplayMaterial((Color)Color.FromArgb(255, 255, 255), 0.0);
		((GH_Component)this).DrawViewportMeshes(args);
		((GH_Component)this).DrawViewportWires(args);
		if (m_mesh == null)
		{
			return;
		}
		foreach (Mesh item in m_mesh)
		{
			if (item != null && ((CommonObject)item).IsValid)
			{
				args.Display.DrawMeshShaded(item, val);
				args.Display.DrawMeshWires(item, (Color)Color.Black);
			}
		}
	}
}


===== IntraLattice.CORE.UtilityModule\MeshReportComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.Properties;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.UtilityModule;

public class MeshReportComponent : GH_Component
{
	private Polyline[] m_nakedEdges;

	public override GH_Exposure Exposure => (GH_Exposure)8;

	protected override Bitmap Icon => Resources.meshReport;

	public override Guid ComponentGuid => new Guid("{f49535d8-ab4a-4ee7-8721-290457b4e3eb}");

	public MeshReportComponent()
		: base("Mesh Report", "MeshReport", "Verifies that the mesh represents a solid, and returns a comprehensive report.", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Mesh to inspect.", (GH_ParamAccess)0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddTextParameter("Report", "Report", "Report of inspection", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		Mesh val = null;
		if (DA.GetData<Mesh>(0, ref val) && ((CommonObject)val).IsValid)
		{
			string text = "";
			bool flag = true;
			text = "- Details -\n";
			m_nakedEdges = val.GetNakedEdges();
			if (m_nakedEdges == null)
			{
				text += "Mesh has 0 naked edges. \n";
			}
			else
			{
				text += $"Mesh has {m_nakedEdges.Length} naked edges. \n";
				flag = false;
			}
			bool flag2 = default(bool);
			bool flag3 = default(bool);
			if (val.IsManifold(true, ref flag2, ref flag3))
			{
				text += "Mesh is manifold. \n";
			}
			else
			{
				text += "Mesh is non-manifold. \n";
				flag = false;
			}
			if (val.SolidOrientation() == 1)
			{
				text += "Mesh is solid. \n";
			}
			else if (val.SolidOrientation() == 0)
			{
				text += "Mesh is not solid. \n";
				flag = false;
			}
			else
			{
				val.Flip(true, true, true);
				text += "Mesh is solid. (normals have been flipped) \n";
			}
			text = ((!flag) ? ("Mesh is INVALID.\n\n" + text) : ("Mesh is VALID.\n\n" + text));
			text = "- Overview -\n" + text;
			DA.SetData(0, (object)text);
		}
	}

	public override void DrawViewportWires(IGH_PreviewArgs args)
	{
		((GH_Component)this).DrawViewportWires(args);
		if (m_nakedEdges == null)
		{
			return;
		}
		Polyline[] nakedEdges = m_nakedEdges;
		foreach (Polyline val in nakedEdges)
		{
			if (val.IsValid)
			{
				args.Display.DrawPolyline((IEnumerable<Point3d>)val, (Color)Color.DarkRed);
			}
		}
	}
}


===== intralattice.csproj =====
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <AssemblyName>IntraLattice</AssemblyName>
    <GenerateAssemblyInfo>False</GenerateAssemblyInfo>
    <TargetFramework>net40</TargetFramework>
  </PropertyGroup>
  <PropertyGroup>
    <LangVersion>11.0</LangVersion>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <RootNamespace />
  </PropertyGroup>
  <ItemGroup />
  <ItemGroup>
    <Reference Include="Grasshopper" />
    <Reference Include="RhinoCommon" />
    <Reference Include="RhinoCommon" />
  </ItemGroup>
<PropertyGroup><PlatformTarget>x64</PlatformTarget></PropertyGroup></Project>

===== IntraLattice.Properties\Resources.cs =====
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Resources;
using System.Runtime.CompilerServices;

namespace IntraLattice.Properties;

[DebuggerNonUserCode]
[CompilerGenerated]
[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
internal class Resources
{
	private static ResourceManager resourceMan;

	private static CultureInfo resourceCulture;

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	internal static ResourceManager ResourceManager
	{
		get
		{
			if (object.ReferenceEquals(resourceMan, null))
			{
				ResourceManager resourceManager = new ResourceManager("IntraLattice.Properties.Resources", typeof(Resources).Assembly);
				resourceMan = resourceManager;
			}
			return resourceMan;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	internal static CultureInfo Culture
	{
		get
		{
			return resourceCulture;
		}
		set
		{
			resourceCulture = value;
		}
	}

	internal static Bitmap adjustUV
	{
		get
		{
			object @object = ResourceManager.GetObject("adjustUV", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap basicBox
	{
		get
		{
			object @object = ResourceManager.GetObject("basicBox", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap basicCylinder
	{
		get
		{
			object @object = ResourceManager.GetObject("basicCylinder", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap cleanNetwork
	{
		get
		{
			object @object = ResourceManager.GetObject("cleanNetwork", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap conformSA
	{
		get
		{
			object @object = ResourceManager.GetObject("conformSA", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap conformSP
	{
		get
		{
			object @object = ResourceManager.GetObject("conformSP", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap conformSS
	{
		get
		{
			object @object = ResourceManager.GetObject("conformSS", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap customCell
	{
		get
		{
			object @object = ResourceManager.GetObject("customCell", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap heterogenCustom
	{
		get
		{
			object @object = ResourceManager.GetObject("heterogenCustom", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap heterogenGradient
	{
		get
		{
			object @object = ResourceManager.GetObject("heterogenGradient", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap homogen
	{
		get
		{
			object @object = ResourceManager.GetObject("homogen", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap meshPreview
	{
		get
		{
			object @object = ResourceManager.GetObject("meshPreview", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap meshReport
	{
		get
		{
			object @object = ResourceManager.GetObject("meshReport", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap presetCell
	{
		get
		{
			object @object = ResourceManager.GetObject("presetCell", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap presetGradient
	{
		get
		{
			object @object = ResourceManager.GetObject("presetGradient", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap uniformDS
	{
		get
		{
			object @object = ResourceManager.GetObject("uniformDS", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal Resources()
	{
	}
}


===== IntraLattice.Properties.Resources.resx =====
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
<resheader name="resmimetype"><value>text/microsoft-resx</value></resheader><resheader name="version"><value>1.3</value></resheader><resheader name="reader"><value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value></resheader><resheader name="writer"><value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value></resheader><data name="heterogenCustom" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAABwMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAApxJREFUSEvtlU9ImmEcx7NITUuXGkhlFkGzf4xGukuHLm5sB4kuBkKHoNARozEQWXbKCJK8LHepU8SiuUO33YJkkWJLpE0zCUUPjW4brli1vvs9ryZrjU2tYx/48fI8z+/7fZ/nfX7P85bc8gcyijEKBde6YZjpJwpQPGcd14EvkUhczc3Nyba2tnfU1lBcmLPntVagFovFEb1ef7y0tITR0VGIRKJz6r8R80dCofCb3W4/SyQSODg4QCgUwvT0NKj/J403ZdIKp5Rm6VAoFOnl5WUkk0mkUilsb29jdXUVKysr0Ol0Z3w+35TNLwhZZWXlB61Wm/b5fGAzj8fj2NraypkvLi6ip6cHlGfOavKmm2Z+aLFYTiKRCPb39xGLxeD3+y+Zz83NoaKi4oTylRlZHggEAgtt5vf5+XlEo1Hs7e2BvWRzc/OSORtvb2//QRN5lZX+FyEt9W1LS0t6bW0Nu7u7CIfD2NnZwcbGxiXzhYUF9PX1nVPJfiRdaUb+b0R3xOIv95RKPGxtxYjBgPdkGAwG4fV6r5hbrVZWPV9Jl/enGWzVaDAxMQHH5CSemkzolkrx0my+Yj47O4vq6uoj0jzOSPPDTOWGqakpuFwuOJ1ONNbV4W55OcYGB3PmbrcbXV1dx7Sxr7O6vLlfU1NzymbHzGtra9npRFN9PbeSGYeDMzcajef0aaI0xudUhSCVSsP9/f05c5VKBY/Hg5nxcQz09sJms4EOVJrGGjlBEXTyeDzubrkwZxvsp0P2pKMDcrn8qKysbCCTWji5K5e9ZHh4GOvr6wgEAlyZPlCrWdW84TKLgP0sfr9yO2Uy2eeGhobToaEhGKhk5VVVh9QvpCiKZxR/u3K7KdjYCIWEdRQLM32Rfd6SpaTkFz+5ZH6PyxmIAAAAAElFTkSuQmCCCw==</value></data><data name="meshReport" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAApAIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAjlJREFUSEvtlEtoU0EUho9WSgVBhK5c2G601Ejt0kcS8qqYIHlBVkJUElzURWPcCZIWQunKmhI3gpFUGiuCSJRsFKRYA+riYhVBG0oCrqSozSI2SZPfM2VS094E+gi46Q+Hgbkz/3fuuZefdtUS6fX6Xo/Ho9jt9qjBYOiX262R2Wz2sXEpmUwiFovB6/WWXS7Xb6fTeUen0/XJY1sXd3rA4XC88Pv9K9lsFoVCYa0ymYwK9vHqwZsI0gdcp0FpoRYuUwcfMg67es5z14uRSAT5fH6d+cbKfJnD15HT+OUlvOomVAK0Ag+1S8v1wg16sniRsDxIWBrtQ+n1bfz5sdDQWNRyTkF1rAfz5wiP9xMWbAT2mJF2avHDT+9OEh61E152EeYHCMVr3NXEWRWs9PYeysEOvOklPO/khq7weukwxBSknVoIUH/a34lyoA3ZC4SZo2pYNXIK1YkzqyN5doiQPsH7DJq9OwSTyQRp1Vzi0Nz7WeSehrE0rm8IS2v+jeTnrW4kH4wjkUhsHqAoylo1gj3klxUj+TY2gOmpyVXzbQPqS8D4O2GSAWKtGbcMIGoXsC1APB6Hz+eD2+3+LG2ai8OtHA6Hi6lUalOAaDQKzqMK59F9zq990qa5OCGPM2TUarV+50v5jbB6QCgUgs1mKxqNRru8vjVptdpjFoslxCbZGqwewIGY45F2yeM7Uw1WCe7BVBvnU5CqGo2mcWruRNz5tMgkscqt1or/w70YoiNilVv/U0R/AeBAmCF6RMFRAAAAAElFTkSuQmCCCw==</value></data><data name="adjustUV" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAfwMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAxRJREFUSEvtk2tIk2EYhufcHEvZYi1/+CfRDi5FkCxs1lIjMIhSKBpF6o9SCkxrKzHNmjl1puZ5lZpl2AykIqzUMjMrT3mYWVrZgQ50wJIVZSR193zfnIR41l/RBRfv93x79zy897tx/inWDFsDh63TBsPW16Sc/MRWM8DwAUVkJXmdrWaAPjKCNLEVh+NFMsPC2Wp0LPsYvzMvRoPJvphcy1ZmEsnZ5scxCSbfkZbTTwkpj8crs7bmfqP1PtWe5tdDzV3JfubFVLDj8/kdodtDPnU9qEdRYc4PoUDARJpOWpoz2A+uk0LE5/MaAzesM91vrEGn8R56uluwTxXOxPGb1LC7JokN6UaqKY7PmzYGmKoqLiEmWo2lnh5YIffCnDkSGEoKsGC+02sul9tGe3eQCwe/Ozq02URNv4jF4vdyudeHJK0GpedOIysjBf7+/jAajdDpdAjapkRXZyNePG1HSfHJb74+K5/T0LcU5Vdq02vuNjKIOxiDRG080tN0yMvJwKkCPfarI6FUKsFgMBhAkaGl6RYeGuvx7HEr3rzsHJLpYW41MlCrVYiNiUbCkcNITUlCdlY69HlZWLLEA+7u7nB0dIR8+TLcrrmK5oab6Gi7gyePmvHqecfEBuzatRN790TiQHQUNIfjoEvWIjMjFcfzMpGcqEH+iWy4LnbBar9VqKkuR8PdG2hvqUM3Rfayp338AaGhoQgLC0NExG5ERe3DobhYJCXG4xgTWS5FVqhnY1ssc4GfrwLVVZdpmAKtTbV41FE/9gC64B8CgWCALvknE4W3tzdCgoNwMPYAtAkapB1NRg5FVnAyl1UmWwRfHwXbtO5WBRsZ88w2GwMxOc/W1naLRCIptbOz6xWJRAMKxUqo9kYiRadFVmYqnU5laQb69aDy6gXU3rwyoQEjIZNKpefodP3Ozk6/tm7ZjBS6Gz3dS/6JXPZeLpaV4Fp52ZQHWOAxJ5NKJEaBwGbAzc0VgQHr6Z8diWw61dkz+dMe8DezKLqtDg4O5+3t5/aIxaI+oVDYb2Vl9XHw8/+MB4fzB/s7jSTTDVEfAAAAAElFTkSuQmCCCw==</value></data><data name="customCell" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAIwEAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAALhJREFUSEvtld0JwzAMhP1o8N8GXqt0l4I3KqWrlM7gMdxTGoEfXFcRFArJB+bASOhkIsUcbCKldIW0GOP9fSMnhHCDfM1ttdZGqjld7hi4oOrNe/+E5uVSRnbOUY6oe3KQrbUXaEHiebkdgCc9QcoaS4Y+u+/goIKWC+nsdDGEvMDqfNrBIGZTBwQ7m9HHHAWG7LUAD5Fk0LSf6U8HTbQqeNDEq4LXtWbZIecB/ZN1rfzhqHN3jTEvwjCGbgK3NQUAAAAASUVORK5CYIIL</value></data><data name="meshPreview" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAmgQAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAABC9JREFUSEvtlGtQVGUYx5/dc3ZlCRUTG1HCS15KioFFyCXAPqCVReOMoGiORhdouLlc9iILKBClhljERRCBgpwmQFMEAoI2B7AgLEkkBhqjSByhEM3lzr93l2NEm40f++Bv5j975pw9v+c9z3POS/f5fxPmTGsi5HxypJyvi3Lh+yLlknGWMXbcG+nMVyud+H0hzrRE+Pu9E+xAC5mkWOUmGcwLmNfdkGo/3PnRSvxcsgqdRctwId0OFdr5t97dLLsS7SL5gxXNVzqRtXD7f7PHgexVrpJrhUE2g781vgRD59swtIVhQO+E65854JeTrEjhUlw6ugjfHLaBPm42Up6T9Ee5SDrDHMlO0NwVsWadtP20bvmo4Uouxn/XY3LwHCb6SnCzXm4q0F2yEh0FS3AxfSG+PvggvoyzQlWEBGkviG9Hr+WbjY4p1b+gdOa2H9hkabjVkYax/i8wPqDHBIvh+5fRX/MEej5djS7WokvZi02rr0+Yg89VFjgbLMaZQIJOwd2IdOL8BJ05e5+SflW1zxZDV6swcr0Ow7+W4EbTdlyrWGNqTVfRUrTlLEbLkQVoSJqLWq0MFaEczgSRKcd8RWCzqxV0M3GMpoei3CWT32baoafME73VG9Fz6jF0F6/AjyeW44c8e7Rm2qI5ha08cQ5qNTPlxhQHEJTr+FEHP5IK2mkUsVTDBoXv0heh/fjDJqHxty3HDq0ZtmhJXYDzb80z9bwmetZUW/4mN+bUa4RIFx4uakoUtNO4acmw34/HiaDZphYYY+xz06H5aHzTGufirVCrtkBlOG8mvpOMzWIon+HAXD8J2mncddSRcJYQ78MjcYMUuTtkKA6yRFm4DOXhUlSGTYtPs4GWvEL4eDchf5sIaT5i6Lx4RHnz2JFKcNVQl6Cdhs3gccVeGs3vJeTWiZCiEyPBl0PM0zw0Ch7sY5oRNTunXc8j5kUO6jfECDkiwq4iwpMaGpNHk4+gnck2f25kZw6hdIitbpBQ2E84fpVwtJvwfifh8GXCgYuEpGb2pI0ErZ4QVUMILycElhI8Ygh+W0RDgs6cPa48PLWEQ60zC6S2EyIqCbsKCFvfIfhnEYJOEtR1UwXCWIENSYTXlWzIcn5S0Jmj87DoLStYBm+tCN7xBN+DhI2xBE81ITSEQ7avFEWbZiGO9fz5UIJCw64nEtazlftHET7cSVCtlXQLOnO0CmnisVdtxiYuu6PhgxXI3m2FTE8eeasJWY+wp1klwidyHtW+lmjYPxdlMTJkRHDICmbDZ4NP8OJus11WI+jM8XMgaayX7MJ7W61HWnIfRU+5I/pqHP/a5IxfsnGbML7C55OtUa2SoTRQgpwtIsR5cMNqV15vdAi6uyKOXW8RkPzsA02xXhY3Va7SiX++QXfC2jGmceMHYhR8fYQz52+8d0pxn3uG6E9YwmZSRUkx3AAAAABJRU5ErkJgggs=</value></data><data name="heterogenGradient" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAAQMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAApZJREFUSEvtlVtIFGEUx/+u6e66pSlWloX2EFtYWhFhRGJRxPYiQRkJdnkxJTSjxK5m2q7besFSLATLoB7UB+0eKV1AJYrSwJSCEB+EsKdiTTOdf2fcacUE3V189AeHmTmc8//mO9+ZM5jjP8LEssXCx59mGVW0S4xiJ1WHz+wHAu0LUFYVhb7qVWhIBFaL+5+4evV9B+eBKJsRPfUJfkO91XvYcmw7C4w6ZcVsiOcBu616/Hx/Qj/KT7lk722yNYV9Z8E8PcZigZVaqNforAZcKQ6Ds/9GBNl9gfxSTr7eS94CeROs24DRAn+kaPGeI6cVZgtCa20cnENPY8muHLF88oXFLc7rYNNmsGQ+0rU0z5B6b7IaMfAy1W9Ead9GdmaQHdnk88RJ4sNWsMiAkRwgQkudmcIAZMibD3516Mk3O8h3B8m3R8ln8ZPElRLwrhm/rwahQkudniOAwWZCfWU0nD/qg8n2BDEpR5vU+1HcJHGWgm0WKA4TOiRV51KYhjQgqMiEb5VLwFqzjg8sizhwZz35SnZw3zxFvP+4lEa6yuPSXAQO1a2R5EvgWCHYmTKPjmB/th1eOEV8OB8sC8Gvy4BFS58ZWSD9sXQD5dBYDH63gVuXgqcDwPZ9E+IsAhvWYshuRJWW6hnngI3XwjGqOFziMSIubsYvg+xEfLku8Q9JUOwGfFZHhivTC0pC0NOcNCEeEynCNeDHbOn1LXKfCdoC4TwDRLsyvGQnsG6xHxS5dYuzSc7kIVhjBstDMZgPJLuivcc9ctVFWlKlzxtlgSdiLWDF8vG3vzce6QPqz8I9ctWdlIaiuzISf5oPgI27QLsJA+p3ogb7QpbYlJGrjgvpriyxtEwgWHP7hCp6SrvOoQH8BU+YZO+a7p1KAAAAAElFTkSuQmCCCw==</value></data><data name="presetGradient" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAATgMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAuNJREFUSEvtVE1IFGEY3svqqvszs4kU9GeNOzvr/vobmYymtNZa7Toz+zuj5lpQIrGrBQlBEEU/7B46eAk1MrA8FB2CTnbq6CUJEuokhOJP0cFIhK/3G8ectSm91cEHHt7nfb/heT52Z17dDv4fGI3GhsLCwiql/a3HGs+UFp87ioqKXEqrM5vNVlzWOg2YTKYMML1urNGn8UzRx8BQgposKCjYD9wHmjYYDAfBSr/muAlwOJCfnz8IdVirbpo9BN4CXtfr9Rfy8vISoJvBphp4AGjEnjmABzM0TX8KBFont8OWlpNvTvj9L5qa/UONjU13WbYpzbJsrK6Orff5juKQXOAATohM916+gmKJri0ZjXfOhWPt74SI9JrjpSE+HL8RbIsmT4dixwMcd0ix3QAOEMKR6SAXQ2V2L7pzLyvXEB9H/lNBWasZaG2bjYldUxTtHafsnixl86RACxTlPgLcq9huYD0gxCeQjalAGPim8/ML6GwoKs/U5ARp7svi4sqlntSEze7NUkzFWgBT8feANl5EtKNSDsDmcTEp95tpc1TOJM/3vP+29PV7X//AMwhNwfzvAWEI4AQR2curNgKkbjQyMorQ6qomfywvr/bjgPKq7QREp/mwhBhntRyQaO9G8wsL8D8k5Jma8Bz8REsrPb19E3ChLKMEMFsGRDqQw1WLhh89kasQ7USBM2FZqxnixdmOrotTDlfNOOOqyQJToCGgFgJqtQM4IfwxyMXhLfFth5/h7ZmkaN/LMto7aLO5r1G0Ryy1uev3lDLa34HT6ZpxOj0fTCZyaiuaCfKtmSx+RZC7HhPW4gxJllwFigRRzBoMBF4ZuYCdcxN2yhh89vdh3zxf11CfAkcVPYbPsIaV8QDWw224mAQ8B7MQ0A1Wh4EW2VQNgiAyVqs1regGi8Uib1L1HM/wmTKXYJ7EGrbqbrhgCdYAk1JzoTZV409zMHeQJPlrXaugvU138I+g0/0ELVpvgBc1D7cAAAAASUVORK5CYIIL</value></data><data name="uniformDS" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAQQMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAtZJREFUSEvtVNlL1GEUPeOo2UtQ/0JgpdLyUmnkMuMktNBmloZW0B600L7XSz2EuYEyqSmVla06E2pQaabRg6+JT+aWFgaSFeOMM97O9fcLehlzCKIHD1z4+H6/79x7zz3fhyn8/0gA4uwRcK6IQl9SGHwajkj0p1jh1G/mb6EjFoi0R6LCMQ2esnQEHmyHfCmBDF6H3FkFKVqMQGo4RuxWVOq/5rHJQQ84otC2cza8w1UQ/1NIy1mIrxoycgvSuJ/JzkA6d0C2zYKXidpCSqKVK3l5JqT1IuMSZHzNJG9OQkrXQl6QvG41JH8Bk8yE1xaG2+bxibEEiFFZhu8axGN1jHrIW679tZDRh5Dmo5DhfMjnIxB3KqRjA4RdeOKBuSZNcNgiUFyeAb+/xiAda4DIc64vQwIuJnjEBMcg3wqZgIncDkj3FosUxCDALkpNmuBIm47eag609RxlyTKINcq3cu8CZ3GaEq2HvNwFqadUBQshtcu5R6k48AGTJjgSacOhUqPS1vOs2m2Eko8+4aDvQZoOQYauQgYOsAMbO8iwSMcaSKIFPpMmOOhz72ARxMsZaLWjjw3iFrrGdx/iqYS82ku7ctgf2YUrGdKVzgQc+KQS8BL1VlGCpoOGFM3HGSe45iBfHzbIi5PoIN4Ftx2SF0uJEvh9PgdtRZ9JExw2K4oLl2Js6ArJ9kC+83L9YDTug3y9xsrZldqzjzbtybRI7TLIh3UWyYuGn0O+YdIEh1pNLdfJ9hvYweApg7RhI+QTu+rfbVTek2WRrk0WqYmHvF85PmCPWtykmRj8uSybl6dgEeRZmhG6Vs+7UihLHGVh5UqeOweSPYMXzYoK8/ifMf5UhONdDpN0sHKt1kXduzcbVf+SRSvPITm1D+2pUOgBVnVTW78+D34nfd5OK7ZzuE52kBuNgH7TykMm/x36JHN4JeyoN9mCEQ11i+791XM9hX8E4Ccrw5WuHG+10AAAAABJRU5ErkJgggs=</value></data><data name="homogen" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAsQIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAkZJREFUSEvtlF9IU1Ecx7+N0WD2x0IjC6r14sIk20tBVAslzaeCioQCXxIppMKgoD9rrM3FBKMeDHI+FkaiRSwIJdSWlEUFBmlUzN7aU08J3u6339nuFrfNzN0e/cCX3Z3L+Xy5955zsMAflEj8knWpf4XQAiy7BJz2AYHLQK0M2dJ3UvJxCSVX1cC8aRVJyIlEfx1+DJ10s8vjmr623DF1FPDK7Yxc/aqy+ZGRx5uh8fVe8mu35A4/3G5loMiul/83+dgu8nMH+aVTIiUjDfwWAP0O6MeA3caUf8ckf7GNnPRJ2iRSMnSA7AZ5C5xoAoMOJGRK5pvMjUk+WkW+PyU5T45LyWBdVs4bknawswzfLwI1xvS/Y5LH3eS7RvJtM/lGSp54c+RsA4erocvqChqK2THJR1zkq/3k2BHypZQ83p5XTj/YV4lpWbpnDE1+TPLhNeToHvL5PvKZlDzaMqs8XgMttBgJtU8MVS5NgDPsRDK6AexyLWLPjhVM3NxMPpWSB+Vzys8CqwxVfuQDHezZBJ0+mRgEPx638XqpnbH6JdSjMmZFrpAj4HDfVikQOSNgMgR6VoMn7GCs2qJccU4OqchSzGjhtLyiLLU76VkLdpSAUy0W5BnaizHY6/0trxB5Ul7Ppyvg3SqLckUlsLHUBk0us3L2S2Jg1G1RLmSPXCn52VsPavfTcg7IypICK/KVkuyRq55EXtdApBgzD2uh39sJPVyEZKFyRaMk58i9AKyX3dkgOaT2iTFcEGqyOFJPsoAB8AsFYq4Y5bNA3AAAAABJRU5ErkJgggs=</value></data><data name="basicCylinder" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAmAMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAy1JREFUSEvtVVtIk2EYfl1uOjXnStNYh2Un80Rpqct5mJWWumqJZgc08rgyD1lQWhc1lK1WmpRJ2EUlphO16GA4qCBLvCgM9UIoIqLYhdCCDKW1p++fP97q1m0PvPD9P+/zPt/7Pj/vT//xz4gm8koiSkgmKkkhOqUiOs3OBdy7MCIRn+Y8WJGggzLvJ+meC2yHZGK7USNHy5EQGNQrcDJKitL1vrZ0D4HtQIDoWSLRcp42P+wkitT4eUzdLgrF5FAWxu4koWnvUlieZeC+di0+96YCo7n4MaBBS/46ZIgFNsZR8PS5ofETfb9xIBgDxpjZ6DsXCV2CH3RKCbqrQnAzW4Zru4PQVrwaTTly5PgLLTx9brBZ46V+82zxF/VRaMlZhgvxvtCnSNHECn99tNPRBRfTb7PBcXj63OCSB66n4VtfBgYbY9GQGYjhW0q8a9nqeP7yMA1Ne5Y6zpb+TLyqDXZewDZeg84TG3EuToqO8jCY67agqyoUbdp1MOui0FmyGoZECRq3uMN2iZwX+Pi4CBguxXmFPyz3YjFSJ0d/6UJcSxJgREuwHCfYjxFMiYRP1S4IjD8oRO9ZJSrC/WDtUgA9YcC9JTDtI8BAsFYSxrIIVyNYboULAtNjZ/FrsABlG3xxN08O43Yprqg8oYsmGGMId9nN36QT7isJU/UuCLxqzoal7zDObw0A+pOBXq6DwJkO2MxRy6KMCcWxDyLfBQHbeC2eG3YgT+aFLmaouVKGgUoJmlMI5lxC5zZCK+vmxiaWq3dB4MOjYuC9ljc5DiP1q/C6akbAYTK7vZ0ZbUpgucwPpwXGHxai54wS5WESTHQo8KebjaiNG5Gb48YT5YT3Gt7kE04KqH08Rp/qM+1TQ8XMZAnaC4LRkCaFMVmMi2wsjQpCu4owpCZ0MJP79xPUnjTK0+cG26Qhu8TCidai6N81sYsBswp4EM46CIIpyw24PGOytZBQvZzs6UKyso0awdPnB25dq31EpjShYProSm8r20GTzbu8bJVrCHUb6WfeIvqRKqAptZDauVye5jziiRZyPxc24yIWp7hgBfNZxLFw59P+w1UQ/QW02ctcYwHVGwAAAABJRU5ErkJgggs=</value></data><data name="cleanNetwork" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAVAEAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAOlJREFUSEvdkb0NwjAQhSMqBqClQ0zgOjKidhuJLRATZBSWomEZcw4+Kzzx4kMJFDzp6Wzrfr7kmr/SSnzKTmerzHVd27YxhBDT+fn0ItaoVlfUOeei954lska1uiIlPOczErNGWFeVzxGJsZHeFUDrqioDCDEDOIjHA6m0ARKrGEBvXTaS4KczgN66bCTBAQxA36vLRhIcwAAwUiEJEjMA8wBMRGIEmD/ASIyRChOtxBiprA1qkcraAONevBZvh9uENOHTeBHfxcfh9kYpIS1yCd/EG/GiGgNexV8ZMPmL5monTkv+pZrmAYQqg4qG+I6sAAAAAElFTkSuQmCCCw==</value></data><data name="basicBox" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAeAIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAg1JREFUSEvtU99Lk2EYPWh/Q5GEbGs5c8vNfkzBdDXZjfCloWmFTrKrborhKC/sBwVZ0ZaRFhZGMZNGxRKJjKiEoKSCIqKBoqhR2czBbLrQ4vS9fnpX2zcY2IUHXp5z857znOd5Xyzj/4WUCWNlVlq4OmfFdKUhfUZUcSr+wct1mN2hhWfhenwI8V2G9MlXPsfc1Fsnn/lKGX3n5PjLvezrLOVccB+HnlSx/45EDuzn83b7RPN6RFUZCPFyfVrY22D5ffeSnc3uzfS3bOctj41nZB5oK2HH6a0832hlT7uDN49awyfXIuLfCCY0kDTIXux8pK9qvvPw6xoGeyvmO595X8c3gTK+8Ev8Fazno4u27083IdRlAjtyVRi4rHjYUIif9+sQObINsc49mBLcXYyYv0bhriLE7jkVfkCL0VAxeEoHXshRYeBxoLunFuQ58EG9UuPxqxZ87M0DvetAVSNK1uCwHqP9W0CfEWyTx5TQwF2Ax8ftisgJh1Lj8UM6fPpcBB7Tgq1GxFKe4HIuBrrN4BUD2GXBj5Qn2J2B8Q8F4HV5wWezMZ36JZsxOFwINmnAaxtUfLRkDVpNGAvI718k8JowkvIR1a7BpEjg0uBLmfwnpAxkLkj9HckmuGHG2O08DNpW42tCcYFkDQ5mYUhV54uo1qNRvhDdqUMofxUiosbj1pX4plp8GUsE4A85RfvAhERNNAAAAABJRU5ErkJgggs=</value></data><data name="conformSA" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAA3wIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAnRJREFUSEvtVElrU1EYPYmlYlf+AkGxCwUXbnQj1FlqHUAqTjggaFUEUYS2NG0GaxdSm7SmKJqmbTBOVDdCk6rFqgjiwmpdWFEXKm5VFKzN8I7nJi8Qh4VJdKUHLve+e+875zvf972H/ygZzWVoaQHG3MCEZssDpDSvt4+LRzOwVWSfPVOR9s9B8pkb/BAFb21DQmLpkkRcTjSJ3IpVI8UB8H4jeHknOFIPxg6DF7Vv3BQl0ghUeRywziwCU/3g1wh4fQ8YWAFGtoBWHORwCU68Dny6thAcbxLhBjC4EnygyI2TUR84sBt8qDl+BLxUqBMXUOt1wkoHwOQpsH0xeHaN1n0a58EbB0H/cjC8EUzHinDic2IsMFOpaQeHFemdOvC5CwytBU9Xg7cPifgK+PgYeGG7yI8W6ETRT8RXgdF1Ss1SRe2XWBDsXAZ2a38yDH6Rm6u7dC7BnlqdDxbgxHTOe0U5oui6RWqc3N2rzhHha+U9JOEOCT+SK1OTp21gr9xFF4DHp4ESoDg+2nQ/w1x4K7Kbm8En+1Rk5T8ooUSHuqkTPLkkmyrjJCEn5ypF6hR5BV54gboGYLZN9WsoRRG1KIdqFKFXNdiholaJ8IRcaH1vP/hG+e+RSKsi9k3BO5HOsl//PWREFFXOybg6p3d11klaLtKqSWsFeKAc1PWwhjPzYiHIORkUccaJatKl9BgnfZVIuhyZPE9qlChiOxnaBL5U8UNyYepUD8zTlRqNPyCSV5P+ubDcDryyjw3yRbrMRsHId9JWjoS+dv2uvkNOZDTzVAxyTvLS8yNmaEzPLouEETECWpZld/4C1PPz7eU/A+AbQyN66m5fZRIAAAAASUVORK5CYIIL</value></data><data name="conformSS" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAPQMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAtJJREFUSEvtU+tLk2EcPRteGvQHRB+yaY55C4w+SfeiexStL11pRSkKXaSgKK9kmTWbvmZqFkYJWYkFGSEhrA8hNNqXml8CIaglZJNSZzo9/R73hutiOv3qgRf2sOc953fO+b2YxYyRb0JpYRTeFRkxWAiMquc8kKn/PX3kAXsKDegvjsFI6SLQcwr03wPduaASyQdy9KuRIy8KjgID2LYF5EPwcy14fSv4wA62Hpdnf0hkWk7kpc2KXMsAeyrBb3Vgwy6wcTdYux3sbxbRF+NOIhZRsbSuAHsdYNUG8MpK0FscctItYjXbwJYj4uIY+EREIxJRF4uNGGEFOCSPcw1YvVGIneDAbYloH3hrp7jbJAPcH3eiHEtn2TrNxJDpPQ6zlFkEth8GXUclEhGqky7KRezNuZCTL/UhkUYRfHYCfH5wik6KDBh024RQoqlYDQ6Xg0FNyNZJXOul7Gvg12qwfgf4SEhVJ+FOJhVRF3plS7w54FXpoTsPfCl5tx0KOamRqcukk/eXQk5674A3RLhhCXjRhGABQFnfoE73N9QFt5C8OgB+Oi15S/6V4uSHFB6Q6cvlt3Ly4bJ0JJ3ctBgpsTJ3buxoVnS0dhaw6lT/hipKuXi8XCYskEllUxy6k6d7wddyVk7qRfiCyUCnOY4+r5dut5vp6el98fHxy3SqiaFEfnMiX7Ai1NaCo7JNQ+KkZI6BVUsX0+fz0e/3MxAIRC6inLToTt5mycqukmjOSCwLjSybP4+dnZ3s6uoaE3G5XLTb7d9TU1OHkpKSfDrN/xHuxCXx9Ah5jRSsdr69uZkej2dMxOFwBNPS0vyJiYmZZrM5Tn99avizk7sW8KQphpqmsaOjg01NTVTkEssC/ZXIEe6kJBrD2bGxzpSUlAElYrPZ+iwWy+Rf8GT45UQJySpaEhISMpRIcnLy8IymD4fuZEQ/QolYrdaP+nEW0wXwE3Pdwqx6hL8hAAAAAElFTkSuQmCCCw==</value></data><data name="conformSP" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAxwIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAlxJREFUSEvtUltLVFEYXdqM4H/opQu+9xoV3a90gXrofiMwlEqIyECdcUyEckZHTUcLu1ChheSLQ5SQUIGElCRISNSTlQ/VFGSN48xqbc4eZqgEz+SjCzbsc/a3v/WttTbm8d+oKsSlag9G/fmI+4GUWRVAsT3OHZXAfn8eJgMFSNYtAYfPg19vgy/KQENSBZTaUvfweRBU89SjbSDvg+Ot4BXtu4+CfWe0DjokOSnRpa2+PLB5uSZuAb91gDf2gHf2gR07wR89Iu3PKHFNUi1b+laBsSDYuhm8vBp8c9FRMiGytu1gbzEYlZLevS5JTGFgAVIMg/FGsGEtGF6vxtpPdoJdsqZzNxjZIWXdWUpkpzIrsW1mhqYfDinQWADsPwY+PQl+b5A18r9eSl5VZJSEN4F3RRgVwcMjs1Qigl9DmvCqLjdr+qQmTzSBjevAlo2Oki8K/Nou8J6atiuTWJeLTExBTIUjmjyoHCYqwYET4OPjCle2tW3R/zXg2zpHSeymctoAXl8G1hZi2gdQK27b/Q1TMKQmzw+DH846SsJqmAiBP2VVSPuIzsfrwSllElmEpHlxfg9GlMHpcmCpbfVvmKAMyYOVmtAPjp3KKInK78FSR0mrLKspQEqWvlPTxfb67JAmMUqeHQI/npPneq5NNpMpKanxIun3YtBecY80Sc8KR8loiYLWK/qkV9S+ENN6lu9tae7IVjJwAPxcrpBll/HctS0z4c9MbhXJ93y8tsfZeKn1xNm6RLaSWi8S+i6zR9kwpIYkN6RJzLoAFNnfcwtLkrSf85grAL8BOKdwLH375ZQAAAAASUVORK5CYIIL</value></data><data name="presetCell" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAUwIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAehJREFUSEtjGNZABIilIEw4cIXSVAHiQFwMxLJgHgTUQ2mqAZDhIEskwTyoBdGyDFOi5Rj+Y8NgVSQCkOGiECaDZZQ0g0GyJuvXrx/K////Vw/H587KbiPXAhRQYCXw7OBKPxTDL55XPrB/L5E+IOR9EP32leLB92+UD4Dw9WtSW0CGE2UB2PuqDF+/7BX+/++4KByfL2eHex9Ev3yOwBfPMYBdT5QF+cZMzw6086IYfqmG48DBOFYUH2CzYOdmIiwAKfjdyHvwXzP/ARC+V861BWQ4PgvOn2Y4OKuJ4X+8KsOXKFmGyWCDcAGQ5n/ZfHB8KwnienQL0HGaAcNDUPCCDcEHQIqxWbA7igVuAR5gAcSgfALCbiABDIBuwc0E9oOz3Zj/xytAvE9xBsOmMU0F4n0Qjlfl+HL04P7/Z86cgeNp06atAqkDasdWdhEPMozEnyzsqkMxfObMmdvq6+thPsBWdmEAHSCGhSOIDQcgQ3Zs23Zw586dB0B47ty5W0CGI1kAAuhlF/EAZMimTZvgePLkyQewWAACIMNBwYUXgMJSDMJk0AURuCyorSxHt4AggHlTAsyDFdHoFkyceLAo2v9/rBLrV4IZDAngrGRAFqDjeC2Bp0RlMCQgDMToEaQNpUckYGAAACxOjpxHF/rmAAAAAElFTkSuQmCCCw==</value></data></root>

===== Properties\AssemblyInfo.cs =====
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyTitle("IntraLattice")]
[assembly: AssemblyDescription("Set of components for generating lattice structures within a design space.")]
[assembly: AssemblyProduct("IntraLattice")]
[assembly: AssemblyCopyright("Copyright © ADML 2015")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("a9172bef-6e73-4cad-b18b-4072973fa4f6")]
[assembly: AssemblyFileVersion("0.7.5")]
[assembly: AssemblyVersion("0.7.5.0")]


===== structure.txt =====
===== IntraLattice\IntraLatticeInfo.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;

namespace IntraLattice;

public class IntraLatticeInfo : GH_AssemblyInfo
{
	public override string Name => "IntraLattice";

	public override Bitmap Icon => null;

	public override string Description => "";

	public override Guid Id => new Guid("df475ca3-9a35-471e-9348-f2b7c04e9189");

	public override string AuthorName => "Aidan Kurtz";

	public override string AuthorContact => "aidan.kurtz@mail.mcgill.ca";
}


===== IntraLattice.CORE.Components\BasicBoxComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class BasicBoxComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.basicBox;

	public override Guid ComponentGuid => new Guid("{3d9572a6-0783-4885-9b11-df464cf549a7}");

	public BasicBoxComponent()
		: base("Basic Box", "BasicBox", "Generates a lattice box.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddNumberParameter("Cell Size ( x )", "CSx", "Size of unit cell (x)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( y )", "CSy", "Size of unit cell (y)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( z )", "CSz", "Size of unit cell (z)", (GH_ParamAccess)0, 5.0);
		pManager.AddIntegerParameter("Number of Cells ( x )", "Nx", "Number of unit cells (x)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number of Cells ( y )", "Ny", "Number of unit cells (y)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number of Cells ( z )", "Nz", "Number of unit cells (z)", (GH_ParamAccess)0, 5);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Expected O, but got Unknown
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		int num4 = 0;
		int num5 = 0;
		int num6 = 0;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<double>(1, ref num) || !DA.GetData<double>(2, ref num2) || !DA.GetData<double>(3, ref num3) || !DA.GetData<int>(4, ref num4) || !DA.GetData<int>(5, ref num5) || !DA.GetData<int>(6, ref num6) || !unitCell.isValid || num == 0.0 || num2 == 0.0 || num3 == 0.0 || num4 == 0 || num5 == 0 || num6 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Plane worldXY = Plane.WorldXY;
		Vector3d val = num * ((Plane)(ref worldXY)).XAxis;
		Vector3d val2 = num2 * ((Plane)(ref worldXY)).YAxis;
		Vector3d val3 = num3 * ((Plane)(ref worldXY)).ZAxis;
		float[] array = new float[3] { num4, num5, num6 };
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val4 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val4);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val5 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val5)).X;
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val6)).Y;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val7)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag2 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag || flag2)
						{
							list.Add(null);
							continue;
						}
						Vector3d val8 = array2[0] * val + array2[1] * val2 + array2[2] * val3;
						LatticeNode item = new LatticeNode(((Plane)(ref worldXY)).Origin + val8);
						list.Add(item);
					}
				}
			}
		}
		lattice.ConformMapping(unitCell, array);
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\BasicCylinderComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class BasicCylinderComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.basicCylinder;

	public override Guid ComponentGuid => new Guid("{9f6769c0-dec5-4a0d-8ade-76fca1dfd4e3}");

	public BasicCylinderComponent()
		: base("Basic Cylinder", "BasicCylinder", "Generates a conformal lattice cylinder.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddNumberParameter("Radius", "R", "Radius of cylinder", (GH_ParamAccess)0, 15.0);
		pManager.AddNumberParameter("Height", "H", "Height of cylinder", (GH_ParamAccess)0, 25.0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (axial)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (theta)", (GH_ParamAccess)0, 15);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (radial)", (GH_ParamAccess)0, 4);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Expected O, but got Unknown
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Expected O, but got Unknown
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Expected O, but got Unknown
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031d: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		double num = 0.0;
		double num2 = 0.0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<double>(1, ref num) || !DA.GetData<double>(2, ref num2) || !DA.GetData<int>(3, ref num3) || !DA.GetData<int>(4, ref num4) || !DA.GetData<int>(5, ref num5) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || num == 0.0 || num2 == 0.0 || num3 == 0 || num4 == 0 || num5 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val = new DataTree<GeometryBase>();
		Plane worldXY = Plane.WorldXY;
		Cylinder val2 = new Cylinder(new Circle(worldXY, num), num2);
		Surface val3 = (Surface)(object)((Cylinder)(ref val2)).ToNurbsSurface();
		val3 = val3.Transpose();
		LineCurve val4 = new LineCurve(((Plane)(ref worldXY)).Origin, ((Plane)(ref worldXY)).Origin + num2 * ((Plane)(ref worldXY)).ZAxis);
		float[] array = new float[3] { num3, num4, num5 };
		Interval val5 = default(Interval);
		((Interval)(ref val5))._002Ector(0.0, 1.0);
		val3.SetDomain(0, val5);
		val3.SetDomain(1, val5);
		((Curve)val4).Domain = val5;
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Point3d val12 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Interval val15 = default(Interval);
		Interval val16 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val6 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val6);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val7)).X;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val8)).Y;
						Point3d val9 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val9)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list.Add(null);
							continue;
						}
						Vector3d val10 = num2 * ((Plane)(ref worldXY)).ZAxis * array2[0] / (double)array[0];
						Point3d val11 = ((Plane)(ref worldXY)).Origin + val10;
						val3.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val12, ref array3);
						Vector3d val13 = val12 - val11;
						LatticeNode item = new LatticeNode(val11 + val13 * array2[2] / (double)array[2]);
						list.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val14 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val15))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val16))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val17 = val3.Trim(val15, val16);
					Curve val18 = ((Curve)val4).Trim(val15);
					val17.SetDomain(0, val5);
					val17.SetDomain(1, val5);
					val18.Domain = val5;
					val.Add((GeometryBase)(object)val17, val14);
					val.Add((GeometryBase)(object)val18, val14);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\ConformSAComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class ConformSAComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.conformSA;

	public override Guid ComponentGuid => new Guid("{e0e8a858-66bd-4145-b173-23dc2e247206}");

	public ConformSAComponent()
		: base("Conform Surface-Axis", "ConformSA", "Generates a conforming lattice between a surface and an axis.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface", "Surf", "Surface to conform to", (GH_ParamAccess)0);
		pManager.AddCurveParameter("Axis", "A", "Axis (may be curved)", (GH_ParamAccess)0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (u)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (v)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (w)", (GH_ParamAccess)0, 5);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Expected O, but got Unknown
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Expected O, but got Unknown
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		Surface val = null;
		Curve val2 = null;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<Surface>(1, ref val) || !DA.GetData<Curve>(2, ref val2) || !DA.GetData<int>(3, ref num) || !DA.GetData<int>(4, ref num2) || !DA.GetData<int>(5, ref num3) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || !((CommonObject)val).IsValid || !((CommonObject)val2).IsValid || num == 0 || num2 == 0 || num3 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val3 = new DataTree<GeometryBase>();
		float[] array = new float[3] { num, num2, num3 };
		Interval val4 = default(Interval);
		((Interval)(ref val4))._002Ector(0.0, 1.0);
		val.SetDomain(0, val4);
		val.SetDomain(1, val4);
		val2.Domain = val4;
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		List<double> list = new List<double>(val2.DivideByCount((int)array[0], true));
		_ = list[1];
		_ = list[0];
		if (val2.IsClosed)
		{
			list.Add(0.0);
		}
		Point3d val10 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Interval val13 = default(Interval);
		Interval val14 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val5 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list2 = lattice.Nodes.EnsurePath(val5);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val6)).X;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val7)).Y;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val8)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list2.Add(null);
							continue;
						}
						Point3d val9 = val2.PointAt(list[i] + x / (double)array[0]);
						val.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val10, ref array3);
						Vector3d val11 = val10 - val9;
						LatticeNode item = new LatticeNode(val9 + val11 * array2[2] / (double)array[2]);
						list2.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val12 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val13))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val14))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val15 = val.Trim(val13, val14);
					Curve val16 = val2.Trim(val13);
					val15.SetDomain(0, val4);
					val15.SetDomain(1, val4);
					val16.Domain = val4;
					val3.Add((GeometryBase)(object)val15, val12);
					val3.Add((GeometryBase)(object)val16, val12);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val3, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\ConformSPComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class ConformSPComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.conformSP;

	public override Guid ComponentGuid => new Guid("{27cbc46a-3ef6-4f00-9a66-d6afd6b7b2fe}");

	public ConformSPComponent()
		: base("Conform Surface-Point", "ConformSP", "Generates a conforming lattice between a surface and a point.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface", "Surf", "Surface to conform to", (GH_ParamAccess)0);
		pManager.AddPointParameter("Point", "Pt", "Point", (GH_ParamAccess)0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (u)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (v)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (w)", (GH_ParamAccess)0, 5);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Expected O, but got Unknown
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Expected O, but got Unknown
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_034f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		Surface val = null;
		Point3d unset = Point3d.Unset;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<Surface>(1, ref val) || !DA.GetData<Point3d>(2, ref unset) || !DA.GetData<int>(3, ref num) || !DA.GetData<int>(4, ref num2) || !DA.GetData<int>(5, ref num3) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || !((CommonObject)val).IsValid || !((Point3d)(ref unset)).IsValid || num == 0 || num2 == 0 || num3 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val2 = new DataTree<GeometryBase>();
		float[] array = new float[3] { num, num2, num3 };
		Interval val3 = default(Interval);
		((Interval)(ref val3))._002Ector(0.0, 1.0);
		val.SetDomain(0, val3);
		val.SetDomain(1, val3);
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Point3d val9 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Interval val12 = default(Interval);
		Interval val13 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val4 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val4);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val5 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val5)).X;
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val6)).Y;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val7)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list.Add(null);
							continue;
						}
						Point3d val8 = unset;
						val.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val9, ref array3);
						Vector3d val10 = val9 - val8;
						LatticeNode item = new LatticeNode(val8 + val10 * array2[2] / (double)array[2]);
						list.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val11 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val12))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val13))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val14 = val.Trim(val12, val13);
					Point val15 = new Point(unset);
					val14.SetDomain(0, val3);
					val14.SetDomain(1, val3);
					val2.Add((GeometryBase)(object)val14, val11);
					val2.Add((GeometryBase)(object)val15, val11);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val2, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\ConformSSComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class ConformSSComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.conformSS;

	public override Guid ComponentGuid => new Guid("{ac0814b4-00e7-4efb-add5-e845a831c6da}");

	public ConformSSComponent()
		: base("Conform Surface-Surface", "ConformSS", "Generates a conforming lattice between two surfaces.", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface 1", "S1", "First bounding surface", (GH_ParamAccess)0);
		pManager.AddSurfaceParameter("Surface 2", "S2", "Second bounding surface", (GH_ParamAccess)0);
		pManager.AddIntegerParameter("Number u", "Nu", "Number of unit cells (u)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number v", "Nv", "Number of unit cells (v)", (GH_ParamAccess)0, 5);
		pManager.AddIntegerParameter("Number w", "Nw", "Number of unit cells (w)", (GH_ParamAccess)0, 5);
		pManager.AddBooleanParameter("Morph", "Morph", "If true, struts are morphed to the space as curves.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Expected O, but got Unknown
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Expected O, but got Unknown
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		Surface val = null;
		Surface val2 = null;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<Surface>(1, ref val) || !DA.GetData<Surface>(2, ref val2) || !DA.GetData<int>(3, ref num) || !DA.GetData<int>(4, ref num2) || !DA.GetData<int>(5, ref num3) || !DA.GetData<bool>(6, ref flag) || !unitCell.isValid || !((CommonObject)val).IsValid || !((CommonObject)val2).IsValid || num == 0 || num2 == 0 || num3 == 0)
		{
			return;
		}
		Lattice lattice = new Lattice();
		DataTree<GeometryBase> val3 = new DataTree<GeometryBase>();
		float[] array = new float[3] { num, num2, num3 };
		Interval val4 = default(Interval);
		((Interval)(ref val4))._002Ector(0.0, 1.0);
		val.SetDomain(0, val4);
		val.SetDomain(1, val4);
		val2.SetDomain(0, val4);
		val2.SetDomain(1, val4);
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Point3d val9 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Point3d val10 = default(Point3d);
		Vector3d[] array4 = default(Vector3d[]);
		Interval val13 = default(Interval);
		Interval val14 = default(Interval);
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val5 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val5);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val6 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val6)).X;
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val7)).Y;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val8)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag2 = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag3 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag2 || flag3)
						{
							list.Add(null);
							continue;
						}
						val.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val9, ref array3);
						val2.Evaluate(array2[0] / (double)array[0], array2[1] / (double)array[1], 2, ref val10, ref array4);
						Vector3d val11 = val10 - val9;
						LatticeNode item = new LatticeNode(val9 + val11 * array2[2] / (double)array[2]);
						list.Add(item);
					}
				}
				if (flag && (float)i < array[0] && (float)j < array[1])
				{
					GH_Path val12 = new GH_Path(new int[2] { i, j });
					((Interval)(ref val13))._002Ector((double)((float)i / array[0]), (double)((float)(i + 1) / array[0]));
					((Interval)(ref val14))._002Ector((double)((float)j / array[1]), (double)((float)(j + 1) / array[1]));
					Surface val15 = val.Trim(val13, val14);
					Surface val16 = val2.Trim(val13, val14);
					val15.SetDomain(0, val4);
					val15.SetDomain(1, val4);
					val16.SetDomain(0, val4);
					val16.SetDomain(1, val4);
					val3.Add((GeometryBase)(object)val15, val12);
					val3.Add((GeometryBase)(object)val16, val12);
				}
			}
		}
		if (flag)
		{
			lattice.MorphMapping(unitCell, val3, array);
		}
		else
		{
			lattice.ConformMapping(unitCell, array);
		}
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components\CustomCellComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.CORE.Data.GH_Goo;
using IntraLattice.Properties;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class CustomCellComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.customCell;

	public override Guid ComponentGuid => new Guid("{93998286-27d4-40a3-8f0e-043de932b931}");

	public CustomCellComponent()
		: base("Custom Cell", "CustomCell", "Pre-processes a custom unit cell by check validity and outputting topology.", "IntraLattice", "Cell")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Custom Cell", "L", "Unit cell lines (curves must be linear).", (GH_ParamAccess)1);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Verified unit cell topology", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		List<Curve> list = new List<Curve>();
		if (!DA.GetDataList<Curve>(0, list))
		{
			return;
		}
		List<Line> list2 = new List<Line>();
		foreach (Curve item in list)
		{
			if (!item.IsLinear())
			{
				((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "All struts must be linear.");
				return;
			}
			list2.Add(new Line(item.PointAtStart, item.PointAtEnd));
		}
		UnitCell unitCell = new UnitCell(list2);
		switch (unitCell.CheckValidity())
		{
		case -1:
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Invalid cell - opposing faces must be identical.");
			return;
		case 0:
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Invalid cell - each face needs at least one node lying on it.");
			return;
		case 1:
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)0, "Your cell is valid!");
			break;
		}
		DA.SetData(0, (object)new UnitCellGoo(unitCell));
	}
}


===== IntraLattice.CORE.Components\PresetCellComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.CORE.Data.GH_Goo;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components;

public class PresetCellComponent : GH_Component
{
	private GH_Document GrasshopperDocument;

	private IGH_Component Component;

	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.presetCell;

	public override Guid ComponentGuid => new Guid("{508cc705-bc5b-42a9-8100-c1e364f3b83d}");

	public PresetCellComponent()
		: base("Preset Cell", "PresetCell", "Built-in selection of unit cell topologies.", "IntraLattice", "Cell")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddIntegerParameter("Cell Tye", "Type", "Unit cell topology type", (GH_ParamAccess)0, 0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddLineParameter("Lines", "L", "Optional output so you can modify the unit cell lines. Pass through the CustomCell component when you're done.", (GH_ParamAccess)1);
		pManager.HideParameter(1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Component = (IGH_Component)(object)this;
		GrasshopperDocument = ((GH_DocumentObject)this).OnPingDocument();
		if (Component.Params.Input[0].SourceCount == 0)
		{
			InputTools.TopoSelect(ref Component, ref GrasshopperDocument, 0, 11f);
		}
		int num = 0;
		if (!DA.GetData<int>(0, ref num))
		{
			return;
		}
		List<Line> rawCell = new List<Line>();
		double d = 5.0;
		switch (num)
		{
		case 0:
			rawCell = GridLines(d);
			break;
		case 1:
			rawCell = XLines(d);
			break;
		case 2:
			rawCell = StarLines(d);
			break;
		case 3:
			rawCell = CrossLines(d);
			break;
		case 4:
			rawCell = TesseractLines(d);
			break;
		case 5:
			rawCell = VintileLines(d);
			break;
		case 6:
			rawCell = OctetLines(d);
			break;
		case 7:
			rawCell = DiamondLines(d);
			break;
		case 8:
			rawCell = Honeycomb(d);
			break;
		case 9:
			rawCell = AuxeticHoneycomb(d);
			break;
		}
		UnitCell unitCell = new UnitCell(rawCell);
		if (!unitCell.isValid)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Invalid cell - this is embarassing.");
		}
		List<Line> list = new List<Line>();
		foreach (IndexPair nodePair in unitCell.NodePairs)
		{
			IndexPair current = nodePair;
			list.Add(new Line(((RhinoList<Point3d>)(object)unitCell.Nodes)[((IndexPair)(ref current)).I], ((RhinoList<Point3d>)(object)unitCell.Nodes)[((IndexPair)(ref current)).J]));
		}
		DA.SetData(0, (object)new UnitCellGoo(unitCell));
		DA.SetDataList(1, (IEnumerable)list);
	}

	private List<Line> GridLines(double d)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		int[] array = new int[3] { 1, 3, 4 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[0], nodes[index]));
		}
		int[] array2 = new int[3] { 1, 3, 6 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[2], nodes[index2]));
		}
		int[] array3 = new int[3] { 1, 4, 6 };
		foreach (int index3 in array3)
		{
			list.Add(new Line(nodes[5], nodes[index3]));
		}
		int[] array4 = new int[3] { 3, 4, 6 };
		foreach (int index4 in array4)
		{
			list.Add(new Line(nodes[7], nodes[index4]));
		}
		return list;
	}

	private List<Line> XLines(double d)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		list.Add(new Line(nodes[0], nodes[6]));
		list.Add(new Line(nodes[1], nodes[7]));
		list.Add(new Line(nodes[3], nodes[5]));
		list.Add(new Line(nodes[2], nodes[4]));
		return list;
	}

	private List<Line> StarLines(double d)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		list.Add(new Line(nodes[0], nodes[6]));
		list.Add(new Line(nodes[1], nodes[7]));
		list.Add(new Line(nodes[3], nodes[5]));
		list.Add(new Line(nodes[2], nodes[4]));
		int[] array = new int[3] { 1, 3, 4 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[0], nodes[index]));
		}
		int[] array2 = new int[3] { 1, 3, 6 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[2], nodes[index2]));
		}
		int[] array3 = new int[3] { 1, 4, 6 };
		foreach (int index3 in array3)
		{
			list.Add(new Line(nodes[5], nodes[index3]));
		}
		int[] array4 = new int[3] { 3, 4, 6 };
		foreach (int index4 in array4)
		{
			list.Add(new Line(nodes[7], nodes[index4]));
		}
		return list;
	}

	private List<Line> DiamondLines(double d)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		list2.Add(new Point3d(0.0, 0.0, 0.0));
		list2.Add(new Point3d(0.0, d / 2.0, d / 2.0));
		list2.Add(new Point3d(d / 2.0, 0.0, d / 2.0));
		list2.Add(new Point3d(d / 2.0, d / 2.0, 0.0));
		list2.Add(new Point3d(d / 4.0, d / 4.0, d / 4.0));
		list.Add(new Line(list2[4], list2[0]));
		list.Add(new Line(list2[4], list2[1]));
		list.Add(new Line(list2[4], list2[2]));
		list.Add(new Line(list2[4], list2[3]));
		List<Line> list3 = new List<Line>(list);
		Line item = default(Line);
		foreach (Line item4 in list)
		{
			Line current = item4;
			((Line)(ref item))._002Ector(((Line)(ref current)).From, ((Line)(ref current)).To);
			((Line)(ref item)).Transform(Transform.Translation(d / 2.0, d / 2.0, 0.0));
			list3.Add(item);
		}
		Line item2 = default(Line);
		foreach (Line item5 in list)
		{
			Line current2 = item5;
			((Line)(ref item2))._002Ector(((Line)(ref current2)).From, ((Line)(ref current2)).To);
			((Line)(ref item2)).Transform(Transform.Rotation(Math.PI / 2.0, list2[4]));
			((Line)(ref item2)).Transform(Transform.Translation(d / 2.0, d / 2.0, d / 2.0));
			list3.Add(item2);
		}
		Line item3 = default(Line);
		foreach (Line item6 in list)
		{
			Line current3 = item6;
			((Line)(ref item3))._002Ector(((Line)(ref current3)).From, ((Line)(ref current3)).To);
			((Line)(ref item3)).Transform(Transform.Rotation(Math.PI / 2.0, list2[4]));
			((Line)(ref item3)).Transform(Transform.Translation(0.0, 0.0, d / 2.0));
			list3.Add(item3);
		}
		list.AddRange(list3);
		return list;
	}

	private List<Line> CrossLines(double d)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		int[] array = new int[2] { 5, 7 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[0], nodes[index]));
			list.Add(new Line(nodes[2], nodes[index]));
		}
		int[] array2 = new int[2] { 4, 6 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[1], nodes[index2]));
			list.Add(new Line(nodes[3], nodes[index2]));
		}
		int[] array3 = new int[4] { 0, 1, 4, 5 };
		foreach (int num in array3)
		{
			list.Add(new Line(nodes[num], nodes[num + 2]));
		}
		return list;
	}

	private List<Line> TesseractLines(double d)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		nodes.Add(new Point3d(d / 4.0, d / 4.0, d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, d / 4.0, d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, 3.0 * d / 4.0, d / 4.0));
		nodes.Add(new Point3d(d / 4.0, 3.0 * d / 4.0, d / 4.0));
		nodes.Add(new Point3d(d / 4.0, d / 4.0, 3.0 * d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, d / 4.0, 3.0 * d / 4.0));
		nodes.Add(new Point3d(3.0 * d / 4.0, 3.0 * d / 4.0, 3.0 * d / 4.0));
		nodes.Add(new Point3d(d / 4.0, 3.0 * d / 4.0, 3.0 * d / 4.0));
		int[] array = new int[3] { 1, 3, 4 };
		foreach (int num in array)
		{
			list.Add(new Line(nodes[0], nodes[num]));
			list.Add(new Line(nodes[8], nodes[num + 8]));
		}
		int[] array2 = new int[3] { 1, 3, 6 };
		foreach (int num2 in array2)
		{
			list.Add(new Line(nodes[2], nodes[num2]));
			list.Add(new Line(nodes[10], nodes[num2 + 8]));
		}
		int[] array3 = new int[3] { 1, 4, 6 };
		foreach (int num3 in array3)
		{
			list.Add(new Line(nodes[5], nodes[num3]));
			list.Add(new Line(nodes[13], nodes[num3 + 8]));
		}
		int[] array4 = new int[3] { 3, 4, 6 };
		foreach (int num4 in array4)
		{
			list.Add(new Line(nodes[7], nodes[num4]));
			list.Add(new Line(nodes[15], nodes[num4 + 8]));
		}
		for (int m = 0; m < 8; m++)
		{
			list.Add(new Line(nodes[m], nodes[m + 8]));
		}
		return list;
	}

	private List<Line> VintileLines(double d)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_0439: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0479: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_0486: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0516: Unknown result type (might be due to invalid IL or missing references)
		//IL_0551: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0560: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0604: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		double[] array = new double[2] { 0.0, d };
		foreach (double num in array)
		{
			list2.Add(new Point3d(0.0, d / 4.0, num));
			list2.Add(new Point3d(0.0, 3.0 * d / 4.0, num));
			list2.Add(new Point3d(d / 4.0, d, num));
			list2.Add(new Point3d(3.0 * d / 4.0, d, num));
			list2.Add(new Point3d(d, 3.0 * d / 4.0, num));
			list2.Add(new Point3d(d, d / 4.0, num));
			list2.Add(new Point3d(3.0 * d / 4.0, 0.0, num));
			list2.Add(new Point3d(d / 4.0, 0.0, num));
		}
		double[] array2 = new double[2]
		{
			d / 4.0,
			3.0 * d / 4.0
		};
		foreach (double num2 in array2)
		{
			list2.Add(new Point3d(0.0, d / 2.0, num2));
			list2.Add(new Point3d(d / 2.0, d, num2));
			list2.Add(new Point3d(d, d / 2.0, num2));
			list2.Add(new Point3d(d / 2.0, 0.0, num2));
		}
		double[] array3 = new double[2]
		{
			d / 4.0,
			3.0 * d / 4.0
		};
		foreach (double num3 in array3)
		{
			list2.Add(new Point3d(d / 2.0, num3, d / 2.0));
		}
		double[] array4 = new double[2]
		{
			d / 4.0,
			3.0 * d / 4.0
		};
		foreach (double num4 in array4)
		{
			list2.Add(new Point3d(num4, d / 2.0, d / 2.0));
		}
		int[] array5 = new int[3] { 0, 1, 26 };
		foreach (int index in array5)
		{
			list.Add(new Line(list2[16], list2[index]));
		}
		int[] array6 = new int[3] { 2, 3, 25 };
		foreach (int index2 in array6)
		{
			list.Add(new Line(list2[17], list2[index2]));
		}
		int[] array7 = new int[3] { 4, 5, 27 };
		foreach (int index3 in array7)
		{
			list.Add(new Line(list2[18], list2[index3]));
		}
		int[] array8 = new int[3] { 6, 7, 24 };
		foreach (int index4 in array8)
		{
			list.Add(new Line(list2[19], list2[index4]));
		}
		int[] array9 = new int[3] { 8, 9, 26 };
		foreach (int index5 in array9)
		{
			list.Add(new Line(list2[20], list2[index5]));
		}
		int[] array10 = new int[3] { 10, 11, 25 };
		foreach (int index6 in array10)
		{
			list.Add(new Line(list2[21], list2[index6]));
		}
		int[] array11 = new int[3] { 12, 13, 27 };
		foreach (int index7 in array11)
		{
			list.Add(new Line(list2[22], list2[index7]));
		}
		int[] array12 = new int[3] { 14, 15, 24 };
		foreach (int index8 in array12)
		{
			list.Add(new Line(list2[23], list2[index8]));
		}
		int[] array13 = new int[6] { 1, 3, 5, 9, 11, 13 };
		foreach (int num12 in array13)
		{
			list.Add(new Line(list2[num12], list2[num12 + 1]));
		}
		int[] array14 = new int[2] { 24, 25 };
		foreach (int index9 in array14)
		{
			list.Add(new Line(list2[26], list2[index9]));
			list.Add(new Line(list2[27], list2[index9]));
		}
		list.Add(new Line(list2[0], list2[7]));
		list.Add(new Line(list2[8], list2[15]));
		return list;
	}

	private List<Line> OctetLines(double d)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> nodes = new List<Point3d>();
		CellTools.MakeCornerNodes(ref nodes, d);
		nodes.Add(new Point3d(d, d / 2.0, d / 2.0));
		nodes.Add(new Point3d(d / 2.0, d, d / 2.0));
		nodes.Add(new Point3d(0.0, d / 2.0, d / 2.0));
		nodes.Add(new Point3d(d / 2.0, 0.0, d / 2.0));
		nodes.Add(new Point3d(d / 2.0, d / 2.0, 0.0));
		nodes.Add(new Point3d(d / 2.0, d / 2.0, d));
		int[] array = new int[8] { 0, 1, 2, 3, 8, 9, 10, 11 };
		foreach (int index in array)
		{
			list.Add(new Line(nodes[12], nodes[index]));
		}
		int[] array2 = new int[8] { 4, 5, 6, 7, 8, 9, 10, 11 };
		foreach (int index2 in array2)
		{
			list.Add(new Line(nodes[13], nodes[index2]));
		}
		int[] array3 = new int[4] { 0, 3, 4, 7 };
		foreach (int index3 in array3)
		{
			list.Add(new Line(nodes[10], nodes[index3]));
		}
		int[] array4 = new int[6] { 2, 3, 6, 7, 8, 10 };
		foreach (int index4 in array4)
		{
			list.Add(new Line(nodes[9], nodes[index4]));
		}
		int[] array5 = new int[4] { 1, 2, 5, 6 };
		foreach (int index5 in array5)
		{
			list.Add(new Line(nodes[8], nodes[index5]));
		}
		int[] array6 = new int[6] { 0, 1, 4, 5, 8, 10 };
		foreach (int index6 in array6)
		{
			list.Add(new Line(nodes[11], nodes[index6]));
		}
		return list;
	}

	private List<Line> Honeycomb(double d)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		for (int i = 0; i < 2; i++)
		{
			double num = 3.0 * d * (double)i;
			list2.Add(new Point3d(2.25 * d, num, 2.0 * d));
			list2.Add(new Point3d(2.25 * d, num, d));
			list2.Add(new Point3d(0.75 * d, num, 2.0 * d));
			list2.Add(new Point3d(0.75 * d, num, d));
			list2.Add(new Point3d(0.0, num, 0.0));
			list2.Add(new Point3d(0.0, num, 0.5 * d));
			list2.Add(new Point3d(0.0, num, 2.5 * d));
			list2.Add(new Point3d(0.0, num, 3.0 * d));
			list2.Add(new Point3d(1.5 * d, num, 0.0));
			list2.Add(new Point3d(1.5 * d, num, 0.5 * d));
			list2.Add(new Point3d(1.5 * d, num, 2.5 * d));
			list2.Add(new Point3d(1.5 * d, num, 3.0 * d));
			list2.Add(new Point3d(3.0 * d, num, 0.0));
			list2.Add(new Point3d(3.0 * d, num, 0.5 * d));
			list2.Add(new Point3d(3.0 * d, num, 2.5 * d));
			list2.Add(new Point3d(3.0 * d, num, 3.0 * d));
		}
		for (int j = 0; j < 2; j++)
		{
			int num2 = j * 16;
			int[] array = new int[3] { 2, 5, 9 };
			foreach (int num3 in array)
			{
				list.Add(new Line(list2[3 + num2], list2[num3 + num2]));
			}
			int[] array2 = new int[3] { 0, 9, 13 };
			foreach (int num4 in array2)
			{
				list.Add(new Line(list2[1 + num2], list2[num4 + num2]));
			}
			int[] array3 = new int[3] { 0, 2, 11 };
			foreach (int num5 in array3)
			{
				list.Add(new Line(list2[10 + num2], list2[num5 + num2]));
			}
			list.Add(new Line(list2[6 + num2], list2[7 + num2]));
			list.Add(new Line(list2[14 + num2], list2[15 + num2]));
			list.Add(new Line(list2[4 + num2], list2[5 + num2]));
			list.Add(new Line(list2[8 + num2], list2[9 + num2]));
			list.Add(new Line(list2[13 + num2], list2[12 + num2]));
			list.Add(new Line(list2[num2], list2[14 + num2]));
			list.Add(new Line(list2[2 + num2], list2[6 + num2]));
		}
		for (int n = 0; n < 16; n++)
		{
			list.Add(new Line(list2[n], list2[n + 16]));
		}
		return list;
	}

	private List<Line> AuxeticHoneycomb(double d)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		List<Line> list = new List<Line>();
		List<Point3d> list2 = new List<Point3d>();
		for (int i = 0; i < 2; i++)
		{
			double num = 3.0 * d * (double)i;
			list2.Add(new Point3d(2.25 * d, num, 2.5 * d));
			list2.Add(new Point3d(2.25 * d, num, 0.5 * d));
			list2.Add(new Point3d(0.75 * d, num, 2.5 * d));
			list2.Add(new Point3d(0.75 * d, num, 0.5 * d));
			list2.Add(new Point3d(0.0, num, 0.0));
			list2.Add(new Point3d(0.0, num, d));
			list2.Add(new Point3d(0.0, num, 2.0 * d));
			list2.Add(new Point3d(0.0, num, 3.0 * d));
			list2.Add(new Point3d(1.5 * d, num, 0.0));
			list2.Add(new Point3d(1.5 * d, num, d));
			list2.Add(new Point3d(1.5 * d, num, 2.0 * d));
			list2.Add(new Point3d(1.5 * d, num, 3.0 * d));
			list2.Add(new Point3d(3.0 * d, num, 0.0));
			list2.Add(new Point3d(3.0 * d, num, d));
			list2.Add(new Point3d(3.0 * d, num, 2.0 * d));
			list2.Add(new Point3d(3.0 * d, num, 3.0 * d));
		}
		for (int j = 0; j < 2; j++)
		{
			int num2 = j * 16;
			int[] array = new int[3] { 2, 5, 9 };
			foreach (int num3 in array)
			{
				list.Add(new Line(list2[3 + num2], list2[num3 + num2]));
			}
			int[] array2 = new int[3] { 0, 9, 13 };
			foreach (int num4 in array2)
			{
				list.Add(new Line(list2[1 + num2], list2[num4 + num2]));
			}
			int[] array3 = new int[3] { 0, 2, 11 };
			foreach (int num5 in array3)
			{
				list.Add(new Line(list2[10 + num2], list2[num5 + num2]));
			}
			list.Add(new Line(list2[6 + num2], list2[7 + num2]));
			list.Add(new Line(list2[14 + num2], list2[15 + num2]));
			list.Add(new Line(list2[4 + num2], list2[5 + num2]));
			list.Add(new Line(list2[8 + num2], list2[9 + num2]));
			list.Add(new Line(list2[13 + num2], list2[12 + num2]));
			list.Add(new Line(list2[num2], list2[14 + num2]));
			list.Add(new Line(list2[2 + num2], list2[6 + num2]));
		}
		for (int n = 0; n < 16; n++)
		{
			list.Add(new Line(list2[n], list2[n + 16]));
		}
		return list;
	}
}


===== IntraLattice.CORE.Components\UniformDSComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using IntraLattice.CORE.Data;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Components;

public class UniformDSComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)8;

	protected override Bitmap Icon => Resources.uniformDS;

	public override Guid ComponentGuid => new Guid("{d242b0c6-83a1-4795-8f8c-a32b1ac85fb3}");

	public UniformDSComponent()
		: base("Uniform DS", "UniformDS", "Generates a uniform lattice within by a design space", "IntraLattice", "Frame")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		pManager.AddGenericParameter("Topology", "Topo", "Unit cell topology", (GH_ParamAccess)0);
		pManager.AddGeometryParameter("Design Space", "DS", "Design Space (Brep or Mesh)", (GH_ParamAccess)0);
		pManager.AddPlaneParameter("Orientation Plane", "Plane", "Lattice orientation plane", (GH_ParamAccess)0, Plane.WorldXY);
		pManager.AddNumberParameter("Cell Size ( x )", "CSx", "Size of unit cell (x)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( y )", "CSy", "Size of unit cell (y)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Cell Size ( z )", "CSz", "Size of unit cell (z)", (GH_ParamAccess)0, 5.0);
		pManager.AddNumberParameter("Tolerance", "Tol", "Smallest allowed strut length", (GH_ParamAccess)0, 0.2);
		pManager.AddBooleanParameter("Strict tolerance", "Strict", "Specifies if we use a strict tolerance.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut curve network", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Expected O, but got Unknown
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		GeometryBase designSpace = null;
		Plane unset = Plane.Unset;
		double num = 0.0;
		double num2 = 0.0;
		double num3 = 0.0;
		double num4 = 0.0;
		bool strictlyIn = false;
		if (!DA.GetData<UnitCell>(0, ref unitCell) || !DA.GetData<GeometryBase>(1, ref designSpace) || !DA.GetData<Plane>(2, ref unset) || !DA.GetData<double>(3, ref num) || !DA.GetData<double>(4, ref num2) || !DA.GetData<double>(5, ref num3) || !DA.GetData<double>(6, ref num4) || !DA.GetData<bool>(7, ref strictlyIn) || !unitCell.isValid || !((CommonObject)designSpace).IsValid || !((Plane)(ref unset)).IsValid || num == 0.0 || num2 == 0.0 || num3 == 0.0)
		{
			return;
		}
		if (num4 >= num || num4 >= num2 || num4 >= num3)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Tolerance parameter cannot be larger than the unit cell dimensions.");
			return;
		}
		int num5 = FrameTools.ValidateSpace(ref designSpace);
		if (num5 == 0)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Design space must be a closed Brep, Mesh or Surface");
			return;
		}
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Box val = default(Box);
		designSpace.GetBoundingBox(unset, ref val);
		Point3d[] corners = ((Box)(ref val)).GetCorners();
		Plane val2 = default(Plane);
		((Plane)(ref val2))._002Ector(corners[0], corners[1], corners[3]);
		double num6 = ((Point3d)(ref corners[0])).DistanceTo(corners[1]);
		double num7 = ((Point3d)(ref corners[0])).DistanceTo(corners[3]);
		double num8 = ((Point3d)(ref corners[0])).DistanceTo(corners[4]);
		int num9 = (int)Math.Ceiling(num6 / num);
		int num10 = (int)Math.Ceiling(num7 / num2);
		int num11 = (int)Math.Ceiling(num8 / num3);
		float[] array = new float[3] { num9, num10, num11 };
		Lattice lattice = new Lattice();
		unitCell = unitCell.Duplicate();
		unitCell.FormatTopology();
		Vector3d val3 = num * ((Plane)(ref val2)).XAxis;
		Vector3d val4 = num2 * ((Plane)(ref val2)).YAxis;
		Vector3d val5 = num3 * ((Plane)(ref val2)).ZAxis;
		for (int i = 0; (float)i <= array[0]; i++)
		{
			for (int j = 0; (float)j <= array[1]; j++)
			{
				for (int k = 0; (float)k <= array[2]; k++)
				{
					GH_Path val6 = new GH_Path(new int[3] { i, j, k });
					List<LatticeNode> list = lattice.Nodes.EnsurePath(val6);
					for (int l = 0; l < ((RhinoList<Point3d>)(object)unitCell.Nodes).Count; l++)
					{
						Point3d val7 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double x = ((Point3d)(ref val7)).X;
						Point3d val8 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double y = ((Point3d)(ref val8)).Y;
						Point3d val9 = ((RhinoList<Point3d>)(object)unitCell.Nodes)[l];
						double z = ((Point3d)(ref val9)).Z;
						double[] array2 = new double[3]
						{
							(double)i + x,
							(double)j + y,
							(double)k + z
						};
						bool flag = unitCell.NodePaths[l][0] > 0 || unitCell.NodePaths[l][1] > 0 || unitCell.NodePaths[l][2] > 0;
						bool flag2 = array2[0] > (double)array[0] || array2[1] > (double)array[1] || array2[2] > (double)array[2];
						if (flag || flag2)
						{
							list.Add(null);
							continue;
						}
						Vector3d val10 = array2[0] * val3 + array2[1] * val4 + array2[2] * val5;
						LatticeNode latticeNode = new LatticeNode(((Plane)(ref val2)).Origin + val10);
						if (FrameTools.IsPointInside(designSpace, latticeNode.Point3d, num5, modelAbsoluteTolerance, strictlyIn))
						{
							latticeNode.State = LatticeNodeState.Inside;
						}
						else
						{
							latticeNode.State = LatticeNodeState.Outside;
						}
						list.Add(latticeNode);
					}
				}
			}
		}
		lattice.UniformMapping(unitCell, designSpace, num5, array, num4);
		DA.SetDataList(0, (IEnumerable)lattice.Struts);
	}
}


===== IntraLattice.CORE.Components.Utility\AdjustUVComponent.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.Properties;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components.Utility;

public class AdjustUVComponent : GH_Component
{
	protected override Bitmap Icon => Resources.adjustUV;

	public override Guid ComponentGuid => new Guid("{3372eac1-1545-4fca-9a25-72c4563aaa1f}");

	public AdjustUVComponent()
		: base("Adjust UV", "AdjustUV", "Adjusts the UV-map of a surface for proper alignment with other surfaces/axes.", "Intralattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddSurfaceParameter("Surface", "Surf", "Surface to adjust.", (GH_ParamAccess)0);
		pManager.AddBooleanParameter("Swap UV", "SwapUV", "Swap the uv parameters.", (GH_ParamAccess)0, false);
		pManager.AddBooleanParameter("Reverse U", "ReverseU", "Reverse the u-parameter direction.", (GH_ParamAccess)0, false);
		pManager.AddBooleanParameter("Reverse V", "ReverseV", "Reverse the v-parameter direction.", (GH_ParamAccess)0, false);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddSurfaceParameter("Adjusted surface", "Surf", "Surface with adjusted uv-map.", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		Surface val = null;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		if (DA.GetData<Surface>(0, ref val) && DA.GetData<bool>(1, ref flag) && DA.GetData<bool>(2, ref flag2) && DA.GetData<bool>(3, ref flag3) && val != null)
		{
			if (flag)
			{
				val = val.Transpose();
			}
			if (flag2)
			{
				val.Reverse(0, true);
			}
			if (flag3)
			{
				val.Reverse(1, true);
			}
			DA.SetData(0, (object)val);
		}
	}
}


===== IntraLattice.CORE.Components.Utility\CleanNetworkComponent.cs =====
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Components.Utility;

public class CleanNetworkComponent : GH_Component
{
	protected override Bitmap Icon => Resources.cleanNetwork;

	public override Guid ComponentGuid => new Guid("{8b3a2f8c-3a76-4b19-84b9-f3eea80010ea}");

	public CleanNetworkComponent()
		: base("Clean Network", "CleanNetwork", "Removes duplicate curves from a network, within specified tolerance.", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Strut network to clean.", (GH_ParamAccess)1);
		pManager.AddNumberParameter("Tolerance", "Tol", "Tolerance for combining nodes.", (GH_ParamAccess)0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Cleaned curve network.", (GH_ParamAccess)1);
		pManager.AddPointParameter("Nodes", "Nodes", "List of unique nodes.", (GH_ParamAccess)1);
		pManager.AddIntegerParameter("CurveStart", "I", "Index in 'Nodes' for the start of each curve in 'Struts'.", (GH_ParamAccess)1);
		pManager.AddIntegerParameter("CurveEnd", "J", "Index in 'Nodes' for the end of each curve in 'Struts'.", (GH_ParamAccess)1);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		List<Curve> list = new List<Curve>();
		double num = 0.0;
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetData<double>(1, ref num) || list == null || list.Count == 1 || num < 0.0)
		{
			return;
		}
		Point3dList nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		list = FrameTools.CleanNetwork(list, num, out nodes, out nodePairs);
		List<int> list2 = new List<int>();
		List<int> list3 = new List<int>();
		foreach (IndexPair item in nodePairs)
		{
			IndexPair current = item;
			list2.Add(((IndexPair)(ref current)).I);
			list3.Add(((IndexPair)(ref current)).J);
		}
		DA.SetDataList(0, (IEnumerable)list);
		DA.SetDataList(1, (IEnumerable)nodes);
		DA.SetDataList(2, (IEnumerable)list2);
		DA.SetDataList(3, (IEnumerable)list3);
	}
}


===== IntraLattice.CORE.Data\EndoMesh.cs =====
namespace IntraLattice.CORE.Data;

internal class EndoMesh
{
}


===== IntraLattice.CORE.Data\ExoHull.cs =====
using System.Collections.Generic;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

internal class ExoHull
{
	private Point3d m_point3d;

	private List<int> m_sleeveIndices;

	private List<int> m_plateIndices;

	private double m_avgRadius;

	public Point3d Point3d
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_point3d;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_point3d = value;
		}
	}

	public List<int> SleeveIndices
	{
		get
		{
			return m_sleeveIndices;
		}
		set
		{
			m_sleeveIndices = value;
		}
	}

	public List<int> PlateIndices
	{
		get
		{
			return m_plateIndices;
		}
		set
		{
			m_plateIndices = value;
		}
	}

	public double AvgRadius
	{
		get
		{
			return m_avgRadius;
		}
		set
		{
			m_avgRadius = value;
		}
	}

	public ExoHull()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = Point3d.Unset;
		m_sleeveIndices = new List<int>();
		m_plateIndices = new List<int>();
		m_avgRadius = 0.0;
	}

	public ExoHull(Point3d point3d)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = point3d;
		m_sleeveIndices = new List<int>();
		m_plateIndices = new List<int>();
		m_avgRadius = 0.0;
	}
}


===== IntraLattice.CORE.Data\ExoMesh.cs =====
using System;
using System.Collections.Generic;
using IntraLattice.CORE.Helpers;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;

namespace IntraLattice.CORE.Data;

internal class ExoMesh
{
	private List<ExoHull> m_hulls;

	private List<ExoSleeve> m_sleeves;

	private List<ExoPlate> m_plates;

	private Mesh m_mesh;

	public List<ExoHull> Hulls
	{
		get
		{
			return m_hulls;
		}
		set
		{
			m_hulls = value;
		}
	}

	public List<ExoSleeve> Sleeves
	{
		get
		{
			return m_sleeves;
		}
		set
		{
			m_sleeves = value;
		}
	}

	public List<ExoPlate> Plates
	{
		get
		{
			return m_plates;
		}
		set
		{
			m_plates = value;
		}
	}

	public Mesh Mesh
	{
		get
		{
			return m_mesh;
		}
		set
		{
			m_mesh = value;
		}
	}

	public ExoMesh()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Expected O, but got Unknown
		m_hulls = new List<ExoHull>();
		m_sleeves = new List<ExoSleeve>();
		m_plates = new List<ExoPlate>();
		m_mesh = new Mesh();
	}

	public ExoMesh(List<Curve> struts)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Expected O, but got Unknown
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Expected O, but got Unknown
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		m_hulls = new List<ExoHull>();
		m_sleeves = new List<ExoSleeve>();
		m_plates = new List<ExoPlate>();
		m_mesh = new Mesh();
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Point3dList nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		struts = FrameTools.CleanNetwork(struts, modelAbsoluteTolerance, out nodes, out nodePairs);
		foreach (Point3d item in (RhinoList<Point3d>)(object)nodes)
		{
			m_hulls.Add(new ExoHull(item));
		}
		IndexPair platePair = default(IndexPair);
		for (int i = 0; i < struts.Count; i++)
		{
			m_sleeves.Add(new ExoSleeve(struts[i], nodePairs[i]));
			List<ExoPlate> plates = m_plates;
			IndexPair val = nodePairs[i];
			plates.Add(new ExoPlate(((IndexPair)(ref val)).I, struts[i].TangentAtStart));
			List<ExoPlate> plates2 = m_plates;
			IndexPair val2 = nodePairs[i];
			plates2.Add(new ExoPlate(((IndexPair)(ref val2)).J, -struts[i].TangentAtEnd));
			((IndexPair)(ref platePair))._002Ector(m_plates.Count - 2, m_plates.Count - 1);
			m_sleeves[i].PlatePair = platePair;
			List<ExoHull> hulls = m_hulls;
			IndexPair val3 = nodePairs[i];
			hulls[((IndexPair)(ref val3)).I].SleeveIndices.Add(i);
			List<ExoHull> hulls2 = m_hulls;
			IndexPair val4 = nodePairs[i];
			hulls2[((IndexPair)(ref val4)).J].SleeveIndices.Add(i);
			List<ExoHull> hulls3 = m_hulls;
			IndexPair val5 = nodePairs[i];
			hulls3[((IndexPair)(ref val5)).I].PlateIndices.Add(((IndexPair)(ref platePair)).I);
			List<ExoHull> hulls4 = m_hulls;
			IndexPair val6 = nodePairs[i];
			hulls4[((IndexPair)(ref val6)).J].PlateIndices.Add(((IndexPair)(ref platePair)).J);
		}
	}

	public bool ComputeOffsets(int nodeIndex, double tol)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Invalid comparison between Unknown and I4
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Invalid comparison between Unknown and I4
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Invalid comparison between Unknown and I4
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Invalid comparison between Unknown and I4
		ExoHull exoHull = Hulls[nodeIndex];
		List<Curve> list = new List<Curve>();
		List<double> list2 = new List<double>();
		List<double> list3 = new List<double>();
		double item = default(double);
		foreach (int sleeveIndex in exoHull.SleeveIndices)
		{
			Curve val = Sleeves[sleeveIndex].Curve.DuplicateCurve();
			Point3d pointAtEnd = val.PointAtEnd;
			if (((Point3d)(ref pointAtEnd)).EpsilonEquals(exoHull.Point3d, 100.0 * tol))
			{
				val.Reverse();
				val.Domain = new Interval(0.0, 1.0);
				list2.Add(Sleeves[sleeveIndex].EndRadius);
			}
			else
			{
				list2.Add(Sleeves[sleeveIndex].StartRadius);
			}
			list.Add(val);
			val.LengthParameter(list2[list2.Count - 1], ref item);
			list3.Add(item);
		}
		double num = 0.0;
		foreach (double item2 in list2)
		{
			double num2 = item2;
			num += num2;
		}
		exoHull.AvgRadius = num / (double)list2.Count;
		bool flag = false;
		int num3 = 0;
		double num4 = list3[0] / 10.0;
		Plane val2 = default(Plane);
		double num5 = default(double);
		double num6 = default(double);
		while (!flag && num3 < 500)
		{
			List<Circle> list4 = new List<Circle>();
			for (int i = 0; i < list.Count; i++)
			{
				list[i].PerpendicularFrameAt(list3[i], ref val2);
				list4.Add(new Circle(val2, list2[i]));
			}
			bool[] array = new bool[list.Count];
			for (int j = 0; j < list.Count; j++)
			{
				for (int k = j + 1; k < list.Count; k++)
				{
					Circle val3 = list4[j];
					PlaneCircleIntersection val4 = Intersection.PlaneCircle(((Circle)(ref val3)).Plane, list4[k], ref num5, ref num6);
					Circle val5 = list4[k];
					PlaneCircleIntersection val6 = Intersection.PlaneCircle(((Circle)(ref val5)).Plane, list4[j], ref num5, ref num6);
					if ((int)val4 == 2 || (int)val4 == 1)
					{
						array[j] = true;
					}
					if ((int)val6 == 2 || (int)val6 == 1)
					{
						array[k] = true;
					}
				}
			}
			flag = true;
			for (int l = 0; l < list.Count; l++)
			{
				if (array[l])
				{
					list3[l] += num4;
					flag = false;
				}
			}
			num3++;
		}
		for (int m = 0; m < list.Count; m++)
		{
			int index = exoHull.PlateIndices[m];
			Plates[index].Offset = 1.05 * list3[m];
		}
		return true;
	}

	public void FixSharpNodes(int nodeIndex, int sides)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		ExoHull exoHull = Hulls[nodeIndex];
		bool flag = true;
		Vector3d val = default(Vector3d);
		foreach (int plateIndex in exoHull.PlateIndices)
		{
			val += Plates[plateIndex].Normal;
		}
		foreach (int plateIndex2 in exoHull.PlateIndices)
		{
			if (Vector3d.VectorAngle(-val, Plates[plateIndex2].Normal) < Math.PI / 2.0)
			{
				flag = false;
			}
		}
		if (flag)
		{
			Plane plane = default(Plane);
			((Plane)(ref plane))._002Ector(exoHull.Point3d - val * exoHull.AvgRadius / (double)exoHull.PlateIndices.Count, -val);
			List<Point3d> collection = MeshTools.CreateKnuckle(plane, sides, exoHull.AvgRadius, 0.0);
			Plates.Add(new ExoPlate(nodeIndex, -val));
			int num = Plates.Count - 1;
			Plates[num].Vtc.AddRange(collection);
			exoHull.PlateIndices.Add(num);
		}
	}

	public Mesh MakeSleeve(int strutIndex, int sides)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		ExoSleeve exoSleeve = Sleeves[strutIndex];
		List<ExoPlate> plates = Plates;
		IndexPair platePair = exoSleeve.PlatePair;
		ExoPlate exoPlate = plates[((IndexPair)(ref platePair)).I];
		List<ExoPlate> plates2 = Plates;
		IndexPair platePair2 = exoSleeve.PlatePair;
		ExoPlate exoPlate2 = plates2[((IndexPair)(ref platePair2)).J];
		double offset = exoPlate.Offset;
		double num = 1.0 - exoPlate2.Offset;
		exoPlate.Vtc.Add(exoSleeve.Curve.PointAt(offset));
		exoPlate2.Vtc.Add(exoSleeve.Curve.PointAt(num));
		double avgRadius = exoSleeve.AvgRadius;
		double length = exoSleeve.Curve.GetLength(new Interval(offset, num));
		double num2 = Math.Max(Math.Round(length * 0.5 / avgRadius) * 2.0, 2.0);
		Vector3d tangentAtStart = exoSleeve.Curve.TangentAtStart;
		Plane plane = default(Plane);
		for (int i = 0; (double)i <= num2; i++)
		{
			if (exoSleeve.Curve.IsLinear())
			{
				Point3d val2 = exoPlate.Vtc[0] + tangentAtStart * (length * (double)i / num2);
				plane = new Plane(val2, tangentAtStart);
			}
			else
			{
				double num3 = offset + (double)i / num2 * (num - offset);
				exoSleeve.Curve.PointAt(num3);
				exoSleeve.Curve.PerpendicularFrameAt(num3, ref plane);
			}
			double radius = exoSleeve.StartRadius - (double)i * (exoSleeve.StartRadius - exoSleeve.EndRadius) / num2;
			double startAngle = (double)i * Math.PI / (double)sides;
			List<Point3d> list = MeshTools.CreateKnuckle(plane, sides, radius, startAngle);
			if (i == 0)
			{
				exoPlate.Vtc.AddRange(list);
			}
			if ((double)i == num2)
			{
				exoPlate2.Vtc.AddRange(list);
			}
			val.Vertices.AddVertices((IEnumerable<Point3d>)list);
		}
		for (int j = 0; (double)j < num2; j++)
		{
			for (int k = 0; k < sides; k++)
			{
				int num4 = j * sides + k;
				int num5 = j * sides + k + sides;
				int num6 = j * sides + sides + (k + 1) % sides;
				int num7 = j * sides + (k + 1) % sides;
				val.Faces.AddFace(num4, num5, num7);
				val.Faces.AddFace(num5, num6, num7);
			}
		}
		return val;
	}

	public Mesh MakeConvexHull(int nodeIndex, int sides, double tol, bool cleanPlates)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		Mesh mesh = new Mesh();
		ExoHull exoHull = Hulls[nodeIndex];
		double avgRadius = exoHull.AvgRadius;
		double num = tol * avgRadius / 10.0;
		List<Point3d> list = new List<Point3d>();
		foreach (int plateIndex in exoHull.PlateIndices)
		{
			list.AddRange(Plates[plateIndex].Vtc);
		}
		mesh.Vertices.Add(list[0]);
		mesh.Vertices.Add(list[1]);
		mesh.Vertices.Add(list[2]);
		Plane val = default(Plane);
		((Plane)(ref val))._002Ector(list[0], list[1], list[2]);
		int i;
		for (i = sides + 1; Math.Abs(((Plane)(ref val)).DistanceTo(list[i])) < num; i++)
		{
		}
		mesh.Vertices.Add(list[i]);
		mesh.Faces.AddFace(0, 2, 1);
		mesh.Faces.AddFace(0, 3, 2);
		mesh.Faces.AddFace(0, 1, 3);
		mesh.Faces.AddFace(1, 2, 3);
		list.RemoveAt(i);
		list.RemoveRange(0, 3);
		Plane val3 = default(Plane);
		for (int j = 0; j < list.Count; j++)
		{
			MeshTools.NormaliseMesh(ref mesh);
			List<int> list2 = new List<int>();
			for (int k = 0; k < mesh.Faces.Count; k++)
			{
				Vector3d val2 = list[j] - mesh.Faces.GetFaceCenter(k);
				double num2 = Vector3d.VectorAngle(Vector3d.op_Implicit(mesh.FaceNormals[k]), val2);
				((Plane)(ref val3))._002Ector(mesh.Faces.GetFaceCenter(k), Vector3d.op_Implicit(mesh.FaceNormals[k]));
				if (num2 < Math.PI / 2.0 || Math.Abs(((Plane)(ref val3)).DistanceTo(list[j])) < num)
				{
					list2.Add(k);
				}
			}
			mesh.Faces.DeleteFaces((IEnumerable<int>)list2);
			mesh.Vertices.Add(list[j]);
			List<MeshFace> list3 = new List<MeshFace>();
			for (int l = 0; l < mesh.TopologyEdges.Count; l++)
			{
				if (!mesh.TopologyEdges.IsSwappableEdge(l))
				{
					IndexPair topologyVertices = mesh.TopologyEdges.GetTopologyVertices(l);
					int num3 = mesh.TopologyVertices.MeshVertexIndices(((IndexPair)(ref topologyVertices)).I)[0];
					int num4 = mesh.TopologyVertices.MeshVertexIndices(((IndexPair)(ref topologyVertices)).J)[0];
					list3.Add(new MeshFace(num3, num4, mesh.Vertices.Count - 1));
				}
			}
			mesh.Faces.AddFaces((IEnumerable<MeshFace>)list3);
		}
		MeshTools.NormaliseMesh(ref mesh);
		if (cleanPlates)
		{
			List<int> list4 = new List<int>();
			Point3f val4 = default(Point3f);
			Point3f val5 = default(Point3f);
			Point3f val6 = default(Point3f);
			Point3f val7 = default(Point3f);
			foreach (int plateIndex2 in exoHull.PlateIndices)
			{
				List<Point3f> list5 = MeshTools.Point3dToPoint3f(Plates[plateIndex2].Vtc);
				if (list5.Count < sides + 1)
				{
					continue;
				}
				for (int m = 0; m < mesh.Faces.Count; m++)
				{
					mesh.Faces.GetFaceVertices(m, ref val4, ref val5, ref val6, ref val7);
					int num5 = 0;
					foreach (Point3f item in list5)
					{
						Point3f current3 = item;
						if (((Point3f)(ref current3)).EpsilonEquals(val4, (float)tol) || ((Point3f)(ref current3)).EpsilonEquals(val5, (float)tol) || ((Point3f)(ref current3)).EpsilonEquals(val6, (float)tol))
						{
							num5++;
						}
					}
					if (num5 == 3)
					{
						list4.Add(m);
					}
				}
			}
			list4.Reverse();
			foreach (int item2 in list4)
			{
				mesh.Faces.RemoveAt(item2);
			}
		}
		return mesh;
	}

	public Mesh MakeEndFace(int nodeIndex, int sides)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		foreach (Point3d item in Plates[Hulls[nodeIndex].PlateIndices[0]].Vtc)
		{
			val.Vertices.Add(item);
		}
		for (int i = 1; i < sides; i++)
		{
			val.Faces.AddFace(0, i, i + 1);
		}
		val.Faces.AddFace(0, sides, 1);
		return val;
	}
}


===== IntraLattice.CORE.Data\ExoPlate.cs =====
using System.Collections.Generic;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

internal class ExoPlate
{
	private double m_offset;

	private Vector3d m_normal;

	private List<Point3d> m_vtc;

	private int m_hullIndex;

	public double Offset
	{
		get
		{
			return m_offset;
		}
		set
		{
			m_offset = value;
		}
	}

	public Vector3d Normal
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_normal;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_normal = value;
		}
	}

	public List<Point3d> Vtc
	{
		get
		{
			return m_vtc;
		}
		set
		{
			m_vtc = value;
		}
	}

	public int HullIndex
	{
		get
		{
			return m_hullIndex;
		}
		set
		{
			m_hullIndex = value;
		}
	}

	public ExoPlate()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		m_offset = 0.0;
		m_normal = Vector3d.Unset;
		m_vtc = new List<Point3d>();
		m_hullIndex = 0;
	}

	public ExoPlate(int hullIndex, Vector3d normal)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		m_offset = 0.0;
		m_normal = normal;
		m_vtc = new List<Point3d>();
		m_hullIndex = hullIndex;
	}
}


===== IntraLattice.CORE.Data\ExoSleeve.cs =====
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

internal class ExoSleeve
{
	private Curve m_curve;

	private IndexPair m_hullPair;

	private IndexPair m_platePair;

	private double m_startRadius;

	private double m_endRadius;

	public Curve Curve
	{
		get
		{
			return m_curve;
		}
		set
		{
			m_curve = value;
		}
	}

	public IndexPair HullPair
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_hullPair;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_hullPair = value;
		}
	}

	public IndexPair PlatePair
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_platePair;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_platePair = value;
		}
	}

	public double StartRadius
	{
		get
		{
			return m_startRadius;
		}
		set
		{
			m_startRadius = value;
		}
	}

	public double EndRadius
	{
		get
		{
			return m_endRadius;
		}
		set
		{
			m_endRadius = value;
		}
	}

	public double AvgRadius => (StartRadius + EndRadius) / 2.0;

	public ExoSleeve()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		m_curve = null;
		m_hullPair = default(IndexPair);
		m_platePair = default(IndexPair);
		m_startRadius = 0.0;
		m_endRadius = 0.0;
	}

	public ExoSleeve(Curve curve)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		m_curve = curve;
		m_hullPair = default(IndexPair);
		m_platePair = default(IndexPair);
		m_startRadius = 0.0;
		m_endRadius = 0.0;
	}

	public ExoSleeve(Curve curve, IndexPair hullPair)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		m_curve = curve;
		m_hullPair = hullPair;
		m_platePair = default(IndexPair);
		m_startRadius = 0.0;
		m_endRadius = 0.0;
	}
}


===== IntraLattice.CORE.Data\Lattice.cs =====
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using Grasshopper;
using Grasshopper.Kernel.Data;
using Rhino;
using Rhino.Collections;
using Rhino.DocObjects;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;
using Rhino.Runtime;

namespace IntraLattice.CORE.Data;

public class Lattice
{
	private DataTree<LatticeNode> m_nodes;

	private List<Curve> m_struts;

	public DataTree<LatticeNode> Nodes
	{
		get
		{
			return m_nodes;
		}
		set
		{
			m_nodes = value;
		}
	}

	public List<Curve> Struts
	{
		get
		{
			return m_struts;
		}
		set
		{
			m_struts = value;
		}
	}

	public Lattice()
	{
		m_nodes = new DataTree<LatticeNode>();
		m_struts = new List<Curve>();
	}

	public Lattice Duplicate()
	{
		using MemoryStream memoryStream = new MemoryStream();
		if (GetType().IsSerializable)
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			binaryFormatter.Serialize(memoryStream, this);
			memoryStream.Position = 0L;
			return (Lattice)binaryFormatter.Deserialize(memoryStream);
		}
		return null;
	}

	public void ConformMapping(UnitCell cell, float[] N)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Expected O, but got Unknown
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Expected O, but got Unknown
		for (int i = 0; (float)i <= N[0]; i++)
		{
			for (int j = 0; (float)j <= N[1]; j++)
			{
				for (int k = 0; (float)k <= N[2]; k++)
				{
					foreach (IndexPair nodePair in cell.NodePairs)
					{
						IndexPair current = nodePair;
						int[] array = cell.NodePaths[((IndexPair)(ref current)).I];
						int[] array2 = cell.NodePaths[((IndexPair)(ref current)).J];
						GH_Path val = new GH_Path(new int[3]
						{
							i + array[0],
							j + array[1],
							k + array[2]
						});
						GH_Path val2 = new GH_Path(new int[3]
						{
							i + array2[0],
							j + array2[1],
							k + array2[2]
						});
						if (!Nodes.PathExists(val) || !Nodes.PathExists(val2))
						{
							continue;
						}
						LatticeNode latticeNode = Nodes[val, array[3]];
						LatticeNode latticeNode2 = Nodes[val2, array2[3]];
						if (latticeNode != null && latticeNode2 != null)
						{
							LineCurve val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
							if (val3 != null && ((CommonObject)val3).IsValid)
							{
								Struts.Add((Curve)(object)val3);
							}
						}
					}
				}
			}
		}
	}

	public void MorphMapping(UnitCell cell, DataTree<GeometryBase> spaceTree, float[] N)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Expected O, but got Unknown
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Expected O, but got Unknown
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Expected O, but got Unknown
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Expected O, but got Unknown
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Invalid comparison between Unknown and I4
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Invalid comparison between Unknown and I4
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Invalid comparison between Unknown and I4
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		Line val6 = default(Line);
		Point3d val7 = default(Point3d);
		Vector3d[] array3 = default(Vector3d[]);
		Point3d val9 = default(Point3d);
		Vector3d[] array4 = default(Vector3d[]);
		for (int i = 0; (float)i <= N[0]; i++)
		{
			for (int j = 0; (float)j <= N[1]; j++)
			{
				for (int k = 0; (float)k <= N[2]; k++)
				{
					foreach (IndexPair nodePair in cell.NodePairs)
					{
						IndexPair current = nodePair;
						int[] array = cell.NodePaths[((IndexPair)(ref current)).I];
						int[] array2 = cell.NodePaths[((IndexPair)(ref current)).J];
						GH_Path val = new GH_Path(new int[3]
						{
							i + array[0],
							j + array[1],
							k + array[2]
						});
						GH_Path val2 = new GH_Path(new int[3]
						{
							i + array2[0],
							j + array2[1],
							k + array2[2]
						});
						if (!Nodes.PathExists(val) || !Nodes.PathExists(val2))
						{
							continue;
						}
						LatticeNode latticeNode = Nodes[val, array[3]];
						LatticeNode latticeNode2 = Nodes[val2, array2[3]];
						if (latticeNode == null || latticeNode2 == null)
						{
							continue;
						}
						GH_Path val3 = (((float)i == N[0] && (float)j == N[1]) ? new GH_Path(new int[2]
						{
							i - 1,
							j - 1
						}) : (((float)i == N[0]) ? new GH_Path(new int[2]
						{
							i - 1,
							j
						}) : (((float)j != N[1]) ? new GH_Path(new int[2] { i, j }) : new GH_Path(new int[2]
						{
							i,
							j - 1
						}))));
						GeometryBase val4 = spaceTree[val3, 0];
						GeometryBase val5 = spaceTree[val3, 1];
						int num = 16;
						List<Point3d> list = new List<Point3d>();
						((Line)(ref val6))._002Ector(((RhinoList<Point3d>)(object)cell.Nodes)[((IndexPair)(ref current)).I], ((RhinoList<Point3d>)(object)cell.Nodes)[((IndexPair)(ref current)).J]);
						for (int l = 0; l <= num; l++)
						{
							list.Add(((Line)(ref val6)).PointAt((double)l / (double)num));
						}
						List<Point3d> list2 = new List<Point3d>();
						foreach (Point3d item2 in list)
						{
							Point3d current2 = item2;
							double num2 = ((Point3d)(ref current2)).X;
							double num3 = ((Point3d)(ref current2)).Y;
							if ((float)i == N[0])
							{
								num2 = 1.0 - num2;
							}
							if ((float)j == N[1])
							{
								num3 = 1.0 - num3;
							}
							((Surface)val4).Evaluate(num2, num3, 0, ref val7, ref array3);
							Vector3d val8 = Vector3d.Unset;
							ObjectType objectType = val5.ObjectType;
							if ((int)objectType != 1)
							{
								if ((int)objectType != 4)
								{
									if ((int)objectType == 8)
									{
										((Surface)val5).Evaluate(num2, num3, 0, ref val9, ref array4);
										val8 = val9 - val7;
									}
								}
								else
								{
									val8 = ((Curve)val5).PointAt(num2) - val7;
								}
							}
							else
							{
								val8 = ((Point)val5).Location - val7;
							}
							Point3d item = val7 + val8 * ((double)k + ((Point3d)(ref current2)).Z) / (double)N[2];
							list2.Add(item);
						}
						Curve val10 = Curve.CreateInterpolatedCurve((IEnumerable<Point3d>)list2, 3);
						if (val10 != null && ((CommonObject)val10).IsValid)
						{
							Struts.Add(val10);
						}
					}
				}
			}
		}
	}

	public void UniformMapping(UnitCell cell, GeometryBase designSpace, int spaceType, float[] N, double minStrutLength)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Expected O, but got Unknown
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Expected O, but got Unknown
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Expected O, but got Unknown
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Expected O, but got Unknown
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Expected O, but got Unknown
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Expected O, but got Unknown
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Expected O, but got Unknown
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Expected O, but got Unknown
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		int[] array5 = default(int[]);
		for (int i = 0; (float)i <= N[0]; i++)
		{
			for (int j = 0; (float)j <= N[1]; j++)
			{
				for (int k = 0; (float)k <= N[2]; k++)
				{
					foreach (IndexPair nodePair in cell.NodePairs)
					{
						IndexPair current = nodePair;
						int[] array = cell.NodePaths[((IndexPair)(ref current)).I];
						int[] array2 = cell.NodePaths[((IndexPair)(ref current)).J];
						GH_Path val = new GH_Path(new int[3]
						{
							i + array[0],
							j + array[1],
							k + array[2]
						});
						GH_Path val2 = new GH_Path(new int[3]
						{
							i + array2[0],
							j + array2[1],
							k + array2[2]
						});
						if (!Nodes.PathExists(val) || !Nodes.PathExists(val2))
						{
							continue;
						}
						LatticeNode latticeNode = Nodes[val, array[3]];
						LatticeNode latticeNode2 = Nodes[val2, array2[3]];
						if (latticeNode == null || latticeNode2 == null)
						{
							continue;
						}
						Curve item = (Curve)new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
						if (latticeNode.IsInside && latticeNode2.IsInside)
						{
							Struts.Add(item);
						}
						else
						{
							if (!latticeNode.IsInside && !latticeNode2.IsInside)
							{
								continue;
							}
							Point3d[] array3 = null;
							Curve[] array4 = null;
							LineCurve val3 = null;
							switch (spaceType)
							{
							case 1:
								val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
								Intersection.CurveBrep((Curve)(object)val3, (Brep)designSpace, modelAbsoluteTolerance, ref array4, ref array3);
								break;
							case 2:
								val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
								array3 = Intersection.MeshLine((Mesh)designSpace, val3.Line, ref array5);
								break;
							case 3:
								array4 = null;
								val3 = new LineCurve(latticeNode.Point3d, latticeNode2.Point3d);
								Intersection.CurveBrep((Curve)(object)val3, ((Surface)designSpace).ToBrep(), modelAbsoluteTolerance, ref array4, ref array3);
								break;
							}
							LineCurve val4 = null;
							if (array3.Length > 0)
							{
								val4 = AddTrimmedStrut(latticeNode, latticeNode2, array3[0], minStrutLength);
								if (val4 != null)
								{
									Struts.Add((Curve)(object)val4);
								}
							}
							else if (array4 != null && array4.Length > 0)
							{
								Struts.Add(array4[0]);
							}
						}
					}
				}
			}
		}
	}

	public LineCurve AddTrimmedStrut(LatticeNode node1, LatticeNode node2, Point3d intersectionPt, double minStrutLength)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Expected O, but got Unknown
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Expected O, but got Unknown
		new LineCurve(new Line(node1.Point3d, node2.Point3d), 0.0, 1.0);
		if (node1.IsInside)
		{
			double num = ((Point3d)(ref intersectionPt)).DistanceTo(node1.Point3d);
			if (num > minStrutLength)
			{
				Nodes.Add(new LatticeNode(intersectionPt, LatticeNodeState.Boundary));
				return new LineCurve(node1.Point3d, intersectionPt);
			}
			node1.State = LatticeNodeState.Boundary;
		}
		if (node2.IsInside)
		{
			double num2 = ((Point3d)(ref intersectionPt)).DistanceTo(node2.Point3d);
			if (num2 > minStrutLength)
			{
				Nodes.Add(new LatticeNode(intersectionPt, LatticeNodeState.Boundary));
				return new LineCurve(node2.Point3d, intersectionPt);
			}
			node2.State = LatticeNodeState.Boundary;
		}
		return null;
	}
}


===== IntraLattice.CORE.Data\LatticeNode.cs =====
using System;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

[Serializable]
public class LatticeNode
{
	private Point3d m_point3d;

	private LatticeNodeState m_state;

	public Point3d Point3d
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_point3d;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_point3d = value;
		}
	}

	public LatticeNodeState State
	{
		get
		{
			return m_state;
		}
		set
		{
			m_state = value;
		}
	}

	public bool IsInside
	{
		get
		{
			if (m_state == LatticeNodeState.Outside)
			{
				return false;
			}
			return true;
		}
	}

	public LatticeNode()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = Point3d.Unset;
		m_state = LatticeNodeState.Inside;
	}

	public LatticeNode(Point3d point3d)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = point3d;
		m_state = LatticeNodeState.Inside;
	}

	public LatticeNode(Point3d point3d, LatticeNodeState state)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		m_point3d = point3d;
		m_state = state;
	}
}


===== IntraLattice.CORE.Data\LatticeNodeState.cs =====
namespace IntraLattice.CORE.Data;

public enum LatticeNodeState
{
	Outside,
	Inside,
	Boundary
}


===== IntraLattice.CORE.Data\UnitCell.cs =====
using System;
using System.Collections.Generic;
using IntraLattice.CORE.Helpers;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data;

public class UnitCell
{
	private Point3dList m_nodes;

	private List<IndexPair> m_nodePairs;

	private List<int[]> m_nodePaths;

	public Point3dList Nodes
	{
		get
		{
			return m_nodes;
		}
		set
		{
			m_nodes = value;
		}
	}

	public List<IndexPair> NodePairs
	{
		get
		{
			return m_nodePairs;
		}
		set
		{
			m_nodePairs = value;
		}
	}

	public List<int[]> NodePaths
	{
		get
		{
			return m_nodePaths;
		}
		set
		{
			m_nodePaths = value;
		}
	}

	public bool isValid
	{
		get
		{
			int num = CheckValidity();
			if (num == 1)
			{
				return true;
			}
			return false;
		}
	}

	public UnitCell()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		m_nodes = new Point3dList();
		m_nodePairs = new List<IndexPair>();
		m_nodePaths = new List<int[]>();
	}

	public UnitCell(List<Line> rawCell)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		m_nodes = new Point3dList();
		m_nodePairs = new List<IndexPair>();
		m_nodePaths = new List<int[]>();
		ExtractTopology(rawCell);
		NormaliseTopology();
	}

	public UnitCell Duplicate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		UnitCell unitCell = new UnitCell();
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			((RhinoList<Point3d>)(object)unitCell.Nodes).Add(item);
		}
		foreach (IndexPair nodePair in NodePairs)
		{
			unitCell.NodePairs.Add(nodePair);
		}
		foreach (int[] nodePath in NodePaths)
		{
			unitCell.NodePaths.Add(new int[4]
			{
				nodePath[0],
				nodePath[1],
				nodePath[2],
				nodePath[3]
			});
		}
		return unitCell;
	}

	private void ExtractTopology(List<Line> lines)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		CellTools.FixIntersections(ref lines);
		IndexPair item = default(IndexPair);
		foreach (Line line in lines)
		{
			Line current = line;
			Point3d[] array = (Point3d[])(object)new Point3d[2]
			{
				((Line)(ref current)).From,
				((Line)(ref current)).To
			};
			List<int> list = new List<int>();
			Point3d[] array2 = array;
			foreach (Point3d val in array2)
			{
				int num = Nodes.ClosestIndex(val);
				if (((RhinoList<Point3d>)(object)Nodes).Count != 0)
				{
					Point3d val2 = ((RhinoList<Point3d>)(object)Nodes)[num];
					if (((Point3d)(ref val2)).EpsilonEquals(val, modelAbsoluteTolerance))
					{
						list.Add(num);
						continue;
					}
				}
				((RhinoList<Point3d>)(object)Nodes).Add(val);
				list.Add(((RhinoList<Point3d>)(object)Nodes).Count - 1);
			}
			((IndexPair)(ref item))._002Ector(list[0], list[1]);
			if (NodePairs.Count == 0 || !NodePairs.Contains(item))
			{
				NodePairs.Add(item);
			}
		}
	}

	private void NormaliseTopology()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Interval val = default(Interval);
		Interval val2 = default(Interval);
		Interval val3 = default(Interval);
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			Point3d current = item;
			if (((Point3d)(ref current)).X < ((Interval)(ref val)).T0)
			{
				((Interval)(ref val)).T0 = ((Point3d)(ref current)).X;
			}
			if (((Point3d)(ref current)).X > ((Interval)(ref val)).T1)
			{
				((Interval)(ref val)).T1 = ((Point3d)(ref current)).X;
			}
			if (((Point3d)(ref current)).Y < ((Interval)(ref val2)).T0)
			{
				((Interval)(ref val2)).T0 = ((Point3d)(ref current)).Y;
			}
			if (((Point3d)(ref current)).Y > ((Interval)(ref val2)).T1)
			{
				((Interval)(ref val2)).T1 = ((Point3d)(ref current)).Y;
			}
			if (((Point3d)(ref current)).Z < ((Interval)(ref val3)).T0)
			{
				((Interval)(ref val3)).T0 = ((Point3d)(ref current)).Z;
			}
			if (((Point3d)(ref current)).Z > ((Interval)(ref val3)).T1)
			{
				((Interval)(ref val3)).T1 = ((Point3d)(ref current)).Z;
			}
		}
		Vector3d val4 = default(Vector3d);
		((Vector3d)(ref val4))._002Ector(0.0 - ((Interval)(ref val)).T0, 0.0 - ((Interval)(ref val2)).T0, 0.0 - ((Interval)(ref val3)).T0);
		Nodes.Transform(Transform.Translation(val4));
		Nodes.Transform(Transform.Scale(Plane.WorldXY, 1.0 / ((Interval)(ref val)).Length, 1.0 / ((Interval)(ref val2)).Length, 1.0 / ((Interval)(ref val3)).Length));
	}

	public int CheckValidity()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Plane[] array = (Plane[])(object)new Plane[2];
		ref Plane reference = ref array[0];
		Point3d val = new Point3d(0.0, 0.0, 0.0);
		Plane worldXY = Plane.WorldXY;
		reference = new Plane(val, ((Plane)(ref worldXY)).ZAxis);
		ref Plane reference2 = ref array[1];
		Point3d val2 = new Point3d(0.0, 0.0, 1.0);
		Plane worldXY2 = Plane.WorldXY;
		reference2 = new Plane(val2, ((Plane)(ref worldXY2)).ZAxis);
		Plane[] array2 = (Plane[])(object)new Plane[2];
		ref Plane reference3 = ref array2[0];
		Point3d val3 = new Point3d(0.0, 0.0, 0.0);
		Plane worldXY3 = Plane.WorldXY;
		reference3 = new Plane(val3, ((Plane)(ref worldXY3)).XAxis);
		ref Plane reference4 = ref array2[1];
		Point3d val4 = new Point3d(1.0, 0.0, 0.0);
		Plane worldXY4 = Plane.WorldXY;
		reference4 = new Plane(val4, ((Plane)(ref worldXY4)).XAxis);
		Plane[] array3 = (Plane[])(object)new Plane[2];
		ref Plane reference5 = ref array3[0];
		Point3d val5 = new Point3d(0.0, 0.0, 0.0);
		Plane worldXY5 = Plane.WorldXY;
		reference5 = new Plane(val5, ((Plane)(ref worldXY5)).YAxis);
		ref Plane reference6 = ref array3[1];
		Point3d val6 = new Point3d(0.0, 1.0, 0.0);
		Plane worldXY6 = Plane.WorldXY;
		reference6 = new Plane(val6, ((Plane)(ref worldXY6)).YAxis);
		bool[] array4 = new bool[3];
		bool[] array5 = array4;
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			Point3d current = item;
			_ = Point3d.Unset;
			if (Math.Abs(((Plane)(ref array[0])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Point3d)(ref current)).Y, ((Plane)(ref array[1])).OriginZ);
				array5[0] = true;
			}
			if (Math.Abs(((Plane)(ref array[1])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Point3d)(ref current)).Y, ((Plane)(ref array[0])).OriginZ);
			}
			if (Math.Abs(((Plane)(ref array2[0])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Plane)(ref array2[1])).OriginX, ((Point3d)(ref current)).Y, ((Point3d)(ref current)).Z);
				array5[1] = true;
			}
			if (Math.Abs(((Plane)(ref array2[1])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Plane)(ref array2[0])).OriginX, ((Point3d)(ref current)).Y, ((Point3d)(ref current)).Z);
			}
			if (Math.Abs(((Plane)(ref array3[0])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Plane)(ref array3[1])).OriginY, ((Point3d)(ref current)).Z);
				array5[2] = true;
			}
			if (Math.Abs(((Plane)(ref array3[1])).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				new Point3d(((Point3d)(ref current)).X, ((Plane)(ref array3[0])).OriginY, ((Point3d)(ref current)).Z);
			}
		}
		if (!array5[0] || !array5[1] || !array5[2])
		{
			return 0;
		}
		return 1;
	}

	public void FormatTopology()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0456: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0462: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0473: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		Plane worldXY = Plane.WorldXY;
		((Plane)(ref worldXY)).Translate(new Vector3d(0.0, 0.0, 1.0));
		Plane worldYZ = Plane.WorldYZ;
		((Plane)(ref worldYZ)).Translate(new Vector3d(1.0, 0.0, 0.0));
		Plane worldZX = Plane.WorldZX;
		((Plane)(ref worldZX)).Translate(new Vector3d(0.0, 1.0, 0.0));
		foreach (Point3d item in (RhinoList<Point3d>)(object)Nodes)
		{
			Point3d current = item;
			if (Math.Abs(((Plane)(ref worldXY)).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				if (((Point3d)(ref current)).DistanceTo(new Point3d(1.0, 1.0, 1.0)) < modelAbsoluteTolerance)
				{
					List<int[]> nodePaths = NodePaths;
					int[] array = new int[4] { 1, 1, 1, 0 };
					array[3] = Nodes.ClosestIndex(new Point3d(0.0, 0.0, 0.0));
					nodePaths.Add(array);
				}
				else if (Math.Abs(((Point3d)(ref current)).X - 1.0) < modelAbsoluteTolerance && Math.Abs(((Point3d)(ref current)).Z - 1.0) < modelAbsoluteTolerance)
				{
					NodePaths.Add(new int[4]
					{
						1,
						0,
						1,
						Nodes.ClosestIndex(new Point3d(0.0, ((Point3d)(ref current)).Y, 0.0))
					});
				}
				else if (Math.Abs(((Point3d)(ref current)).Y - 1.0) < modelAbsoluteTolerance && Math.Abs(((Point3d)(ref current)).Z - 1.0) < modelAbsoluteTolerance)
				{
					NodePaths.Add(new int[4]
					{
						0,
						1,
						1,
						Nodes.ClosestIndex(new Point3d(((Point3d)(ref current)).X, 0.0, 0.0))
					});
				}
				else
				{
					NodePaths.Add(new int[4]
					{
						0,
						0,
						1,
						Nodes.ClosestIndex(new Point3d(((Point3d)(ref current)).X, ((Point3d)(ref current)).Y, 0.0))
					});
				}
			}
			else if (Math.Abs(((Plane)(ref worldYZ)).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				if (Math.Abs(((Point3d)(ref current)).X - 1.0) < modelAbsoluteTolerance && Math.Abs(((Point3d)(ref current)).Y - 1.0) < modelAbsoluteTolerance)
				{
					NodePaths.Add(new int[4]
					{
						1,
						1,
						0,
						Nodes.ClosestIndex(new Point3d(0.0, 0.0, ((Point3d)(ref current)).Z))
					});
				}
				else
				{
					NodePaths.Add(new int[4]
					{
						1,
						0,
						0,
						Nodes.ClosestIndex(new Point3d(0.0, ((Point3d)(ref current)).Y, ((Point3d)(ref current)).Z))
					});
				}
			}
			else if (Math.Abs(((Plane)(ref worldZX)).DistanceTo(current)) < modelAbsoluteTolerance)
			{
				NodePaths.Add(new int[4]
				{
					0,
					1,
					0,
					Nodes.ClosestIndex(new Point3d(((Point3d)(ref current)).X, 0.0, ((Point3d)(ref current)).Z))
				});
			}
			else
			{
				NodePaths.Add(new int[4]
				{
					0,
					0,
					0,
					((RhinoList<Point3d>)(object)Nodes).IndexOf(current)
				});
			}
		}
		List<int> list = new List<int>();
		for (int i = 0; i < NodePairs.Count; i++)
		{
			Point3dList nodes = Nodes;
			IndexPair val = NodePairs[i];
			Point3d val2 = ((RhinoList<Point3d>)(object)nodes)[((IndexPair)(ref val)).I];
			Point3dList nodes2 = Nodes;
			IndexPair val3 = NodePairs[i];
			Point3d val4 = ((RhinoList<Point3d>)(object)nodes2)[((IndexPair)(ref val3)).J];
			bool flag = false;
			if (Math.Abs(((Plane)(ref worldXY)).DistanceTo(val2)) < modelAbsoluteTolerance && Math.Abs(((Plane)(ref worldXY)).DistanceTo(val4)) < modelAbsoluteTolerance)
			{
				flag = true;
			}
			if (Math.Abs(((Plane)(ref worldYZ)).DistanceTo(val2)) < modelAbsoluteTolerance && Math.Abs(((Plane)(ref worldYZ)).DistanceTo(val4)) < modelAbsoluteTolerance)
			{
				flag = true;
			}
			if (Math.Abs(((Plane)(ref worldZX)).DistanceTo(val2)) < modelAbsoluteTolerance && Math.Abs(((Plane)(ref worldZX)).DistanceTo(val4)) < modelAbsoluteTolerance)
			{
				flag = true;
			}
			if (flag)
			{
				list.Add(i);
			}
		}
		list.Reverse();
		foreach (int item2 in list)
		{
			NodePairs.RemoveAt(item2);
		}
	}
}


===== IntraLattice.CORE.Data.GH_Goo\LatticeGoo.cs =====
using System;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data.GH_Goo;

public class LatticeGoo : GH_GeometricGoo<Lattice>, IGH_PreviewData
{
	public override bool IsValid
	{
		get
		{
			if (((GH_GeometricGoo<Lattice>)this).Value == null)
			{
				return false;
			}
			return base.IsValid;
		}
	}

	public override string IsValidWhyNot
	{
		get
		{
			if (((GH_GeometricGoo<Lattice>)this).Value.Nodes == null)
			{
				return "nodes empty";
			}
			if (((GH_GeometricGoo<Lattice>)this).Value.Struts == null)
			{
				return "struts empty";
			}
			return ((GH_Goo<Lattice>)(object)this).IsValidWhyNot;
		}
	}

	public override string TypeDescription => "Lattice Representation";

	public override string TypeName => "LatticeGoo";

	public override BoundingBox Boundingbox
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			Point3dList val = new Point3dList();
			foreach (LatticeNode item in ((GH_GeometricGoo<Lattice>)this).Value.Nodes.AllData())
			{
				((RhinoList<Point3d>)(object)val).Add(item.Point3d);
			}
			return val.BoundingBox;
		}
	}

	public BoundingBox ClippingBox => ((GH_GeometricGoo<Lattice>)this).Boundingbox;

	public LatticeGoo()
	{
		((GH_GeometricGoo<Lattice>)this).Value = new Lattice();
	}

	public LatticeGoo(Lattice cell)
	{
		if (cell == null)
		{
			cell = new Lattice();
		}
		((GH_GeometricGoo<Lattice>)this).Value = cell;
	}

	public LatticeGoo DuplicateGoo()
	{
		return new LatticeGoo(((GH_GeometricGoo<Lattice>)this).Value.Duplicate());
	}

	public override IGH_GeometricGoo DuplicateGeometry()
	{
		return (IGH_GeometricGoo)(object)DuplicateGoo();
	}

	public override string ToString()
	{
		if (((GH_GeometricGoo<Lattice>)this).Value == null)
		{
			return "Null Lattice";
		}
		return ((GH_GeometricGoo<Lattice>)this).Value.ToString();
	}

	public override object ScriptVariable()
	{
		return ((GH_GeometricGoo<Lattice>)this).Value;
	}

	public override bool CastTo<Q>(out Q target)
	{
		if (typeof(Q).IsAssignableFrom(typeof(Lattice)))
		{
			if (((GH_GeometricGoo<Lattice>)this).Value == null)
			{
				target = default(Q);
			}
			else
			{
				target = (Q)(object)((GH_GeometricGoo<Lattice>)this).Value;
			}
			return true;
		}
		target = default(Q);
		return false;
	}

	public override bool CastFrom(object source)
	{
		if (source == null)
		{
			return false;
		}
		if (typeof(Lattice).IsAssignableFrom(source.GetType()))
		{
			((GH_GeometricGoo<Lattice>)this).Value = (Lattice)source;
			return true;
		}
		return false;
	}

	public override BoundingBox GetBoundingBox(Transform xform)
	{
		throw new NotImplementedException();
	}

	public override IGH_GeometricGoo Transform(Transform xform)
	{
		throw new NotImplementedException();
	}

	public override IGH_GeometricGoo Morph(SpaceMorph xmorph)
	{
		throw new NotImplementedException();
	}

	public void DrawViewportWires(GH_PreviewWireArgs args)
	{
	}

	public void DrawViewportMeshes(GH_PreviewMeshArgs args)
	{
	}
}


===== IntraLattice.CORE.Data.GH_Goo\UnitCellGoo.cs =====
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Types;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;

namespace IntraLattice.CORE.Data.GH_Goo;

public class UnitCellGoo : GH_GeometricGoo<UnitCell>, IGH_PreviewData
{
	public override bool IsValid
	{
		get
		{
			if (((GH_GeometricGoo<UnitCell>)this).Value == null)
			{
				return false;
			}
			return base.IsValid;
		}
	}

	public override string IsValidWhyNot
	{
		get
		{
			if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
			{
				return "Node list empty";
			}
			if (((GH_GeometricGoo<UnitCell>)this).Value.NodePairs == null)
			{
				return "No line";
			}
			return ((GH_Goo<UnitCell>)(object)this).IsValidWhyNot;
		}
	}

	public override string TypeDescription => "LatticeCell Representation";

	public override string TypeName => "LatticeCellGoo";

	public override BoundingBox Boundingbox
	{
		get
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (((GH_GeometricGoo<UnitCell>)this).Value == null)
			{
				return BoundingBox.Empty;
			}
			if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
			{
				return BoundingBox.Empty;
			}
			return ((GH_GeometricGoo<UnitCell>)this).Value.Nodes.BoundingBox;
		}
	}

	public BoundingBox ClippingBox => ((GH_GeometricGoo<UnitCell>)this).Boundingbox;

	public UnitCellGoo()
	{
		((GH_GeometricGoo<UnitCell>)this).Value = new UnitCell();
	}

	public UnitCellGoo(UnitCell cell)
	{
		if (cell == null)
		{
			cell = new UnitCell();
		}
		((GH_GeometricGoo<UnitCell>)this).Value = cell;
	}

	public override IGH_GeometricGoo DuplicateGeometry()
	{
		return (IGH_GeometricGoo)(object)DuplicateGoo();
	}

	public UnitCellGoo DuplicateGoo()
	{
		return new UnitCellGoo((((GH_GeometricGoo<UnitCell>)this).Value == null) ? new UnitCell() : ((GH_GeometricGoo<UnitCell>)this).Value.Duplicate());
	}

	public override string ToString()
	{
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return "Null LatticeCell";
		}
		return ((GH_GeometricGoo<UnitCell>)this).Value.ToString();
	}

	public override BoundingBox GetBoundingBox(Transform xform)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return BoundingBox.Empty;
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
		{
			return BoundingBox.Empty;
		}
		return ((GH_GeometricGoo<UnitCell>)this).Value.Nodes.BoundingBox;
	}

	public override object ScriptVariable()
	{
		return ((GH_GeometricGoo<UnitCell>)this).Value;
	}

	public override bool CastTo<Q>(out Q target)
	{
		if (typeof(Q).IsAssignableFrom(typeof(UnitCell)))
		{
			if (((GH_GeometricGoo<UnitCell>)this).Value == null)
			{
				target = default(Q);
			}
			else
			{
				target = (Q)(object)((GH_GeometricGoo<UnitCell>)this).Value;
			}
			return true;
		}
		target = default(Q);
		return false;
	}

	public override bool CastFrom(object source)
	{
		if (source == null)
		{
			return false;
		}
		if (typeof(UnitCell).IsAssignableFrom(source.GetType()))
		{
			((GH_GeometricGoo<UnitCell>)this).Value = (UnitCell)source;
			return true;
		}
		return false;
	}

	public override IGH_GeometricGoo Transform(Transform xform)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return null;
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes == null)
		{
			return null;
		}
		((GH_Goo<UnitCell>)(object)this).m_value.Nodes.Transform(xform);
		return (IGH_GeometricGoo)(object)this;
	}

	public override IGH_GeometricGoo Morph(SpaceMorph xmorph)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes).Count; i++)
		{
			((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[i] = xmorph.MorphPoint(((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[i]);
		}
		return (IGH_GeometricGoo)(object)this;
	}

	public void DrawViewportWires(GH_PreviewWireArgs args)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		if (((GH_GeometricGoo<UnitCell>)this).Value == null)
		{
			return;
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.Nodes != null)
		{
			foreach (Point3d item in (RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)
			{
				args.Pipeline.DrawPoint(item, (Color)args.Color);
			}
		}
		if (((GH_GeometricGoo<UnitCell>)this).Value.NodePairs == null)
		{
			return;
		}
		foreach (IndexPair nodePair in ((GH_GeometricGoo<UnitCell>)this).Value.NodePairs)
		{
			IndexPair current2 = nodePair;
			Point3d val = ((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[((IndexPair)(ref current2)).I];
			Point3d val2 = ((RhinoList<Point3d>)(object)((GH_GeometricGoo<UnitCell>)this).Value.Nodes)[((IndexPair)(ref current2)).J];
			args.Pipeline.DrawLine(val, val2, (Color)args.Color);
		}
	}

	public void DrawViewportMeshes(GH_PreviewMeshArgs args)
	{
	}
}


===== IntraLattice.CORE.Helpers\CellTools.cs =====
using System.Collections.Generic;
using Rhino;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;

namespace IntraLattice.CORE.Helpers;

public class CellTools
{
	public static void FixIntersections(ref List<Line> lines)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		List<int> list = new List<int>();
		List<Line> list2 = new List<Line>();
		double num = default(double);
		double num2 = default(double);
		for (int i = 0; i < lines.Count; i++)
		{
			for (int j = i + 1; j < lines.Count; j++)
			{
				if (Intersection.LineLine(lines[i], lines[j], ref num, ref num2, modelAbsoluteTolerance, true))
				{
					if (num > modelAbsoluteTolerance && 1.0 - num > modelAbsoluteTolerance && !list.Contains(i))
					{
						Line val = lines[i];
						Point3d from = ((Line)(ref val)).From;
						Line val2 = lines[i];
						list2.Add(new Line(from, ((Line)(ref val2)).PointAt(num)));
						Line val3 = lines[i];
						Point3d val4 = ((Line)(ref val3)).PointAt(num);
						Line val5 = lines[i];
						list2.Add(new Line(val4, ((Line)(ref val5)).To));
						list.Add(i);
					}
					if (num2 > modelAbsoluteTolerance && 1.0 - num2 > modelAbsoluteTolerance && !list.Contains(j))
					{
						Line val6 = lines[j];
						Point3d from2 = ((Line)(ref val6)).From;
						Line val7 = lines[j];
						list2.Add(new Line(from2, ((Line)(ref val7)).PointAt(num2)));
						Line val8 = lines[j];
						Point3d val9 = ((Line)(ref val8)).PointAt(num2);
						Line val10 = lines[j];
						list2.Add(new Line(val9, ((Line)(ref val10)).To));
						list.Add(j);
					}
				}
			}
		}
		list.Sort();
		list.Reverse();
		foreach (int item in list)
		{
			lines.RemoveAt(item);
		}
		lines.AddRange(list2);
	}

	public static void MakeCornerNodes(ref List<Point3d> nodes, double d)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		nodes.Add(new Point3d(0.0, 0.0, 0.0));
		nodes.Add(new Point3d(d, 0.0, 0.0));
		nodes.Add(new Point3d(d, d, 0.0));
		nodes.Add(new Point3d(0.0, d, 0.0));
		nodes.Add(new Point3d(0.0, 0.0, d));
		nodes.Add(new Point3d(d, 0.0, d));
		nodes.Add(new Point3d(d, d, d));
		nodes.Add(new Point3d(0.0, d, d));
	}
}


===== IntraLattice.CORE.Helpers\FrameTools.cs =====
using System;
using System.Collections.Generic;
using Rhino;
using Rhino.Collections;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.Helpers;

public class FrameTools
{
	public static List<Curve> CleanNetwork(List<Curve> inputStruts, double tol)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		Point3dList nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		return CleanNetwork(inputStruts, tol, out nodes, out nodePairs);
	}

	public static List<Curve> CleanNetwork(List<Curve> inputStruts, double tol, out Point3dList nodes)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		nodes = new Point3dList();
		List<IndexPair> nodePairs = new List<IndexPair>();
		return CleanNetwork(inputStruts, tol, out nodes, out nodePairs);
	}

	public static List<Curve> CleanNetwork(List<Curve> inputStruts, double tol, out Point3dList nodes, out List<IndexPair> nodePairs)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		nodes = new Point3dList();
		nodePairs = new List<IndexPair>();
		List<Curve> list = new List<Curve>();
		IndexPair item = default(IndexPair);
		for (int i = 0; i < inputStruts.Count; i++)
		{
			Curve val = inputStruts[i];
			val.Domain = new Interval(0.0, 1.0);
			double num = Math.Max(tol, 100.0 * RhinoDoc.ActiveDoc.ModelAbsoluteTolerance);
			if (val == null || !((CommonObject)val).IsValid || val.IsShort(num))
			{
				continue;
			}
			Point3d[] array = (Point3d[])(object)new Point3d[2] { val.PointAtStart, val.PointAtEnd };
			List<int> list2 = new List<int>();
			for (int j = 0; j < 2; j++)
			{
				Point3d val2 = array[j];
				int num2 = nodes.ClosestIndex(val2);
				if (((RhinoList<Point3d>)(object)nodes).Count != 0 && ((Point3d)(ref val2)).EpsilonEquals(((RhinoList<Point3d>)(object)nodes)[num2], tol))
				{
					list2.Add(num2);
					continue;
				}
				((RhinoList<Point3d>)(object)nodes).Add(val2);
				list2.Add(((RhinoList<Point3d>)(object)nodes).Count - 1);
			}
			bool flag = false;
			((IndexPair)(ref item))._002Ector(list2[0], list2[1]);
			int num3 = nodePairs.IndexOf(item);
			if (nodePairs.Count != 0 && num3 != -1)
			{
				Curve val3 = list[num3];
				Point3d val4 = val.PointAt(0.5);
				Point3d val5 = val3.PointAt(0.5);
				if (((Point3d)(ref val4)).EpsilonEquals(val5, tol))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				nodePairs.Add(item);
				val.Domain = new Interval(0.0, 1.0);
				list.Add(val);
			}
		}
		return list;
	}

	public static int ValidateSpace(ref GeometryBase designSpace)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Invalid comparison between Unknown and I4
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Invalid comparison between Unknown and I4
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		int result = 0;
		if ((int)designSpace.ObjectType == 16)
		{
			result = 1;
		}
		else if ((int)designSpace.ObjectType == 32 && ((Mesh)designSpace).IsClosed)
		{
			result = 2;
		}
		else if ((int)designSpace.ObjectType == 8 && ((Surface)designSpace).IsSolid)
		{
			result = 3;
		}
		return result;
	}

	public static bool IsPointInside(GeometryBase geometry, Point3d testPoint, int spaceType, double tol, bool strictlyIn)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		switch (spaceType)
		{
		case 1:
			result = ((Brep)geometry).IsPointInside(testPoint, tol, strictlyIn);
			break;
		case 2:
			result = ((Mesh)geometry).IsPointInside(testPoint, tol, strictlyIn);
			break;
		case 3:
			result = ((Surface)geometry).ToBrep().IsPointInside(testPoint, tol, strictlyIn);
			break;
		}
		return result;
	}

	public static double DistanceTo(GeometryBase geometry, Point3d testPoint, int spaceType)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		double result = 0.0;
		switch (spaceType)
		{
		case 1:
		{
			Point3d val = ((Brep)geometry).ClosestPoint(testPoint);
			result = ((Point3d)(ref testPoint)).DistanceTo(val);
			break;
		}
		case 2:
		{
			Point3d val = ((Mesh)geometry).ClosestPoint(testPoint);
			result = ((Point3d)(ref testPoint)).DistanceTo(val);
			break;
		}
		case 3:
		{
			Point3d val = ((Surface)geometry).ToBrep().ClosestPoint(testPoint);
			result = ((Point3d)(ref testPoint)).DistanceTo(val);
			break;
		}
		}
		return result;
	}
}


===== IntraLattice.CORE.Helpers\InputTools.cs =====
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Special;

namespace IntraLattice.CORE.Helpers;

public class InputTools
{
	public static void TopoSelect(ref IGH_Component Component, ref GH_Document GrasshopperDocument, int index, float offset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Expected O, but got Unknown
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Expected O, but got Unknown
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Expected O, but got Unknown
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Expected O, but got Unknown
		GH_ValueList val = new GH_ValueList();
		val.ListMode = (GH_ValueListMode)3;
		val.CreateAttributes();
		float x = ((IGH_DocumentObject)Component).Attributes.Pivot.X - 250f;
		float y = ((IGH_DocumentObject)Component).Attributes.Pivot.Y + (float)(index * 40) - offset;
		PointF pivot = new PointF(x, y);
		((GH_DocumentObject)val).Attributes.Pivot = pivot;
		val.ListItems.Clear();
		List<GH_ValueListItem> list = new List<GH_ValueListItem>();
		list.Add(new GH_ValueListItem("Grid", "0"));
		list.Add(new GH_ValueListItem("X", "1"));
		list.Add(new GH_ValueListItem("Star", "2"));
		list.Add(new GH_ValueListItem("Cross", "3"));
		list.Add(new GH_ValueListItem("Tesseract", "4"));
		list.Add(new GH_ValueListItem("Vintiles", "5"));
		list.Add(new GH_ValueListItem("Octet", "6"));
		list.Add(new GH_ValueListItem("Diamond", "7"));
		list.Add(new GH_ValueListItem("Honeycomb 1", "8"));
		list.Add(new GH_ValueListItem("Honeycomb 2", "9"));
		val.ListItems.AddRange(list);
		GrasshopperDocument.AddObject((IGH_DocumentObject)(object)val, false, int.MaxValue);
		Component.Params.Input[index].AddSource((IGH_Param)(object)val);
		((IGH_ActiveObject)Component.Params.Input[index]).CollectData();
	}

	public static void OrientSelect(ref IGH_Component Component, ref GH_Document GrasshopperDocument, int index, float offset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		GH_ValueList val = new GH_ValueList();
		val.ListMode = (GH_ValueListMode)3;
		val.CreateAttributes();
		float x = ((IGH_DocumentObject)Component).Attributes.Pivot.X - 200f;
		float y = ((IGH_DocumentObject)Component).Attributes.Pivot.Y + (float)(index * 40) - offset;
		PointF pivot = new PointF(x, y);
		((GH_DocumentObject)val).Attributes.Pivot = pivot;
		val.ListItems.Clear();
		List<GH_ValueListItem> list = new List<GH_ValueListItem>();
		list.Add(new GH_ValueListItem("Default", "0"));
		list.Add(new GH_ValueListItem("RotateZ", "1"));
		list.Add(new GH_ValueListItem("RotateY", "2"));
		list.Add(new GH_ValueListItem("RotateX", "3"));
		val.ListItems.AddRange(list);
		GrasshopperDocument.AddObject((IGH_DocumentObject)(object)val, false, int.MaxValue);
		Component.Params.Input[index].AddSource((IGH_Param)(object)val);
		((IGH_ActiveObject)Component.Params.Input[index]).CollectData();
	}

	public static void GradientSelect(ref IGH_Component Component, ref GH_Document GrasshopperDocument, int index, float offset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Expected O, but got Unknown
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Expected O, but got Unknown
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Expected O, but got Unknown
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Expected O, but got Unknown
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Expected O, but got Unknown
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Expected O, but got Unknown
		GH_ValueList val = new GH_ValueList();
		val.ListMode = (GH_ValueListMode)1;
		val.CreateAttributes();
		float x = ((IGH_DocumentObject)Component).Attributes.Pivot.X - 200f;
		float y = ((IGH_DocumentObject)Component).Attributes.Pivot.Y + (float)(index * 40) - offset;
		PointF pivot = new PointF(x, y);
		((GH_DocumentObject)val).Attributes.Pivot = pivot;
		val.ListItems.Clear();
		List<GH_ValueListItem> list = new List<GH_ValueListItem>();
		list.Add(new GH_ValueListItem("Linear (X)", "0"));
		list.Add(new GH_ValueListItem("Linear (Y)", "1"));
		list.Add(new GH_ValueListItem("Linear (Z)", "2"));
		list.Add(new GH_ValueListItem("Centered (X)", "3"));
		list.Add(new GH_ValueListItem("Centered (Y)", "4"));
		list.Add(new GH_ValueListItem("Centered (Z)", "5"));
		list.Add(new GH_ValueListItem("Cylindrical (X)", "6"));
		list.Add(new GH_ValueListItem("Cylindrical (Y)", "7"));
		list.Add(new GH_ValueListItem("Cylindrical (Z)", "8"));
		list.Add(new GH_ValueListItem("Spherical", "9"));
		val.ListItems.AddRange(list);
		GrasshopperDocument.AddObject((IGH_DocumentObject)(object)val, false, int.MaxValue);
		Component.Params.Input[index].AddSource((IGH_Param)(object)val);
		((IGH_ActiveObject)Component.Params.Input[index]).CollectData();
	}
}


===== IntraLattice.CORE.Helpers\MeshTools.cs =====
using System;
using System.Collections.Generic;
using Rhino.Geometry;

namespace IntraLattice.CORE.Helpers;

public class MeshTools
{
	public static List<Point3d> CreateKnuckle(Plane plane, int sides, double radius, double startAngle)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		List<Point3d> list = new List<Point3d>();
		for (int i = 0; i < sides; i++)
		{
			double num = (double)(i * 2) * Math.PI / (double)sides + startAngle;
			list.Add(((Plane)(ref plane)).PointAt(radius * Math.Cos(num), radius * Math.Sin(num)));
		}
		return list;
	}

	public static List<Point3f> Point3dToPoint3f(List<Point3d> in3d)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		List<Point3f> list = new List<Point3f>();
		foreach (Point3d item in in3d)
		{
			Point3d current = item;
			list.Add(new Point3f((float)((Point3d)(ref current)).X, (float)((Point3d)(ref current)).Y, (float)((Point3d)(ref current)).Z));
		}
		return list;
	}

	public static void NormaliseMesh(ref Mesh mesh)
	{
		if (mesh.SolidOrientation() == -1)
		{
			mesh.Flip(true, true, true);
		}
		mesh.FaceNormals.ComputeFaceNormals();
		mesh.UnifyNormals();
		mesh.Normals.ComputeNormals();
	}
}


===== IntraLattice.CORE.MeshModule\HeterogenCustomComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.MeshModule;

public class HeterogenCustomComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.heterogenCustom;

	public override Guid ComponentGuid => new Guid("{5fa648cd-af7e-41e5-ac9c-f81bc19466bb}");

	public HeterogenCustomComponent()
		: base("Heterogen Custom", "HeterogenCustom", "Heterogeneous solidification of lattice wireframe", "IntraLattice", "Mesh")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Wireframe to thicken.", (GH_ParamAccess)1);
		pManager.AddNumberParameter("Start Radii", "StartRadii", "Radius at the start of each strut.", (GH_ParamAccess)1);
		pManager.AddNumberParameter("End Radii", "EndRadii", "Radius at the end of each strut.", (GH_ParamAccess)1);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Thickened wireframe.", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		List<Curve> list = new List<Curve>();
		List<double> list2 = new List<double>();
		List<double> list3 = new List<double>();
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetDataList<double>(1, list2) || !DA.GetDataList<double>(2, list3) || list == null || list.Count == 0 || list2 == null || list2.Count == 0 || list3 == null || list3.Count == 0)
		{
			return;
		}
		if (list2.Count != list.Count || list3.Count != list.Count)
		{
			((GH_ActiveObject)this).AddRuntimeMessage((GH_RuntimeMessageLevel)20, "Number of radii in each list must have same number of elements as the struts list.");
			return;
		}
		int sides = 6;
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		ExoMesh exoMesh = new ExoMesh(list);
		for (int i = 0; i < exoMesh.Sleeves.Count; i++)
		{
			exoMesh.Sleeves[i].StartRadius = list2[i];
			exoMesh.Sleeves[i].EndRadius = list3[i];
		}
		for (int j = 0; j < exoMesh.Hulls.Count; j++)
		{
			if (exoMesh.Hulls[j].SleeveIndices.Count >= 2)
			{
				exoMesh.ComputeOffsets(j, modelAbsoluteTolerance);
				exoMesh.FixSharpNodes(j, sides);
			}
		}
		for (int k = 0; k < exoMesh.Sleeves.Count; k++)
		{
			Mesh val = exoMesh.MakeSleeve(k, sides);
			exoMesh.Mesh.Append(val);
		}
		for (int l = 0; l < exoMesh.Hulls.Count; l++)
		{
			_ = exoMesh.Hulls[l];
			int count = exoMesh.Hulls[l].PlateIndices.Count;
			if (count < 2)
			{
				Mesh val2 = exoMesh.MakeEndFace(l, sides);
				exoMesh.Mesh.Append(val2);
			}
			else
			{
				Mesh val3 = exoMesh.MakeConvexHull(l, sides, modelAbsoluteTolerance, cleanPlates: true);
				exoMesh.Mesh.Append(val3);
			}
		}
		exoMesh.Mesh.Vertices.CombineIdentical(true, true);
		exoMesh.Mesh.FaceNormals.ComputeFaceNormals();
		exoMesh.Mesh.UnifyNormals();
		exoMesh.Mesh.Normals.ComputeNormals();
		DA.SetData(0, (object)exoMesh.Mesh);
	}
}


===== IntraLattice.CORE.MeshModule\HeterogenGradientComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Expressions;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.MeshModule;

public class HeterogenGradientComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.heterogenGradient;

	public override Guid ComponentGuid => new Guid("{a5e48dd2-8467-4991-95b1-15d29524de3e}");

	public HeterogenGradientComponent()
		: base("Heterogen Gradient", "HeterogenGradient", "Heterogeneous solidification (thickness gradient) of lattice wireframe", "IntraLattice", "Mesh")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Wireframe to thicken", (GH_ParamAccess)1);
		pManager.AddTextParameter("Gradient String", "Grad", "The spatial gradient as an expression string", (GH_ParamAccess)0, "0");
		pManager.AddNumberParameter("Maximum Radius", "Rmax", "Maximum radius in gradient", (GH_ParamAccess)0, 0.5);
		pManager.AddNumberParameter("Minimum Radius", "Rmin", "Minimum radius in gradient", (GH_ParamAccess)0, 0.2);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Thickened wireframe", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Expected O, but got Unknown
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		List<Curve> list = new List<Curve>();
		string text = null;
		double num = 0.0;
		double num2 = 0.0;
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetData<string>(1, ref text) || !DA.GetData<double>(2, ref num) || !DA.GetData<double>(3, ref num2) || list == null || list.Count == 0 || num <= 0.0 || num2 <= 0.0)
		{
			return;
		}
		int sides = 6;
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		ExoMesh exoMesh = new ExoMesh(list);
		BoundingBox val = default(BoundingBox);
		foreach (ExoSleeve sleefe in exoMesh.Sleeves)
		{
			BoundingBox boundingBox = ((GeometryBase)sleefe.Curve).GetBoundingBox(Plane.WorldXY);
			((BoundingBox)(ref val)).Union(boundingBox);
		}
		Point3d max = ((BoundingBox)(ref val)).Max;
		double x = ((Point3d)(ref max)).X;
		Point3d min = ((BoundingBox)(ref val)).Min;
		double num3 = x - ((Point3d)(ref min)).X;
		Point3d max2 = ((BoundingBox)(ref val)).Max;
		double y = ((Point3d)(ref max2)).Y;
		Point3d min2 = ((BoundingBox)(ref val)).Min;
		double num4 = y - ((Point3d)(ref min2)).Y;
		Point3d max3 = ((BoundingBox)(ref val)).Max;
		double z = ((Point3d)(ref max3)).Z;
		Point3d min3 = ((BoundingBox)(ref val)).Min;
		double num5 = z - ((Point3d)(ref min3)).Z;
		text = GH_ExpressionSyntaxWriter.RewriteForEvaluator(text);
		foreach (ExoSleeve sleefe2 in exoMesh.Sleeves)
		{
			List<ExoHull> hulls = exoMesh.Hulls;
			IndexPair hullPair = sleefe2.HullPair;
			ExoHull exoHull = hulls[((IndexPair)(ref hullPair)).I];
			GH_ExpressionParser val2 = new GH_ExpressionParser();
			Point3d point3d = exoHull.Point3d;
			double x2 = ((Point3d)(ref point3d)).X;
			Point3d min4 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("x", (x2 - ((Point3d)(ref min4)).X) / num3);
			Point3d point3d2 = exoHull.Point3d;
			double y2 = ((Point3d)(ref point3d2)).Y;
			Point3d min5 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("y", (y2 - ((Point3d)(ref min5)).Y) / num4);
			Point3d point3d3 = exoHull.Point3d;
			double z2 = ((Point3d)(ref point3d3)).Z;
			Point3d min6 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("z", (z2 - ((Point3d)(ref min6)).Z) / num5);
			sleefe2.StartRadius = num2 + val2.Evaluate(text)._Double * (num - num2);
			val2.ClearVariables();
			List<ExoHull> hulls2 = exoMesh.Hulls;
			IndexPair hullPair2 = sleefe2.HullPair;
			exoHull = hulls2[((IndexPair)(ref hullPair2)).J];
			Point3d point3d4 = exoHull.Point3d;
			double x3 = ((Point3d)(ref point3d4)).X;
			Point3d min7 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("x", (x3 - ((Point3d)(ref min7)).X) / num3);
			Point3d point3d5 = exoHull.Point3d;
			double y3 = ((Point3d)(ref point3d5)).Y;
			Point3d min8 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("y", (y3 - ((Point3d)(ref min8)).Y) / num4);
			Point3d point3d6 = exoHull.Point3d;
			double z3 = ((Point3d)(ref point3d6)).Z;
			Point3d min9 = ((BoundingBox)(ref val)).Min;
			val2.AddVariable("z", (z3 - ((Point3d)(ref min9)).Z) / num5);
			sleefe2.EndRadius = num2 + val2.Evaluate(text)._Double * (num - num2);
			val2.ClearVariables();
		}
		for (int i = 0; i < exoMesh.Hulls.Count; i++)
		{
			if (exoMesh.Hulls[i].SleeveIndices.Count >= 2)
			{
				exoMesh.ComputeOffsets(i, modelAbsoluteTolerance);
				exoMesh.FixSharpNodes(i, sides);
			}
		}
		for (int j = 0; j < exoMesh.Sleeves.Count; j++)
		{
			Mesh val3 = exoMesh.MakeSleeve(j, sides);
			exoMesh.Mesh.Append(val3);
		}
		for (int k = 0; k < exoMesh.Hulls.Count; k++)
		{
			_ = exoMesh.Hulls[k];
			int count = exoMesh.Hulls[k].PlateIndices.Count;
			if (count < 2)
			{
				Mesh val4 = exoMesh.MakeEndFace(k, sides);
				exoMesh.Mesh.Append(val4);
			}
			else
			{
				Mesh val5 = exoMesh.MakeConvexHull(k, sides, modelAbsoluteTolerance, cleanPlates: true);
				exoMesh.Mesh.Append(val5);
			}
		}
		exoMesh.Mesh.Vertices.CombineIdentical(true, true);
		exoMesh.Mesh.FaceNormals.ComputeFaceNormals();
		exoMesh.Mesh.UnifyNormals();
		exoMesh.Mesh.Normals.ComputeNormals();
		DA.SetData(0, (object)exoMesh.Mesh);
	}
}


===== IntraLattice.CORE.MeshModule\HomogenComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Data;
using IntraLattice.Properties;
using Rhino;
using Rhino.Geometry;

namespace IntraLattice.CORE.MeshModule;

public class HomogenComponent : GH_Component
{
	public override GH_Exposure Exposure => (GH_Exposure)2;

	protected override Bitmap Icon => Resources.homogen;

	public override Guid ComponentGuid => new Guid("{a51ac688-3afc-48a5-b121-48cecf687eb5}");

	public HomogenComponent()
		: base("Homogen", "Homogen", "Homogeneous solidification of lattice wireframe", "IntraLattice", "Mesh")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddCurveParameter("Struts", "Struts", "Wireframe to thicken", (GH_ParamAccess)1);
		pManager.AddNumberParameter("Radius", "Radius", "Strut Radius", (GH_ParamAccess)0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Thickened wireframe", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		List<Curve> list = new List<Curve>();
		double num = 0.0;
		if (!DA.GetDataList<Curve>(0, list) || !DA.GetData<double>(1, ref num) || list == null || list.Count == 0 || num <= 0.0)
		{
			return;
		}
		int sides = 6;
		double modelAbsoluteTolerance = RhinoDoc.ActiveDoc.ModelAbsoluteTolerance;
		ExoMesh exoMesh = new ExoMesh(list);
		foreach (ExoSleeve sleefe in exoMesh.Sleeves)
		{
			sleefe.StartRadius = num;
			sleefe.EndRadius = num;
		}
		for (int i = 0; i < exoMesh.Hulls.Count; i++)
		{
			if (exoMesh.Hulls[i].SleeveIndices.Count >= 2)
			{
				exoMesh.ComputeOffsets(i, modelAbsoluteTolerance);
				exoMesh.FixSharpNodes(i, sides);
			}
		}
		for (int j = 0; j < exoMesh.Sleeves.Count; j++)
		{
			Mesh val = exoMesh.MakeSleeve(j, sides);
			exoMesh.Mesh.Append(val);
		}
		for (int k = 0; k < exoMesh.Hulls.Count; k++)
		{
			_ = exoMesh.Hulls[k];
			int count = exoMesh.Hulls[k].PlateIndices.Count;
			if (count < 2)
			{
				Mesh val2 = exoMesh.MakeEndFace(k, sides);
				exoMesh.Mesh.Append(val2);
			}
			else
			{
				Mesh val3 = exoMesh.MakeConvexHull(k, sides, modelAbsoluteTolerance, cleanPlates: true);
				exoMesh.Mesh.Append(val3);
			}
		}
		exoMesh.Mesh.Vertices.CombineIdentical(true, true);
		exoMesh.Mesh.FaceNormals.ComputeFaceNormals();
		exoMesh.Mesh.UnifyNormals();
		exoMesh.Mesh.Normals.ComputeNormals();
		DA.SetData(0, (object)exoMesh.Mesh);
	}
}


===== IntraLattice.CORE.MeshModule\PresetGradientComponent.cs =====
using System;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.CORE.Helpers;
using IntraLattice.Properties;

namespace IntraLattice.CORE.MeshModule;

public class PresetGradientComponent : GH_Component
{
	private GH_Document GrasshopperDocument;

	private IGH_Component Component;

	public override GH_Exposure Exposure => (GH_Exposure)4;

	protected override Bitmap Icon => Resources.presetGradient;

	public override Guid ComponentGuid => new Guid("{6a4e5dcf-5d72-49fc-a543-c2465b14eb86}");

	public PresetGradientComponent()
		: base("Preset Gradient", "PresetGradient", "Generates gradient string (i.e. a spatial math expression)", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddIntegerParameter("Gradient Type", "Type", "Selection of gradient types", (GH_ParamAccess)0, 0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddTextParameter("Gradient String", "Grad", "The spatial gradient as an expression string", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		Component = (IGH_Component)(object)this;
		GrasshopperDocument = ((GH_DocumentObject)this).OnPingDocument();
		if (Component.Params.Input[0].SourceCount == 0)
		{
			InputTools.GradientSelect(ref Component, ref GrasshopperDocument, 0, 11f);
		}
		int num = 0;
		if (DA.GetData<int>(0, ref num))
		{
			string text = null;
			switch (num)
			{
			case 0:
				text = "Abs(x)";
				break;
			case 1:
				text = "Abs(y)";
				break;
			case 2:
				text = "Abs(z)";
				break;
			case 3:
				text = "Abs(2*x-1)";
				break;
			case 4:
				text = "Abs(2*y-1)";
				break;
			case 5:
				text = "Abs(2*z-1)";
				break;
			case 6:
				text = "Sqrt(Abs(2*y-1)^2 + Abs(2*z-1)^2)/Sqrt(2)";
				break;
			case 7:
				text = "Sqrt(Abs(2*x-1)^2 + Abs(2*z-1)^2)/Sqrt(2)";
				break;
			case 8:
				text = "Sqrt(Abs(2*x-1)^2 + Abs(2*y-1)^2)/Sqrt(2)";
				break;
			case 9:
				text = "Sqrt(Abs(2*x-1)^2 + Abs(2*y-1)^2 + Abs(2*z-1)^2)/Sqrt(3)";
				break;
			}
			DA.SetData(0, (object)text);
		}
	}
}


===== IntraLattice.CORE.UtilityModule\MeshPreviewComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.Properties;
using Rhino.Display;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.UtilityModule;

public class MeshPreviewComponent : GH_Component
{
	private List<Mesh> m_mesh = new List<Mesh>();

	public override GH_Exposure Exposure => (GH_Exposure)8;

	protected override Bitmap Icon => Resources.meshPreview;

	public override Guid ComponentGuid => new Guid("{c5e3b143-5534-4ad3-a711-33881772d683}");

	public MeshPreviewComponent()
		: base("Mesh Preview", "MeshPreview", "Generates a preview of the mesh.", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Mesh(es) to preview.", (GH_ParamAccess)1);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		List<Mesh> list = new List<Mesh>();
		if (DA.GetDataList<Mesh>(0, list) && list != null && list.Count != 0)
		{
			m_mesh = list;
		}
	}

	public override void DrawViewportMeshes(IGH_PreviewArgs args)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Expected O, but got Unknown
		DisplayMaterial val = new DisplayMaterial((Color)Color.FromArgb(255, 255, 255), 0.0);
		((GH_Component)this).DrawViewportMeshes(args);
		((GH_Component)this).DrawViewportWires(args);
		if (m_mesh == null)
		{
			return;
		}
		foreach (Mesh item in m_mesh)
		{
			if (item != null && ((CommonObject)item).IsValid)
			{
				args.Display.DrawMeshShaded(item, val);
				args.Display.DrawMeshWires(item, (Color)Color.Black);
			}
		}
	}
}


===== IntraLattice.CORE.UtilityModule\MeshReportComponent.cs =====
using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using IntraLattice.Properties;
using Rhino.Geometry;
using Rhino.Runtime;

namespace IntraLattice.CORE.UtilityModule;

public class MeshReportComponent : GH_Component
{
	private Polyline[] m_nakedEdges;

	public override GH_Exposure Exposure => (GH_Exposure)8;

	protected override Bitmap Icon => Resources.meshReport;

	public override Guid ComponentGuid => new Guid("{f49535d8-ab4a-4ee7-8721-290457b4e3eb}");

	public MeshReportComponent()
		: base("Mesh Report", "MeshReport", "Verifies that the mesh represents a solid, and returns a comprehensive report.", "IntraLattice", "Utils")
	{
	}

	protected override void RegisterInputParams(GH_InputParamManager pManager)
	{
		pManager.AddMeshParameter("Mesh", "Mesh", "Mesh to inspect.", (GH_ParamAccess)0);
	}

	protected override void RegisterOutputParams(GH_OutputParamManager pManager)
	{
		pManager.AddTextParameter("Report", "Report", "Report of inspection", (GH_ParamAccess)0);
	}

	protected override void SolveInstance(IGH_DataAccess DA)
	{
		Mesh val = null;
		if (DA.GetData<Mesh>(0, ref val) && ((CommonObject)val).IsValid)
		{
			string text = "";
			bool flag = true;
			text = "- Details -\n";
			m_nakedEdges = val.GetNakedEdges();
			if (m_nakedEdges == null)
			{
				text += "Mesh has 0 naked edges. \n";
			}
			else
			{
				text += $"Mesh has {m_nakedEdges.Length} naked edges. \n";
				flag = false;
			}
			bool flag2 = default(bool);
			bool flag3 = default(bool);
			if (val.IsManifold(true, ref flag2, ref flag3))
			{
				text += "Mesh is manifold. \n";
			}
			else
			{
				text += "Mesh is non-manifold. \n";
				flag = false;
			}
			if (val.SolidOrientation() == 1)
			{
				text += "Mesh is solid. \n";
			}
			else if (val.SolidOrientation() == 0)
			{
				text += "Mesh is not solid. \n";
				flag = false;
			}
			else
			{
				val.Flip(true, true, true);
				text += "Mesh is solid. (normals have been flipped) \n";
			}
			text = ((!flag) ? ("Mesh is INVALID.\n\n" + text) : ("Mesh is VALID.\n\n" + text));
			text = "- Overview -\n" + text;
			DA.SetData(0, (object)text);
		}
	}

	public override void DrawViewportWires(IGH_PreviewArgs args)
	{
		((GH_Component)this).DrawViewportWires(args);
		if (m_nakedEdges == null)
		{
			return;
		}
		Polyline[] nakedEdges = m_nakedEdges;
		foreach (Polyline val in nakedEdges)
		{
			if (val.IsValid)
			{
				args.Display.DrawPolyline((IEnumerable<Point3d>)val, (Color)Color.DarkRed);
			}
		}
	}
}


===== intralattice.csproj =====
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <AssemblyName>IntraLattice</AssemblyName>
    <GenerateAssemblyInfo>False</GenerateAssemblyInfo>
    <TargetFramework>net40</TargetFramework>
  </PropertyGroup>
  <PropertyGroup>
    <LangVersion>11.0</LangVersion>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <RootNamespace />
  </PropertyGroup>
  <ItemGroup />
  <ItemGroup>
    <Reference Include="Grasshopper" />
    <Reference Include="RhinoCommon" />
    <Reference Include="RhinoCommon" />
  </ItemGroup>
<PropertyGroup><PlatformTarget>x64</PlatformTarget></PropertyGroup></Project>

===== IntraLattice.Properties\Resources.cs =====
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Resources;
using System.Runtime.CompilerServices;

namespace IntraLattice.Properties;

[DebuggerNonUserCode]
[CompilerGenerated]
[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
internal class Resources
{
	private static ResourceManager resourceMan;

	private static CultureInfo resourceCulture;

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	internal static ResourceManager ResourceManager
	{
		get
		{
			if (object.ReferenceEquals(resourceMan, null))
			{
				ResourceManager resourceManager = new ResourceManager("IntraLattice.Properties.Resources", typeof(Resources).Assembly);
				resourceMan = resourceManager;
			}
			return resourceMan;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	internal static CultureInfo Culture
	{
		get
		{
			return resourceCulture;
		}
		set
		{
			resourceCulture = value;
		}
	}

	internal static Bitmap adjustUV
	{
		get
		{
			object @object = ResourceManager.GetObject("adjustUV", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap basicBox
	{
		get
		{
			object @object = ResourceManager.GetObject("basicBox", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap basicCylinder
	{
		get
		{
			object @object = ResourceManager.GetObject("basicCylinder", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap cleanNetwork
	{
		get
		{
			object @object = ResourceManager.GetObject("cleanNetwork", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap conformSA
	{
		get
		{
			object @object = ResourceManager.GetObject("conformSA", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap conformSP
	{
		get
		{
			object @object = ResourceManager.GetObject("conformSP", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap conformSS
	{
		get
		{
			object @object = ResourceManager.GetObject("conformSS", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap customCell
	{
		get
		{
			object @object = ResourceManager.GetObject("customCell", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap heterogenCustom
	{
		get
		{
			object @object = ResourceManager.GetObject("heterogenCustom", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap heterogenGradient
	{
		get
		{
			object @object = ResourceManager.GetObject("heterogenGradient", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap homogen
	{
		get
		{
			object @object = ResourceManager.GetObject("homogen", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap meshPreview
	{
		get
		{
			object @object = ResourceManager.GetObject("meshPreview", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap meshReport
	{
		get
		{
			object @object = ResourceManager.GetObject("meshReport", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap presetCell
	{
		get
		{
			object @object = ResourceManager.GetObject("presetCell", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap presetGradient
	{
		get
		{
			object @object = ResourceManager.GetObject("presetGradient", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal static Bitmap uniformDS
	{
		get
		{
			object @object = ResourceManager.GetObject("uniformDS", resourceCulture);
			return (Bitmap)@object;
		}
	}

	internal Resources()
	{
	}
}


===== IntraLattice.Properties.Resources.resx =====
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
<resheader name="resmimetype"><value>text/microsoft-resx</value></resheader><resheader name="version"><value>1.3</value></resheader><resheader name="reader"><value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value></resheader><resheader name="writer"><value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value></resheader><data name="heterogenCustom" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAABwMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAApxJREFUSEvtlU9ImmEcx7NITUuXGkhlFkGzf4xGukuHLm5sB4kuBkKHoNARozEQWXbKCJK8LHepU8SiuUO33YJkkWJLpE0zCUUPjW4brli1vvs9ryZrjU2tYx/48fI8z+/7fZ/nfX7P85bc8gcyijEKBde6YZjpJwpQPGcd14EvkUhczc3Nyba2tnfU1lBcmLPntVagFovFEb1ef7y0tITR0VGIRKJz6r8R80dCofCb3W4/SyQSODg4QCgUwvT0NKj/J403ZdIKp5Rm6VAoFOnl5WUkk0mkUilsb29jdXUVKysr0Ol0Z3w+35TNLwhZZWXlB61Wm/b5fGAzj8fj2NraypkvLi6ip6cHlGfOavKmm2Z+aLFYTiKRCPb39xGLxeD3+y+Zz83NoaKi4oTylRlZHggEAgtt5vf5+XlEo1Hs7e2BvWRzc/OSORtvb2//QRN5lZX+FyEt9W1LS0t6bW0Nu7u7CIfD2NnZwcbGxiXzhYUF9PX1nVPJfiRdaUb+b0R3xOIv95RKPGxtxYjBgPdkGAwG4fV6r5hbrVZWPV9Jl/enGWzVaDAxMQHH5CSemkzolkrx0my+Yj47O4vq6uoj0jzOSPPDTOWGqakpuFwuOJ1ONNbV4W55OcYGB3PmbrcbXV1dx7Sxr7O6vLlfU1NzymbHzGtra9npRFN9PbeSGYeDMzcajef0aaI0xudUhSCVSsP9/f05c5VKBY/Hg5nxcQz09sJms4EOVJrGGjlBEXTyeDzubrkwZxvsp0P2pKMDcrn8qKysbCCTWji5K5e9ZHh4GOvr6wgEAlyZPlCrWdW84TKLgP0sfr9yO2Uy2eeGhobToaEhGKhk5VVVh9QvpCiKZxR/u3K7KdjYCIWEdRQLM32Rfd6SpaTkFz+5ZH6PyxmIAAAAAElFTkSuQmCCCw==</value></data><data name="meshReport" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAApAIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAjlJREFUSEvtlEtoU0EUho9WSgVBhK5c2G601Ejt0kcS8qqYIHlBVkJUElzURWPcCZIWQunKmhI3gpFUGiuCSJRsFKRYA+riYhVBG0oCrqSozSI2SZPfM2VS094E+gi46Q+Hgbkz/3fuuZefdtUS6fX6Xo/Ho9jt9qjBYOiX262R2Wz2sXEpmUwiFovB6/WWXS7Xb6fTeUen0/XJY1sXd3rA4XC88Pv9K9lsFoVCYa0ymYwK9vHqwZsI0gdcp0FpoRYuUwcfMg67es5z14uRSAT5fH6d+cbKfJnD15HT+OUlvOomVAK0Ag+1S8v1wg16sniRsDxIWBrtQ+n1bfz5sdDQWNRyTkF1rAfz5wiP9xMWbAT2mJF2avHDT+9OEh61E152EeYHCMVr3NXEWRWs9PYeysEOvOklPO/khq7weukwxBSknVoIUH/a34lyoA3ZC4SZo2pYNXIK1YkzqyN5doiQPsH7DJq9OwSTyQRp1Vzi0Nz7WeSehrE0rm8IS2v+jeTnrW4kH4wjkUhsHqAoylo1gj3klxUj+TY2gOmpyVXzbQPqS8D4O2GSAWKtGbcMIGoXsC1APB6Hz+eD2+3+LG2ai8OtHA6Hi6lUalOAaDQKzqMK59F9zq990qa5OCGPM2TUarV+50v5jbB6QCgUgs1mKxqNRru8vjVptdpjFoslxCbZGqwewIGY45F2yeM7Uw1WCe7BVBvnU5CqGo2mcWruRNz5tMgkscqt1or/w70YoiNilVv/U0R/AeBAmCF6RMFRAAAAAElFTkSuQmCCCw==</value></data><data name="adjustUV" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAfwMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAxRJREFUSEvtk2tIk2EYhufcHEvZYi1/+CfRDi5FkCxs1lIjMIhSKBpF6o9SCkxrKzHNmjl1puZ5lZpl2AykIqzUMjMrT3mYWVrZgQ50wJIVZSR193zfnIR41l/RBRfv93x79zy897tx/inWDFsDh63TBsPW16Sc/MRWM8DwAUVkJXmdrWaAPjKCNLEVh+NFMsPC2Wp0LPsYvzMvRoPJvphcy1ZmEsnZ5scxCSbfkZbTTwkpj8crs7bmfqP1PtWe5tdDzV3JfubFVLDj8/kdodtDPnU9qEdRYc4PoUDARJpOWpoz2A+uk0LE5/MaAzesM91vrEGn8R56uluwTxXOxPGb1LC7JokN6UaqKY7PmzYGmKoqLiEmWo2lnh5YIffCnDkSGEoKsGC+02sul9tGe3eQCwe/Ozq02URNv4jF4vdyudeHJK0GpedOIysjBf7+/jAajdDpdAjapkRXZyNePG1HSfHJb74+K5/T0LcU5Vdq02vuNjKIOxiDRG080tN0yMvJwKkCPfarI6FUKsFgMBhAkaGl6RYeGuvx7HEr3rzsHJLpYW41MlCrVYiNiUbCkcNITUlCdlY69HlZWLLEA+7u7nB0dIR8+TLcrrmK5oab6Gi7gyePmvHqecfEBuzatRN790TiQHQUNIfjoEvWIjMjFcfzMpGcqEH+iWy4LnbBar9VqKkuR8PdG2hvqUM3Rfayp338AaGhoQgLC0NExG5ERe3DobhYJCXG4xgTWS5FVqhnY1ssc4GfrwLVVZdpmAKtTbV41FE/9gC64B8CgWCALvknE4W3tzdCgoNwMPYAtAkapB1NRg5FVnAyl1UmWwRfHwXbtO5WBRsZ88w2GwMxOc/W1naLRCIptbOz6xWJRAMKxUqo9kYiRadFVmYqnU5laQb69aDy6gXU3rwyoQEjIZNKpefodP3Ozk6/tm7ZjBS6Gz3dS/6JXPZeLpaV4Fp52ZQHWOAxJ5NKJEaBwGbAzc0VgQHr6Z8diWw61dkz+dMe8DezKLqtDg4O5+3t5/aIxaI+oVDYb2Vl9XHw8/+MB4fzB/s7jSTTDVEfAAAAAElFTkSuQmCCCw==</value></data><data name="customCell" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAIwEAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAALhJREFUSEvtld0JwzAMhP1o8N8GXqt0l4I3KqWrlM7gMdxTGoEfXFcRFArJB+bASOhkIsUcbCKldIW0GOP9fSMnhHCDfM1ttdZGqjld7hi4oOrNe/+E5uVSRnbOUY6oe3KQrbUXaEHiebkdgCc9QcoaS4Y+u+/goIKWC+nsdDGEvMDqfNrBIGZTBwQ7m9HHHAWG7LUAD5Fk0LSf6U8HTbQqeNDEq4LXtWbZIecB/ZN1rfzhqHN3jTEvwjCGbgK3NQUAAAAASUVORK5CYIIL</value></data><data name="meshPreview" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAmgQAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAABC9JREFUSEvtlGtQVGUYx5/dc3ZlCRUTG1HCS15KioFFyCXAPqCVReOMoGiORhdouLlc9iILKBClhljERRCBgpwmQFMEAoI2B7AgLEkkBhqjSByhEM3lzr93l2NEm40f++Bv5j975pw9v+c9z3POS/f5fxPmTGsi5HxypJyvi3Lh+yLlknGWMXbcG+nMVyud+H0hzrRE+Pu9E+xAC5mkWOUmGcwLmNfdkGo/3PnRSvxcsgqdRctwId0OFdr5t97dLLsS7SL5gxXNVzqRtXD7f7PHgexVrpJrhUE2g781vgRD59swtIVhQO+E65854JeTrEjhUlw6ugjfHLaBPm42Up6T9Ee5SDrDHMlO0NwVsWadtP20bvmo4Uouxn/XY3LwHCb6SnCzXm4q0F2yEh0FS3AxfSG+PvggvoyzQlWEBGkviG9Hr+WbjY4p1b+gdOa2H9hkabjVkYax/i8wPqDHBIvh+5fRX/MEej5djS7WokvZi02rr0+Yg89VFjgbLMaZQIJOwd2IdOL8BJ05e5+SflW1zxZDV6swcr0Ow7+W4EbTdlyrWGNqTVfRUrTlLEbLkQVoSJqLWq0MFaEczgSRKcd8RWCzqxV0M3GMpoei3CWT32baoafME73VG9Fz6jF0F6/AjyeW44c8e7Rm2qI5ha08cQ5qNTPlxhQHEJTr+FEHP5IK2mkUsVTDBoXv0heh/fjDJqHxty3HDq0ZtmhJXYDzb80z9bwmetZUW/4mN+bUa4RIFx4uakoUtNO4acmw34/HiaDZphYYY+xz06H5aHzTGufirVCrtkBlOG8mvpOMzWIon+HAXD8J2mncddSRcJYQ78MjcYMUuTtkKA6yRFm4DOXhUlSGTYtPs4GWvEL4eDchf5sIaT5i6Lx4RHnz2JFKcNVQl6Cdhs3gccVeGs3vJeTWiZCiEyPBl0PM0zw0Ch7sY5oRNTunXc8j5kUO6jfECDkiwq4iwpMaGpNHk4+gnck2f25kZw6hdIitbpBQ2E84fpVwtJvwfifh8GXCgYuEpGb2pI0ErZ4QVUMILycElhI8Ygh+W0RDgs6cPa48PLWEQ60zC6S2EyIqCbsKCFvfIfhnEYJOEtR1UwXCWIENSYTXlWzIcn5S0Jmj87DoLStYBm+tCN7xBN+DhI2xBE81ITSEQ7avFEWbZiGO9fz5UIJCw64nEtazlftHET7cSVCtlXQLOnO0CmnisVdtxiYuu6PhgxXI3m2FTE8eeasJWY+wp1klwidyHtW+lmjYPxdlMTJkRHDICmbDZ4NP8OJus11WI+jM8XMgaayX7MJ7W61HWnIfRU+5I/pqHP/a5IxfsnGbML7C55OtUa2SoTRQgpwtIsR5cMNqV15vdAi6uyKOXW8RkPzsA02xXhY3Va7SiX++QXfC2jGmceMHYhR8fYQz52+8d0pxn3uG6E9YwmZSRUkx3AAAAABJRU5ErkJgggs=</value></data><data name="heterogenGradient" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAAQMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAApZJREFUSEvtlVtIFGEUx/+u6e66pSlWloX2EFtYWhFhRGJRxPYiQRkJdnkxJTSjxK5m2q7besFSLATLoB7UB+0eKV1AJYrSwJSCEB+EsKdiTTOdf2fcacUE3V189AeHmTmc8//mO9+ZM5jjP8LEssXCx59mGVW0S4xiJ1WHz+wHAu0LUFYVhb7qVWhIBFaL+5+4evV9B+eBKJsRPfUJfkO91XvYcmw7C4w6ZcVsiOcBu616/Hx/Qj/KT7lk722yNYV9Z8E8PcZigZVaqNforAZcKQ6Ds/9GBNl9gfxSTr7eS94CeROs24DRAn+kaPGeI6cVZgtCa20cnENPY8muHLF88oXFLc7rYNNmsGQ+0rU0z5B6b7IaMfAy1W9Ead9GdmaQHdnk88RJ4sNWsMiAkRwgQkudmcIAZMibD3516Mk3O8h3B8m3R8ln8ZPElRLwrhm/rwahQkudniOAwWZCfWU0nD/qg8n2BDEpR5vU+1HcJHGWgm0WKA4TOiRV51KYhjQgqMiEb5VLwFqzjg8sizhwZz35SnZw3zxFvP+4lEa6yuPSXAQO1a2R5EvgWCHYmTKPjmB/th1eOEV8OB8sC8Gvy4BFS58ZWSD9sXQD5dBYDH63gVuXgqcDwPZ9E+IsAhvWYshuRJWW6hnngI3XwjGqOFziMSIubsYvg+xEfLku8Q9JUOwGfFZHhivTC0pC0NOcNCEeEynCNeDHbOn1LXKfCdoC4TwDRLsyvGQnsG6xHxS5dYuzSc7kIVhjBstDMZgPJLuivcc9ctVFWlKlzxtlgSdiLWDF8vG3vzce6QPqz8I9ctWdlIaiuzISf5oPgI27QLsJA+p3ogb7QpbYlJGrjgvpriyxtEwgWHP7hCp6SrvOoQH8BU+YZO+a7p1KAAAAAElFTkSuQmCCCw==</value></data><data name="presetGradient" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAATgMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAuNJREFUSEvtVE1IFGEY3svqqvszs4kU9GeNOzvr/vobmYymtNZa7Toz+zuj5lpQIrGrBQlBEEU/7B46eAk1MrA8FB2CTnbq6CUJEuokhOJP0cFIhK/3G8ectSm91cEHHt7nfb/heT52Z17dDv4fGI3GhsLCwiql/a3HGs+UFp87ioqKXEqrM5vNVlzWOg2YTKYMML1urNGn8UzRx8BQgposKCjYD9wHmjYYDAfBSr/muAlwOJCfnz8IdVirbpo9BN4CXtfr9Rfy8vISoJvBphp4AGjEnjmABzM0TX8KBFont8OWlpNvTvj9L5qa/UONjU13WbYpzbJsrK6Orff5juKQXOAATohM916+gmKJri0ZjXfOhWPt74SI9JrjpSE+HL8RbIsmT4dixwMcd0ix3QAOEMKR6SAXQ2V2L7pzLyvXEB9H/lNBWasZaG2bjYldUxTtHafsnixl86RACxTlPgLcq9huYD0gxCeQjalAGPim8/ML6GwoKs/U5ARp7svi4sqlntSEze7NUkzFWgBT8feANl5EtKNSDsDmcTEp95tpc1TOJM/3vP+29PV7X//AMwhNwfzvAWEI4AQR2curNgKkbjQyMorQ6qomfywvr/bjgPKq7QREp/mwhBhntRyQaO9G8wsL8D8k5Jma8Bz8REsrPb19E3ChLKMEMFsGRDqQw1WLhh89kasQ7USBM2FZqxnixdmOrotTDlfNOOOqyQJToCGgFgJqtQM4IfwxyMXhLfFth5/h7ZmkaN/LMto7aLO5r1G0Ryy1uev3lDLa34HT6ZpxOj0fTCZyaiuaCfKtmSx+RZC7HhPW4gxJllwFigRRzBoMBF4ZuYCdcxN2yhh89vdh3zxf11CfAkcVPYbPsIaV8QDWw224mAQ8B7MQ0A1Wh4EW2VQNgiAyVqs1regGi8Uib1L1HM/wmTKXYJ7EGrbqbrhgCdYAk1JzoTZV409zMHeQJPlrXaugvU138I+g0/0ELVpvgBc1D7cAAAAASUVORK5CYIIL</value></data><data name="uniformDS" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAQQMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAtZJREFUSEvtVNlL1GEUPeOo2UtQ/0JgpdLyUmnkMuMktNBmloZW0B600L7XSz2EuYEyqSmVla06E2pQaabRg6+JT+aWFgaSFeOMM97O9fcLehlzCKIHD1z4+H6/79x7zz3fhyn8/0gA4uwRcK6IQl9SGHwajkj0p1jh1G/mb6EjFoi0R6LCMQ2esnQEHmyHfCmBDF6H3FkFKVqMQGo4RuxWVOq/5rHJQQ84otC2cza8w1UQ/1NIy1mIrxoycgvSuJ/JzkA6d0C2zYKXidpCSqKVK3l5JqT1IuMSZHzNJG9OQkrXQl6QvG41JH8Bk8yE1xaG2+bxibEEiFFZhu8axGN1jHrIW679tZDRh5Dmo5DhfMjnIxB3KqRjA4RdeOKBuSZNcNgiUFyeAb+/xiAda4DIc64vQwIuJnjEBMcg3wqZgIncDkj3FosUxCDALkpNmuBIm47eag609RxlyTKINcq3cu8CZ3GaEq2HvNwFqadUBQshtcu5R6k48AGTJjgSacOhUqPS1vOs2m2Eko8+4aDvQZoOQYauQgYOsAMbO8iwSMcaSKIFPpMmOOhz72ARxMsZaLWjjw3iFrrGdx/iqYS82ku7ctgf2YUrGdKVzgQc+KQS8BL1VlGCpoOGFM3HGSe45iBfHzbIi5PoIN4Ftx2SF0uJEvh9PgdtRZ9JExw2K4oLl2Js6ArJ9kC+83L9YDTug3y9xsrZldqzjzbtybRI7TLIh3UWyYuGn0O+YdIEh1pNLdfJ9hvYweApg7RhI+QTu+rfbVTek2WRrk0WqYmHvF85PmCPWtykmRj8uSybl6dgEeRZmhG6Vs+7UihLHGVh5UqeOweSPYMXzYoK8/ifMf5UhONdDpN0sHKt1kXduzcbVf+SRSvPITm1D+2pUOgBVnVTW78+D34nfd5OK7ZzuE52kBuNgH7TykMm/x36JHN4JeyoN9mCEQ11i+791XM9hX8E4Ccrw5WuHG+10AAAAABJRU5ErkJgggs=</value></data><data name="homogen" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAsQIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAkZJREFUSEvtlF9IU1Ecx7+N0WD2x0IjC6r14sIk20tBVAslzaeCioQCXxIppMKgoD9rrM3FBKMeDHI+FkaiRSwIJdSWlEUFBmlUzN7aU08J3u6339nuFrfNzN0e/cCX3Z3L+Xy5955zsMAflEj8knWpf4XQAiy7BJz2AYHLQK0M2dJ3UvJxCSVX1cC8aRVJyIlEfx1+DJ10s8vjmr623DF1FPDK7Yxc/aqy+ZGRx5uh8fVe8mu35A4/3G5loMiul/83+dgu8nMH+aVTIiUjDfwWAP0O6MeA3caUf8ckf7GNnPRJ2iRSMnSA7AZ5C5xoAoMOJGRK5pvMjUk+WkW+PyU5T45LyWBdVs4bknawswzfLwI1xvS/Y5LH3eS7RvJtM/lGSp54c+RsA4erocvqChqK2THJR1zkq/3k2BHypZQ83p5XTj/YV4lpWbpnDE1+TPLhNeToHvL5PvKZlDzaMqs8XgMttBgJtU8MVS5NgDPsRDK6AexyLWLPjhVM3NxMPpWSB+Vzys8CqwxVfuQDHezZBJ0+mRgEPx638XqpnbH6JdSjMmZFrpAj4HDfVikQOSNgMgR6VoMn7GCs2qJccU4OqchSzGjhtLyiLLU76VkLdpSAUy0W5BnaizHY6/0trxB5Ul7Ppyvg3SqLckUlsLHUBk0us3L2S2Jg1G1RLmSPXCn52VsPavfTcg7IypICK/KVkuyRq55EXtdApBgzD2uh39sJPVyEZKFyRaMk58i9AKyX3dkgOaT2iTFcEGqyOFJPsoAB8AsFYq4Y5bNA3AAAAABJRU5ErkJgggs=</value></data><data name="basicCylinder" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAmAMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAy1JREFUSEvtVVtIk2EYfl1uOjXnStNYh2Un80Rpqct5mJWWumqJZgc08rgyD1lQWhc1lK1WmpRJ2EUlphO16GA4qCBLvCgM9UIoIqLYhdCCDKW1p++fP97q1m0PvPD9P+/zPt/7Pj/vT//xz4gm8koiSkgmKkkhOqUiOs3OBdy7MCIRn+Y8WJGggzLvJ+meC2yHZGK7USNHy5EQGNQrcDJKitL1vrZ0D4HtQIDoWSLRcp42P+wkitT4eUzdLgrF5FAWxu4koWnvUlieZeC+di0+96YCo7n4MaBBS/46ZIgFNsZR8PS5ofETfb9xIBgDxpjZ6DsXCV2CH3RKCbqrQnAzW4Zru4PQVrwaTTly5PgLLTx9brBZ46V+82zxF/VRaMlZhgvxvtCnSNHECn99tNPRBRfTb7PBcXj63OCSB66n4VtfBgYbY9GQGYjhW0q8a9nqeP7yMA1Ne5Y6zpb+TLyqDXZewDZeg84TG3EuToqO8jCY67agqyoUbdp1MOui0FmyGoZECRq3uMN2iZwX+Pi4CBguxXmFPyz3YjFSJ0d/6UJcSxJgREuwHCfYjxFMiYRP1S4IjD8oRO9ZJSrC/WDtUgA9YcC9JTDtI8BAsFYSxrIIVyNYboULAtNjZ/FrsABlG3xxN08O43Yprqg8oYsmGGMId9nN36QT7isJU/UuCLxqzoal7zDObw0A+pOBXq6DwJkO2MxRy6KMCcWxDyLfBQHbeC2eG3YgT+aFLmaouVKGgUoJmlMI5lxC5zZCK+vmxiaWq3dB4MOjYuC9ljc5DiP1q/C6akbAYTK7vZ0ZbUpgucwPpwXGHxai54wS5WESTHQo8KebjaiNG5Gb48YT5YT3Gt7kE04KqH08Rp/qM+1TQ8XMZAnaC4LRkCaFMVmMi2wsjQpCu4owpCZ0MJP79xPUnjTK0+cG26Qhu8TCidai6N81sYsBswp4EM46CIIpyw24PGOytZBQvZzs6UKyso0awdPnB25dq31EpjShYProSm8r20GTzbu8bJVrCHUb6WfeIvqRKqAptZDauVye5jziiRZyPxc24yIWp7hgBfNZxLFw59P+w1UQ/QW02ctcYwHVGwAAAABJRU5ErkJgggs=</value></data><data name="cleanNetwork" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAVAEAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAOlJREFUSEvdkb0NwjAQhSMqBqClQ0zgOjKidhuJLRATZBSWomEZcw4+Kzzx4kMJFDzp6Wzrfr7kmr/SSnzKTmerzHVd27YxhBDT+fn0ItaoVlfUOeei954lska1uiIlPOczErNGWFeVzxGJsZHeFUDrqioDCDEDOIjHA6m0ARKrGEBvXTaS4KczgN66bCTBAQxA36vLRhIcwAAwUiEJEjMA8wBMRGIEmD/ASIyRChOtxBiprA1qkcraAONevBZvh9uENOHTeBHfxcfh9kYpIS1yCd/EG/GiGgNexV8ZMPmL5monTkv+pZrmAYQqg4qG+I6sAAAAAElFTkSuQmCCCw==</value></data><data name="basicBox" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAeAIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAg1JREFUSEvtU99Lk2EYPWh/Q5GEbGs5c8vNfkzBdDXZjfCloWmFTrKrborhKC/sBwVZ0ZaRFhZGMZNGxRKJjKiEoKSCIqKBoqhR2czBbLrQ4vS9fnpX2zcY2IUHXp5z857znOd5Xyzj/4WUCWNlVlq4OmfFdKUhfUZUcSr+wct1mN2hhWfhenwI8V2G9MlXPsfc1Fsnn/lKGX3n5PjLvezrLOVccB+HnlSx/45EDuzn83b7RPN6RFUZCPFyfVrY22D5ffeSnc3uzfS3bOctj41nZB5oK2HH6a0832hlT7uDN49awyfXIuLfCCY0kDTIXux8pK9qvvPw6xoGeyvmO595X8c3gTK+8Ev8Fazno4u27083IdRlAjtyVRi4rHjYUIif9+sQObINsc49mBLcXYyYv0bhriLE7jkVfkCL0VAxeEoHXshRYeBxoLunFuQ58EG9UuPxqxZ87M0DvetAVSNK1uCwHqP9W0CfEWyTx5TQwF2Ax8ftisgJh1Lj8UM6fPpcBB7Tgq1GxFKe4HIuBrrN4BUD2GXBj5Qn2J2B8Q8F4HV5wWezMZ36JZsxOFwINmnAaxtUfLRkDVpNGAvI718k8JowkvIR1a7BpEjg0uBLmfwnpAxkLkj9HckmuGHG2O08DNpW42tCcYFkDQ5mYUhV54uo1qNRvhDdqUMofxUiosbj1pX4plp8GUsE4A85RfvAhERNNAAAAABJRU5ErkJgggs=</value></data><data name="conformSA" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAA3wIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAnRJREFUSEvtVElrU1EYPYmlYlf+AkGxCwUXbnQj1FlqHUAqTjggaFUEUYS2NG0GaxdSm7SmKJqmbTBOVDdCk6rFqgjiwmpdWFEXKm5VFKzN8I7nJi8Qh4VJdKUHLve+e+875zvf972H/ygZzWVoaQHG3MCEZssDpDSvt4+LRzOwVWSfPVOR9s9B8pkb/BAFb21DQmLpkkRcTjSJ3IpVI8UB8H4jeHknOFIPxg6DF7Vv3BQl0ghUeRywziwCU/3g1wh4fQ8YWAFGtoBWHORwCU68Dny6thAcbxLhBjC4EnygyI2TUR84sBt8qDl+BLxUqBMXUOt1wkoHwOQpsH0xeHaN1n0a58EbB0H/cjC8EUzHinDic2IsMFOpaQeHFemdOvC5CwytBU9Xg7cPifgK+PgYeGG7yI8W6ETRT8RXgdF1Ss1SRe2XWBDsXAZ2a38yDH6Rm6u7dC7BnlqdDxbgxHTOe0U5oui6RWqc3N2rzhHha+U9JOEOCT+SK1OTp21gr9xFF4DHp4ESoDg+2nQ/w1x4K7Kbm8En+1Rk5T8ooUSHuqkTPLkkmyrjJCEn5ypF6hR5BV54gboGYLZN9WsoRRG1KIdqFKFXNdiholaJ8IRcaH1vP/hG+e+RSKsi9k3BO5HOsl//PWREFFXOybg6p3d11klaLtKqSWsFeKAc1PWwhjPzYiHIORkUccaJatKl9BgnfZVIuhyZPE9qlChiOxnaBL5U8UNyYepUD8zTlRqNPyCSV5P+ubDcDryyjw3yRbrMRsHId9JWjoS+dv2uvkNOZDTzVAxyTvLS8yNmaEzPLouEETECWpZld/4C1PPz7eU/A+AbQyN66m5fZRIAAAAASUVORK5CYIIL</value></data><data name="conformSS" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAPQMAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAtJJREFUSEvtU+tLk2EcPRteGvQHRB+yaY55C4w+SfeiexStL11pRSkKXaSgKK9kmTWbvmZqFkYJWYkFGSEhrA8hNNqXml8CIaglZJNSZzo9/R73hutiOv3qgRf2sOc953fO+b2YxYyRb0JpYRTeFRkxWAiMquc8kKn/PX3kAXsKDegvjsFI6SLQcwr03wPduaASyQdy9KuRIy8KjgID2LYF5EPwcy14fSv4wA62Hpdnf0hkWk7kpc2KXMsAeyrBb3Vgwy6wcTdYux3sbxbRF+NOIhZRsbSuAHsdYNUG8MpK0FscctItYjXbwJYj4uIY+EREIxJRF4uNGGEFOCSPcw1YvVGIneDAbYloH3hrp7jbJAPcH3eiHEtn2TrNxJDpPQ6zlFkEth8GXUclEhGqky7KRezNuZCTL/UhkUYRfHYCfH5wik6KDBh024RQoqlYDQ6Xg0FNyNZJXOul7Gvg12qwfgf4SEhVJ+FOJhVRF3plS7w54FXpoTsPfCl5tx0KOamRqcukk/eXQk5674A3RLhhCXjRhGABQFnfoE73N9QFt5C8OgB+Oi15S/6V4uSHFB6Q6cvlt3Ly4bJ0JJ3ctBgpsTJ3buxoVnS0dhaw6lT/hipKuXi8XCYskEllUxy6k6d7wddyVk7qRfiCyUCnOY4+r5dut5vp6el98fHxy3SqiaFEfnMiX7Ai1NaCo7JNQ+KkZI6BVUsX0+fz0e/3MxAIRC6inLToTt5mycqukmjOSCwLjSybP4+dnZ3s6uoaE3G5XLTb7d9TU1OHkpKSfDrN/xHuxCXx9Ah5jRSsdr69uZkej2dMxOFwBNPS0vyJiYmZZrM5Tn99avizk7sW8KQphpqmsaOjg01NTVTkEssC/ZXIEe6kJBrD2bGxzpSUlAElYrPZ+iwWy+Rf8GT45UQJySpaEhISMpRIcnLy8IymD4fuZEQ/QolYrdaP+nEW0wXwE3Pdwqx6hL8hAAAAAElFTkSuQmCCCw==</value></data><data name="conformSP" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAxwIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAlxJREFUSEvtUltLVFEYXdqM4H/opQu+9xoV3a90gXrofiMwlEqIyECdcUyEckZHTUcLu1ChheSLQ5SQUIGElCRISNSTlQ/VFGSN48xqbc4eZqgEz+SjCzbsc/a3v/WttTbm8d+oKsSlag9G/fmI+4GUWRVAsT3OHZXAfn8eJgMFSNYtAYfPg19vgy/KQENSBZTaUvfweRBU89SjbSDvg+Ot4BXtu4+CfWe0DjokOSnRpa2+PLB5uSZuAb91gDf2gHf2gR07wR89Iu3PKHFNUi1b+laBsSDYuhm8vBp8c9FRMiGytu1gbzEYlZLevS5JTGFgAVIMg/FGsGEtGF6vxtpPdoJdsqZzNxjZIWXdWUpkpzIrsW1mhqYfDinQWADsPwY+PQl+b5A18r9eSl5VZJSEN4F3RRgVwcMjs1Qigl9DmvCqLjdr+qQmTzSBjevAlo2Oki8K/Nou8J6atiuTWJeLTExBTIUjmjyoHCYqwYET4OPjCle2tW3R/zXg2zpHSeymctoAXl8G1hZi2gdQK27b/Q1TMKQmzw+DH846SsJqmAiBP2VVSPuIzsfrwSllElmEpHlxfg9GlMHpcmCpbfVvmKAMyYOVmtAPjp3KKInK78FSR0mrLKspQEqWvlPTxfb67JAmMUqeHQI/npPneq5NNpMpKanxIun3YtBecY80Sc8KR8loiYLWK/qkV9S+ENN6lu9tae7IVjJwAPxcrpBll/HctS0z4c9MbhXJ93y8tsfZeKn1xNm6RLaSWi8S+i6zR9kwpIYkN6RJzLoAFNnfcwtLkrSf85grAL8BOKdwLH375ZQAAAAASUVORK5CYIIL</value></data><data name="presetCell" mimetype="application/x-microsoft.net.object.binary.base64"><value>AAEAAAD/////AQAAAAAAAAAMAgAAAFFTeXN0ZW0uRHJhd2luZywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EFAQAAABVTeXN0ZW0uRHJhd2luZy5CaXRtYXABAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAUwIAAAKJUE5HDQoaCgAAAA1JSERSAAAAGAAAABgIBgAAAOB3PfgAAAABc1JHQgCuzhzpAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAADiwAAA4sBdcsX+wAAAehJREFUSEtjGNZABIilIEw4cIXSVAHiQFwMxLJgHgTUQ2mqAZDhIEskwTyoBdGyDFOi5Rj+Y8NgVSQCkOGiECaDZZQ0g0GyJuvXrx/K////Vw/H587KbiPXAhRQYCXw7OBKPxTDL55XPrB/L5E+IOR9EP32leLB92+UD4Dw9WtSW0CGE2UB2PuqDF+/7BX+/++4KByfL2eHex9Ev3yOwBfPMYBdT5QF+cZMzw6086IYfqmG48DBOFYUH2CzYOdmIiwAKfjdyHvwXzP/ARC+V861BWQ4PgvOn2Y4OKuJ4X+8KsOXKFmGyWCDcAGQ5n/ZfHB8KwnienQL0HGaAcNDUPCCDcEHQIqxWbA7igVuAR5gAcSgfALCbiABDIBuwc0E9oOz3Zj/xytAvE9xBsOmMU0F4n0Qjlfl+HL04P7/Z86cgeNp06atAqkDasdWdhEPMozEnyzsqkMxfObMmdvq6+thPsBWdmEAHSCGhSOIDQcgQ3Zs23Zw586dB0B47ty5W0CGI1kAAuhlF/EAZMimTZvgePLkyQewWAACIMNBwYUXgMJSDMJk0AURuCyorSxHt4AggHlTAsyDFdHoFkyceLAo2v9/rBLrV4IZDAngrGRAFqDjeC2Bp0RlMCQgDMToEaQNpUckYGAAACxOjpxHF/rmAAAAAElFTkSuQmCCCw==</value></data></root>



